%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{article}
\pagestyle{headings}
\label{packages}
\usepackage[sc]{mathpazo}
\usepackage[scaled]{helvet} % ss
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[a4paper,pdftex,colorlinks=true,
	urlcolor=blue,pdfstartview=FitH]{hyperref}
\usepackage{graphicx}
\usepackage{amssymb,amsfonts,amsthm,amsmath}
\usepackage{titlesec}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[dvipsnames]{xcolor,colortbl}
\usepackage{caption}
\protect\usepackage{semantic}
\usepackage{bcprules, proof}
\usepackage{stmaryrd}
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
 \usepackage{float}
\usepackage{changepage}
\usepackage{setspace}
\usepackage{pstricks,pstricks-add,pst-math,pst-xkey}
\usepackage{multicol}
\usepackage[small,nohug,heads=vee]{diagrams}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{xargs}
\usepackage{chngcntr}
\usepackage{ulem}
\usepackage{cancel}
\crefname{enumi}{position}{positions}
\diagramstyle[labelstyle=\scriptstyle]
\titleformat{\section}[hang]% style du titre
  {\normalfont\LARGE\bfseries}% police du titre + numéro
  {\thesection}% numérotation
  {0.4in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\section}
  {-0.9in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite

\titleformat{\subsection}[hang]% style du titre
  {\normalfont\Large\bfseries}% police du titre + numéro
  {\thesubsection}% numérotation
  {0.2in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\subsection}
  {-0.7in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite


\titleformat{\subsubsection}[hang]% style du titre
  {\normalfont\large\bfseries}% police du titre + numéro
  {\thesubsubsection}% numérotation
  {0.1in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\subsubsection}
  {-0.6in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite


\titleformat{\paragraph}[hang]% style du titre
  {\normalfont\large\bfseries}% police du titre + numéro
  {\paragraph}% numérotation
  {0.1in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\paragraph}
  {-0.4in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite

\RequirePackage{listings}
\RequirePackage{amssymb}

\lstset{
  basicstyle={\ttfamily},
  framesep=2pt,
  frame=single,
  keywordstyle={\color{blue}},
  stringstyle=\itshape,
  commentstyle=\itshape,
  columns=[l]fullflexible,
  showstringspaces=false,
}

\lstdefinelanguage{why3}
{
morekeywords={namespace,predicate,function,inductive,type,use,clone,%
import,export,theory,module,end,in,with,%
let,rec,for,to,do,done,match,if,then,else,while,try,invariant,variant,%
absurd,raise,assert,exception,private,abstract,mutable,ghost,%
downto,raises,writes,reads,requires,ensures,returns,val,model,%
goal,axiom,lemma,forall},%
string=[b]",%
sensitive=true,%
morecomment=[s]{(*}{*)},%
keepspaces=true,
}
%literate=%
%{'a}{$\alpha$}{1}%
%{'b}{$\beta$}{1}%
%{<}{$<$}{1}%
%{>}{$>$}{1}%
%{<=}{$\le$}{1}%
%{>=}{$\ge$}{1}%
% {<>}{$\ne$}{1}%
% {/\\}{$\land$}{1}%
% {\\/}{ $\lor$ }{3}%
% {\ or(}{ $\lor$(}{3}%
% {not\ }{$\lnot$ }{1}%
% {not(}{$\lnot$(}{1}%
% {+->}{\texttt{+->}}{2}%
% % {+->}{$\mapsto$}{2}%
% {-->}{\texttt{-\relax->}}{2}%
% %{-->}{$\longrightarrow$}{2}%
% {->}{$\rightarrow$}{2}%
% {<->}{$\leftrightarrow$}{2}%

\lstnewenvironment{whycode}{\lstset{language=why3}}{}
\lstnewenvironment{ocamlcode}{\lstset{language={[Objective]Caml}}}{}

%\lstset{basicstyle={\ttfamily}}
\let\why\lstinline
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


\label{proclamations}
\newtheoremstyle{plain}
{\topsep}{\topsep}{\upshape}{}{}{:~}{ }
{\textsc{\hspace{-1.55cm} #2 \quad #1} \textsc{#3}}
\theoremstyle{plain}
\newtheorem{definition}{Definition}[subsection]
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{corr}[definition]{Corrolary}


\label{ML-Terms marcos}
\newcommand{\mlt}[1]{#1}
\newcommand{\tmapp}[2]{(#1 ~ #2)}
\newcommand{\tmlet}[3]{let~#1=#2~in~#3}
\newcommandx{\tmrec}[5][5=]{rec~#1_{#5}~#2 : #3.#4}
\newcommand{\varslash}[2]{#1 / #2}
\newcommand{\tmsbst}[3]{#1 [#2 \mapsfrom #3] }
\label{ML-Types marcros}
\newcommand{\ty}[1][]{\tau_{#1}}
\newcommandx{\tyarr}[4][1=1, 2=2, 3=\theta, 4=\rho]
	{\tau_{#1}\hspace*{-0.2cm}\stackrel{(#3,#4)}
	{\Rightarrow}\hspace*{-0.2cm}\tau_{#2}}
\newcommandx{\tyord}[2][2=]{\ty[#2]^{#1}}

%
%\newcommand{\tarrS}[4]
%	{\tau^{\mf{B}_{#3}}_{#1}
%	\stackrel{\Sigma_#4}{\longrightarrow} \tau_{#2}}


\newcommand{\bwedge}{\boldsymbol{~\wedge~}}
\newcommand{\bvee}{\boldsymbol{~\vee~}}
\newcommand{\brarr}{\boldsymbol{~\Rightarrow~}}
\label{ML-Typing marcos}
\newcommandx{\typerule}[5]{~\vdash  #1 : (#2, #3, #4) #5}

\label{Semantics marcos}
\newcommand{\evalstep}[4]{~#1_{|\mu_#2} \rightarrow #3_{|\mu_#4} ~}
\newcommand{\evalstar}[4]{~#1_{|\mu_#2} \rightarrow^{\star} #3_{|\mu_#4} ~}
\newcommand{\evalinfty}[2]{~#1_{|#2} \rightarrow \infty ~}
\newcommand{\eqv}[1]{#1 \thicksim #1'}
\newcommand{\eqvsbst}[2]{#1 \thicksim_{#2} #1'}
\label{Inlining macros}
\newcommand{\inlT}{\mathcal{T}}
\newcommand{\inlS}{\mathcal{S}}
\newcommand{\inlU}{\mathcal{U}}

\newcommand{\hookdownarrow}{\mathrel{\rotatebox[origin=c]{180}{$\hookleftarrow$}}}
\newcommand{\inlletarr}{\hookdownarrow}
\newcommand{\inlletplus}{\hookdownarrow^{+}}
\newcommand{\inlletNF}{\overset{\inlletplus}{NF}}
\newcommand{\inllet}[2]{#1 \hookdownarrow #2}
\newcommand{\inllett}[2]{#1 \inlletplus #2}


\newcommand{\ilarr}{\hookdownarrow}
\newcommand{\ilarrt}{\ilarr^{+}}
\newcommand{\ilNF}{\overset{\ilarrt}{NF}}
\newcommand{\il}[2]{#1 \ilarr #2}
\newcommand{\ilt}[2]{#1 \ilarrt #2}

\newcommand{\icarr}{\hookrightarrow}
\newcommand{\icarrt}{\icarr^{+}}
\newcommand{\icNF}{\overset{\icarrt}{NF}}
\newcommand{\ic}[2]{#1 \icarr #2}
\newcommand{\ict}[2]{#1 \icarrt #2}

%
\let\mf\mathfrak


\addtolength{\textwidth}{1.5cm}

\def\nrepeat#1#2{\count0=#1 \loop \ifnum\count0>0 \advance\count0 by -1 #2\repeat}

%\swapnumbers




\newcommand{\mem}{_{|\mu}}\newcommand{\memp}{_{|\mu'}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\glam}{\textit{ghost}-$\lambda$~}
\newcommand{\gml}{\textit{ghost}-ml~}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\var}[3]{#1^{#2}_{#3}}
\newcommand{\gvar}[3]{#1^{\mathfrak{B_{#2}}}_{\tau_{#3}}}
\newcommand{\gref}[3]
{#1^{\mathfrak{B_{#2}}}_{\mathtt{ref}~\tau_{#3}}}
\let\rvar\gref
\newcommand{\gvarT}[2]{#1^{\top}_{\tau_{#2}}}
\newcommand{\gvarF}[2]{#1^{\bot}_{\tau_{#2}}}
\newcommand{\gabst}[4]{\lambda \gvar{#1}{#2}{#3}. #4}
\newcommand{\gghost}[1]{\mathtt{ghost}~ #1}
\newcommand{\glet}[5]
{\mathtt{let}~\gvar{#1}{#2}{#3} = #4 ~ \mathtt{in}~ #5}
\newcommand{\gif}[3]{\mathtt{if}~#1~\mathtt{then}~#2~\mathtt{else}~#3}
\newcommand{\grech}[6]
	{\mathtt{rec}~\var{#1}{\mf{B_{#2}}}{}~\gvar{#3}{#4}{#5}~:~\tau_{#6}. t}
\newcommand{\grec}[4]
	{\mathtt{rec}~\var{f}{\mf{B_{#1}}}{}~\gvar{x}{#3}{#4}:\tau_{#2}.~t}
\newcommand{\gread}[3]{!\gref{#1}{#2}{#3}}
\newcommand{\gwrite}[4]{\gref{#1}{#2}{#3} := #4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%SEMANTICS
\newcommand{\leval}[4]{~#1_{|#2} \rightarrow_{\lambda} #3_{|#4} ~}
\newcommand{\geval}[4]{~#1_{|#2} \rightarrow_{g\lambda} #3_{|#4} ~}

\newcommand{\levalh}[4]{~#1_{|#2} \stackrel{\epsilon}{\rightarrow}_{\lambda} #3_{|#4} ~}
\newcommand{\gevalh}[4]{~#1_{|#2} \stackrel{\epsilon}{\rightarrow}_{g\lambda} #3_{|#4} ~}

\newcommand{\levalstar}[4]{~#1_{|#2} \rightarrow_{\lambda}^{\star} #3_{|#4} ~}
\newcommand{\gevalstar}[4]{~#1_{|#2} \rightarrow_{g\lambda}^{\star} #3_{|#4} ~}
\newcommand{\gstep}[2]{~#1 ~ {\rightarrow}_{g\lambda} ~ #2~}
\newcommand{\ghead}[2]{~#1~\stackrel{\epsilon}{\rightarrow}~#2~}
\newcommand{\gstar}[2]{~#1 ~ {\rightarrow}^{\star}_{g\lambda} ~ #2~}
\newcommand{\glhead}[2]{#1~\stackrel{\epsilon\quad}
										{\rightarrow_{g\lambda}}~#2}
\newcommand{\stepone}[2]{#1 ~ {\rightarrow}~ #2}
\let\eval\stepone





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\tarr}[3]{\tau^{\mf{B}_{#3}}_{#1} \rightarrow \tau_{#2}}
\newcommand{\tarrS}[4]
	{\tau^{\mf{B}_{#3}}_{#1}
	\stackrel{\Sigma_#4}{\longrightarrow} \tau_{#2}}

\newcommand{\sbst}[3]{#1 [#2 \mapsfrom #3] }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\grtitle}[2]{#1 & ::= &  & \textit{#2} \\}
\newcommand{\grhead}[3]{#1 & ::= & #2 & \textit{#3} \\}
\newcommand{\grcase}[2]{&  & #1 & \textit{#2} \\}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TYPING
\newcommand{\tystepone}[3]{\vdash_{g\lambda}  #1 : (#2, #3) }
\newcommand{\typrule}[5]{~\vdash_{g\lambda}  #1 : (#2, #3, #4) #5}

% ERASURE
\newcommand{\e}{\mathcal{E}}
\newcommand{\ebot}[1]{\e_{\bot}(#1)}
\newcommand{\etop}[1]{\e_{\top}(#1)}
\newcommand{\evar}[2]{\e_{#1}(#2)}


% CONSTANTS
\newcommand{\glvar}{\gvar{x}{}{}}
\newcommand{\glref}{\gref{r}{}{}}
\newcommand{\glabst}{\gabst{x}{}{}{t}}
\newcommand{\glapp}{t_1 ~ t_2}
\newcommand{\gltyping}{~\typrule{t}{\tau}{\mf{B}}{\Sigma}{}~}
\newcommand{\vardecl}{\text{var }\glref = v}
\newcommand{\gllet}{\glet{x}{}{}{t}{t}}
\newcommand{\glif}{\gif{t}{t}{t}}
\newcommand{\glrec}{\grec{}{}{}{}}
\newcommand{\glread}{!\gref{r}{}{}}
\newcommand{\glwrite}{\gref{r}{}{} := t}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Longdownarrow}{\rotatebox{90}{$\Longleftarrow$}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\lgvar}[2]{#1_{#2}}
\newcommand{\lgvarc}{x_{\tau}}

\newcommand{\lgabs}[3]{\lambda \lgvar{#1}{#2}.{#3}}
\newcommand{\lgabsc}{\lgabs{x}{\tau_2}{t_1}}

\newcommand{\lgapp}[2]{#1~#2}
\newcommand{\lgappc}{t_1~t_2}

\newcommand{\lglet}[4]{\text{let } \lgvar{#1}{#2} = #3 \text{ in } #4}
\newcommand{\lgletc}{\lglet{x}{\tau_2}{t_2}{t_1}}

\newcommand{\lgif}[3]{\text{ if } #1 \text{ then } #2 \text{ else } #3}
\newcommand{\lgifc}{\lgif{t_1}{t_2}{t_3}}

\newcommand{\lgrec}[5]{\text{rec } #1~\lgvar{#3}{#4} : #2 = #5}
\newcommand{\lgrecc}{\lgrec{g}{\tau_1}{x}{\tau_2}{t_1}}

\newcommand{\lgand}[2]{#1 \wedge #2}
\newcommand{\lgandc}{\lgand{t_1}{t_2}}

\newcommand{\lgor}[2]{#1 \bvee #2}
\newcommand{\lgorc}{\lgor{t_1}{t_2}}

\newcommand{\lgneg}[1]{\neg #1}

\newcommand{\lgexist}[3]{\exists \glvar{#1}{#2}. #3}
\newcommand{\lgexistc}{\lgexist{x}{\tau_2}{f_1}}

\newcommand{\lgforall}[3]{\forall \glvar{#1}{#2}. #3}
\newcommand{\lgforallc}{\lgforall{x}{\tau_2}{f_1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{TITLE}
\author{Léon}
%\date{\today}
\counterwithin{figure}{subsection}
\sloppy 
\begin{document}

\maketitle

\tableofcontents

\begin{abstract}
  This is the abstract...
\end{abstract}

\section{Introduction}

context: deductive program verification~\cite{filliatre11sttt}

main idea = if a program is using a HO function to write a loop, its
proof of correctness should not be more difficult than its imperative
counterpart using a for/while loop

motivating examples

related work 

\section{Programming Language}

mini-ML + global references + recursive functions

\subsection{Syntax}

\subsection{Semantics}

\subsection{Type System with Effects}

side effects + termination, independently
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Inlining}

Inlining of higher-order expressions is a syntactic transformation that simplifies every higher-order expression that appear in a program. Local variables are replaced by functional expression they introduce; formal parameters of functional type are substituted by actual arguments, and more generally applications of higher-order terms are progressively simplified until no higher-order expression is left. The rest of the source program,  remains syntactically unchanged. 

Is it always possible to transform a higher-order program into a first-order program that contains no higher-order sub-expression ? If the source ML-program is of some first-order type,  such as \texttt{int}, \textit{list bool}, \textit{unit}, etc., then obviously inlining should result in an ML-program that contains no higher-order expression: programs being \textit{closed}, \textit{well-typed} terms, the only higher-order expressions that might appear in a first-order input, are either local functional definition or functional's application, and those forms are precisely what inlining aims to eliminate.  

The most important thing to understand about inlining is that, by its nature, inlining is a \textit{syntactic} transformation; there is a little chance of any correlation between inlining of a source program and its formal semantics. Therefore, our main concern will be the \textbf{correctness} of inlining: it  should be \textit{deterministic} transformation, that always \textit{terminate}, and returns a first-order program that has exactly the same \textit{meaning} that the corresponding source program. 

Can we take as the source language for inlining the set of ML programs we defined in the previous section ? The interesting feature of ML programs is side effects, notably, reference assignment and recursive function non-termination. Suppose now that we want to inline 
$$t \triangleq \tmlet{F_{(int \rightarrow int) \rightarrow int}}{(r_{int}:= 42; \lambda f_{int \rightarrow int}. t_0)}{t_1} $$


Intuitively, inlining operation should not simplify the bounded expression 
$(r_{int}:= 42; \lambda f_{int \rightarrow int}. t_0)$ in order to prevent an assignment of variable $r$, so the result of inlining should be directly a substitution 
$$ I(t) \approx \tmsbst{t_1}{F}{(r_{int}:= 42; \lambda f_{int \rightarrow int}. t_0)} $$
Sadly, the semantics of $t_1$ is not preserved by inlining:  
 if $F$ has multiple occurrences in $t_1$, the variable assignment $r:=42$ will be multiplied, and if $f$ does not occur in $t_1$, then it will be lost. Even if $F$ occurs just once in $t_1$, we cannot be sure, that the initial order of assignments is preserved. And If we replace $r:=42$ in the example above by some recursive call that loops, from an always looping program $t$ we get an eventually terminating $I(t)$, so again the semantics is not preserved.

Another (de)-motivating example is the example of a higher-order function that is recursive:
\begin{whycode}
let swap f g x = 
	if x > 0 then swap f g (f x) 
	else if x < 0 then swap g f (g x
\end{whycode}
%$$t \triangleq  
%\text{ let } \text{ rec } \text{swap} =
%(\tmrec{\text{swap}}{f~x}{\texttt{int}}
%{\text{ if x = 0}
%\text{ then } (\text{swap} f (f x))
%  
%\text{ else } (\text{swap} (\lambda x.  x)} f_0\boldsymbol{)}~ $$


\textbf{Thus, some restrictions must be imposed on the source language}, before we can apply inlining \textit{safely}.



%
%$$ t \triangleq (\lambda f_{int \rightarrow int}. t_0 ~ (r_{int} := 42; \lambda x_{int}. x))$$






\subsection{Restrictions On The Source Language}

What restrictions should we impose to the source program syntax and typing, and that has exactly the \textit{same} meaning that 

syntax typing notations


\subsection{Inlining As Rewriting Strategy}

Short description of two steps
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Inlining Second-Order Variables}

Our first goal is to transform the input language $\inlT$ in such way that it
would contain no more second order binders. As we are interested in programs, 
i.e. well-typed closed terms, the only possible way for a variable $F$ to 
appear in a term $t$ of $\inlT$ is to be introduced by some local binding 
expression $\tmlet{F}{t_1}{t_2}$ (programs like $\lambda F. t$ will be
rejected by typing system). Of course, that does not mean that we have to define 
the inlining procedure for programs only. The definition we are going to give
should simply eliminate all local second-order bindings, ignoring the eventual
free second-order variables.

That is, with respect to our notations, the syntax of the resulting language
 $\inlS$ should respect the following grammar :\\[1em]\indent 
  $ s ::= l~|~w~|~(s~w) ~|~ \tmlet{l}{s_1}{s_2} ~|~ r:= c ~|~ !r \hfill \textsc{(Terms)}$ \\\indent 
  $ w ::= \lambda l. s ~|~ \tmrec{f}{x}{\tau}{s}\hfill \textsc{(Values)}$ \\\indent 
  $ l ::= x ~|~ f \hfill \textsc{(Binders)}$ \\\indent 
  $ c ::= x ~|~ \overline{n}~|~... \hfill \textsc{(Constants)}$\\[1em]

It is straightforward to see that $\inlS \subsetneq \inlT$. In particular,
terms of $S$ are in \textit{A-Normal Forms}, respects all typing restrictions 
we imposed on terms of $\inlT$ and has exactly the same \textit{CBV} semantics. 

Our goal is then to define the inlining procedure and show that it always terminates, resulting in some term $s \in \inlS$. 
%Most importantly, we will
%show that inlining procedure preserves the meaining of the source p 
To acheive this goal, let us start by describing all possible forms that inlining procedure can take in  \textit{one step}.

\begin{definition}[(One Step local bindings Inlining, $\hookdownarrow$)]
   Let $t$ be a term of the source language $\inlT$  such that $t \not\in \inlS$ and $t \neq F $. Thus $t$ contains at least one local binding of some second-order variable $F$ introduced by $\tmlet{F}{t_0}{t_1}$ construction.

Then the inlining of local bindings of $t$, is defined as a rewriting strategy
$\inllet{t}{t'}$ by the set of inference rules of \cref{fig:inl-let-d}.

\label{inlletrule-macro}
\newcommandx{\inlletrule}[5]
{\infrule[$I_1$-#1]
	{\inllet{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\inllet{#4}{#5}}}
	
\label{inllettrulet-macro}	
	\newcommandx{\inllettrule}[5]
{\infrule[$I_1$-#1]
	{\inllett{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\inllett{#4}{#5}}}


 	\begin{figure}[H]
  \begin{footnotesize}
	\begin{spacing}{1.01}
	\hrulefill
	\begin{adjustwidth}{6em}{-14em}
		\begin{multicols}{2}
		\infrule[$I_1$-Let$_0$]{}
			{\boldsymbol{\tmlet{F}{s_1}{s_2} \hookdownarrow 				
			\tmsbst{s_2}{F}{s_1}}}
		\end{multicols}
		\vspace*{-2em}
	\end{adjustwidth}
	\begin{adjustwidth}{-8em}{-4em}
		\begin{multicols}{2}	
		\inlletrule{Fun}
			{t_1}{t'_1}
 			{\lambda l. \boldsymbol{t_1}}{\lambda l.\boldsymbol{t'_1}}
		\inlletrule{App$_1$}
			{t_1}{t'_1}
			{(\boldsymbol{t_1}v)}{(\boldsymbol{t'_1}v)}
		\inlletrule{Let$_1$}
			{t_1}{t'_1}
			{\tmlet{\varslash{l}{F}}{\boldsymbol{t_1}}{t_2}}
			{\tmlet{\varslash{l}{F}}{\boldsymbol{t'_1}}{t_2}}
		\inlletrule{Rec}{t_1}{t'_1}
 			{\tmrec{f}{x}{\tau}{\boldsymbol{t_1}}}
 			{\tmrec{f}{x}{\tau}{\boldsymbol{t'_1}}}
		\inlletrule{App$_2$}
			{v}{v'}
			{(s\boldsymbol{v})}{(s\boldsymbol{v'})}	
		\inlletrule{Let$_2$}
			{t_2}{t'_2}
			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t_2}}}
			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t'_2}}}
		\end{multicols}
	\end{adjustwidth}	
	\hrulefill
	\end{spacing}
	\caption{ \textbf{Inlining of Second-Order Local Bindings}\hfill}
 	\label{fig:inl-let-d}
 	\end{footnotesize}
	\end{figure}
\end{definition}

As we can see, the $\ilarr$ relation consist in the head reduction rule \textsc{I$_1$-Let$_0$} and the set of contextual reductions are defined recursively, from left to right, on the immediate sub-term where a second-local binding take place. Then, the first phase of inlining is defined as follows: 

\begin{definition}([Multi-Step Inlining, $\inlletplus$]) The multi-step inlining $\inlletplus$ is the transitive closure of one-step inlining. That is, it is the smallest relation defined by the following inference rules:

$$\dfrac{\inllet{t}{t'}}{\inllett{t}{t'}}{~~(\textsc{$I_1$-step})}
\quad\dfrac{\inllett{t}{t'} 
\qquad \inllett{t'}{t''}}{\inllett{t}{t''}}{~~(\textsc{$I_1$-trans})}$$
\end{definition}

To achieve the goal we have fixed above, it is useful to state the following auxiliary lemmas and definitions :

\begin{lemma}[(Determinacy of $\inlletplus$)] 
	$\forall n \in \mathbb{N}.~ \forall t, t_1, t_2.
		(t \inlletarr^{n} {t_1} \bwedge t \inlletarr^{n} {t_2}) \brarr
			t_1 = t_2$.	\label{inllet-determ-l}	
\end{lemma}
\begin{proof} See \ref{inllet-determ-p}. \end{proof}

\begin{lemma}[($\inlletplus$ Preservation Properties)]
For any well-typed term $t$ such that\\ $\typerule{t}{\tau}{\theta}{\rho}$, if $\inllett{t}{t'}$ then
\begin{displaymath}
\begin{array}{l@{\hspace*{1cm}}l@{\hspace*{1cm}}l}
	(1)& FV(t') \subseteq FV(t) & \textsc{(free variables inclusion)} \\
	(2)& \typerule{t'}{\tau}{\theta}{\rho} &\textsc{(typing preservation)} \\
	(3)& t' \in \inlT & \textsc{(A-normal form preservation)}
\end{array}
\end{displaymath}
 \label{inllet-prop-l}
\end{lemma}
\begin{proof}
 By induction on the derivation of $\inllet{t}{t'}$. For detailed proof see
 \ref{inllet-prop-p}.
 \end{proof}



\begin{definition}[(Normal Forms For $\inlletplus$)]
	The set of normal forms for $\inlletplus$,  $\inlletNF$, is defined as follows: \quad
 $ \inlletNF \triangleq \{ t | t \in \inlT \bwedge 
 \forall t' \in \inlT. t~\cancel{\inlletplus}~t' \} $
\end{definition}

\begin{lemma}[(Normal Forms For $\inlletarr^\star$)] 
$ \inlletNF \backslash \{ F \} = \inlS.$
\label{inllet-nforms-l}
\end{lemma}
\begin{proof}
For detailed proof see \ref{inllet-nforms-p}.
\end{proof}

\begin{theorem}[(Termination of $\inlletplus$)] 
		The multi-step inlining always terminates: \\
		$\forall t_0~
	 			!\exists t_n : 
	 				  (\inllett{t_0}{t_n}) \brarr (t_n \in \inlletNF).$
\label{inllet-term-l}
\end{theorem}
\begin{proof} For detailed proof see \ref{inllet-term-p}. \end{proof}
 
\begin{corr}[(Second-Order Local Bindings Inlining)] blah\\
 $\forall t.~ 
	 			!\exists s : 
	 				(t \in \inlT \bwedge t \not\in \inlS) \brarr 
	 				  (\inllett{t}{s} \bwedge s \in \inlS).$
\end{corr}


\newpage
\subsubsection*{Inlining Second-Order Applications}

- output language subset

\label{icrule-macro}
\newcommandx{\icrule}[5]
{\infrule[$I_2$-#1]
	{\ic{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\ic{#4}{#5}}}

\newcommandx{\icrulehead}[3]
{\infrule[$I_2$-#1]
	{}
	{\ic{#2}{#3}}}
	

\label{ictrule-macro}	
	\newcommandx{\ictrule}[5]
{\infrule[$I_1$-#1]
	{\ict{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\ict{#4}{#5}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[(One Step Inlining Of Second-Order Calls, $\icarr$)]
bla	
	\begin{figure}[H]
	\begin{spacing}{1.01}
	\hrulefill
	\begin{adjustwidth}{-12em}{-4em}
	\begin{multicols}{2}
	\icrulehead{App$_0$}
		{(\lambda f. u~\omega)}
		{\tmsbst{u}{f}{\omega}}
	\icrulehead{Let$_0$}
		{(\boldsymbol{(}\tmlet{l}{u_1}{u_2}\boldsymbol{)} \boldsymbol{\omega})}
		{\tmlet{l}{u_1}{\boldsymbol{(u_2~\omega)}}}	
	\end{multicols}
	\vspace*{1em}
	\begin{multicols}{2}	
	\icrule{Fun}
		{s}{s'}
		{\lambda l. \boldsymbol{s}}{\lambda l. \boldsymbol{s'}}	
	\icrule{App$_1$}
		{s}{s'}
		{(\boldsymbol{s}w)}{(\boldsymbol{s'}w)}
	\icrule{Let$_1$}
		{s_1}{s'_1}
		{\tmlet{l}{\boldsymbol{s_1}}{s_2}}{\tmlet{l}{\boldsymbol{s'_1}}{s_2}}
	\icrule{Rec}
		{s}{s'}
		{\tmrec{f}{x}{\tau}{\boldsymbol{s}}}{\tmrec{f}{x}{\tau}{\boldsymbol{s'}}}	
	\icrule{App$_2$}
		{w}{w'}
		{(u\boldsymbol{w})}{(u\boldsymbol{w'})}
	\icrule{Let$_2$}
		{s_2}{s'_2}
		{\tmlet{l}{u_1}{\boldsymbol{s_2}}}{\tmlet{l}{u_1}{\boldsymbol{s'_2}}}
	\end{multicols}
	\end{adjustwidth}
	\hrulefill
	\caption{ \textbf{Inlining of Second-Order Applications}\hfill}
 	\label{fig:inl-app-d}
	\end{spacing}
	\end{figure}
\end{definition}

\begin{definition}([Multi-Step Inlining, $\inlletplus$]) The multi-step inlining $\inlletplus$ is the transitive closure of one-step inlining. That is, it is the smallest relation defined by the following inference rules:

%\begin{figure}[H]
%	\begin{spacing}{1.01}
%	\hrulefill
%	\begin{adjustwidth}{-8em}{0em}
%
%		\begin{multicols}{3}
%		\infrule[$I_1$-Step]{\inllet{t}{t'}{\inllett{t}{t'} 			
%			\tmsbst{s_2}{F}{s_1}}}
%		\inllettrule{$I_1$-Trans}{t_2}{t'_2}
%			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t_2}}}
%			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t'_2}}}
%		\end{multicols}
%	\end{adjustwidth}	
%	\hrulefill
%	\end{spacing}
%	\caption{ \textbf{Multi-Step Inlining of Second-Order Local Bindings}\hfill}
% 	\label{fig:inl-let-d}
%	\end{figure}

$$\dfrac{\inllet{t}{t'}}{\inllett{t}{t'}}{~~(\textsc{$I_1$-step})}
\quad\dfrac{\inllett{t}{t'} 
\qquad \inllett{t'}{t''}}{\inllett{t}{t''}}{~~(\textsc{$I_1$-trans})}$$
\end{definition}

- sos definition
- theorem 2	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Semantic Equivalence Relation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Semantic Equivalence Between Closed Terms}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{semantic equivalence}
\begin{definition}[(Semantic Equivalence)]
	Let $t$ and $t'$ be two well-typed closed terms of the source 
	language such that 
	
	$$
		\typerule{t}{\tau}{\theta}{\rho}{} \quad \typerule{t'}{\tau}{\theta}{\rho}{} 
	$$

	We define $\eqv{t}$, the \textit{semantic equivalence} between $t$ and $t'$, 
	by induction on the structure of type $\ty$ :
	
	\begin{itemize}
		\item[$(\alpha)$]

			if $\ty{} = \ty{}^0$ for some base type $\ty{}^0$, then $\eqv{t}$ iff
			$$	\forall \mu_0.(\evalinfty{t}{\mu_0} \bwedge \evalinfty{t'}{\mu_0})~
					\bvee ~ \exists \mu_1 \exists v: 
					\evalstar{t}{0}{v}{1} \bwedge \evalstar{t'}{0}{v}{1} $$
		
		\item[$(\beta)$]
			if $\ty = \tyarr$ for some types $\ty[1], \ty[2]$,
			then\\[0.2cm]
			$\hspace*{0em}\forall v_0, v'_0. ~ \eqv{v_0} ~ 
			\bwedge \typerule{v_0}{\ty[1]}{\bot_\theta}{\bot_\rho}{} ~~
			\bwedge \typerule{v'_0}{\ty[1]}{\bot_\theta}{\bot_\rho}{} $ \\[0.2cm]
			$\hspace*{1em}
			\Rightarrow \forall\mu_0.(\evalinfty{\tmapp{t}{v_0}}{\mu_0}
			\bwedge\evalinfty{\tmapp{t'}{v'_0}}{\mu_0})$\\[0.2cm]
			$\hspace*{2em}\bvee~(\exists \mu_1 \exists v_1, v'_1 : 
			 	\evalstar{\tmapp{t}{v_0}}{0}{{v_1}}{1} 
				\bwedge \evalstar{\tmapp{t'}{v'_0}}{0}{{v'_1}}{1}
				\bwedge~\eqv{v_1})$				
	\end{itemize}
	\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{lemma} 
		The semantic equivalence 	terms, $\thicksim$, is reflexive, 	
		symmetric and transitive relation.
	\end{lemma}
	
	\begin{proof}
		By straightforward induction on the structure of type of the terms, using 
		the fact that $\rightarrow^\star$ is an evaluation strategy, thus 
		deterministic.
	\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{lemma}
		$\forall t,t'.~ \eqv{t} \Leftrightarrow 
			(\forall v, v'.~\eqv{v}~\Rightarrow
			\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$
	\label{equiv-def-l}
	\end{lemma}
	
	\begin{proof} By induction on the structure of type $\ty[t]$.
	For Detailed proof, see \ref{equiv-def-p}.
	\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\begin{lemma}
		For any pair of states $\mu_0$, $\mu_1$ such that
		$\evalstar{{t_0}}{0}{{t_1}}{1}$ and $\evalstar{{t'_0}}{0}{{t'_1}}{1}$
		if $\eqv{t_0}$ then $\eqv{t_1}$.
		\label{equiv-red2-l}
	\end{lemma}
	
	\begin{proof}
		By induction on the structure of type of $t_0$. 
		For Detailed proof, see \ref{equiv-red2-p}.
	\end{proof}		

	\begin{corr} 
		For any pair of states $\mu_0$, $\mu_1$ such that
		$\evalstar{{t}}{0}{{v}}{1}$ and \mbox{$\evalstar{{t'}}{0}{{v'}}{1}$},
		if $\eqv{t}$ then $\eqv{v_1}$.
		\label{equivalence parallel preservation corr}
	\end{corr}
	
	
	
	\begin{lemma}
		For any state $\mu_0$, if $\evalstep{{t_0}}{0}{{t_1}}{0}$, then
		$t_0 \thicksim t_1$.
	\end{lemma}	
	\begin{proof}
		By Straightforward observation that $\rightarrow$ is an evaluation
		strategy, thus deterministic.
	\end{proof}		

	\begin{corr} 
		For any state $\mu_0$, if $\evalstar{{t}}{0}{{v}}{0}$, then		
		$t \thicksim v$.
	\end{corr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Semantics Equivalence Between Parallel Substitutions}

  



	\begin{definition}[(parallel substitutions)]
	Let $t$ be any well-typed term, $t_1, \dots t_n$ well-typed 
	\textit{\textbf{closed}} terms, and $x_1, \dots, x_n$ distinct variables.
	To fix the notation, 
	let $\sigma = [x_1 \mapsfrom t_1, \dots, x_n \mapsfrom t_n] $ be
	a finite map such that :  	
	$$\forall x\in\mathfrak{Dom}(\sigma).~x\notin BV(t)\bwedge\tau_x=
	\tau_{\sigma(x)}$$

	Then the parallel substitution $(t\sigma)$ is defined by induction on $t$ 
	as follows :
	\begin{displaymath}
	\begin{array}{lll}
	 (x_i\sigma)& \triangleq & \sigma(x_i)\\
	 (y\sigma)& \triangleq & y \\
	 ((t_1t_2)\sigma) & \triangleq & ((t_1\sigma)(t_2\sigma))\\
	 (\lambda y_{\tau}. t)\sigma & \triangleq & \lambda y_\tau. (t\sigma)\\
	 (rec~f~y_{\tau_1} : \tau_2 = t)\sigma & \triangleq 
	   & rec~f~y_{\tau_1} : \tau_2 = (t\sigma) \\
	 ((let~y_\tau = t_1~ in~ t_2)\sigma) & \triangleq 
	   & let~y_\tau = (t_1\sigma)~in~ (t_2\sigma)\\
	  (r_\tau := v)\sigma)	& \triangleq & r_\tau := (v\sigma) \\
	 (!r_\tau\sigma) & \triangleq & !r_\tau \\
	     	 
	\end{array}
	\end{displaymath}
	\label{}
	\end{definition}

	\begin{definition}[(equivalent parallel substitutions)]
	Let $t$ be a well-typed term. Then we define the semantic equivalence
	between two parallel substitutions $\sigma$ and $\sigma'$, 
	$\sigma \thicksim_t \sigma'$ as follows:
	\begin{itemize}
	\item[(1)] 
	  $(t\sigma)$ and $(t\sigma')$ are well-defined parallel substitutions
	\item[(2)]
	  $ \mathfrak{Dom}_\sigma = \mathfrak{Dom}_\sigma' = FV(t)$
	\item[(3)]
		$ \forall x \in \mathfrak{Dom}_\sigma.~ \sigma(x) \thicksim_t \sigma'(x)$
	\end{itemize}	 
	\label{equiv-subst-d}
	\end{definition}

	Note that from (1) it follows, that both $(t\sigma)$ and 
	$(t\sigma')$ are terms that well-typed, and from (2) and (3) it follows 
	that both $(t\sigma)$ and	 $(t\sigma')$ are \textit{\textbf{closed}} terms.
	
	The next lemma captures the intuition that plugging free variables inside a term by semantically equivalent, even thought syntactically different programs gives two programs for which the semantic equivalence is preserved:
	
	\begin{lemma} 
		$\forall t. \forall (\sigma, \sigma'). ~\eqvsbst{\sigma}{t}
		\Rightarrow \tmapp{t}{\sigma} \thicksim \tmapp{t}{\sigma'}.$ 
	\label{equiv-subst-l}
	\end{lemma}

	\begin{proof}
		By induction on the structure of term $t$. For detailed proof, see
		\ref{equiv-subst-p}.
	\end{proof}


\subsubsection*{Output Language}
TODO: Nice figure 

%\subsection{Inlining Higher-Order Programs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Specification Language}

\subsection{Ghost Code}

\begin{definition}[blah blah] blah
\end{definition}

\begin{theorem}[blah] 
blah
\end{theorem}

\begin{lemma}[blah blah blah]
blah
\end{lemma}

type system, erasure, proof of correctness of erasure

\subsection{Annotations}

requires, ensures, assert

\section{Putting Pieces Together}

\subsection{Orthogonality}

inlining adapted to specification language

\subsection{Experimental Evaluation}

\section{Conclusion and Perspectives}

blah blah

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section*{Appendices}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{Detailed proofs} 


	\subsection{Inlining Second-Order Local Bindings}
	

\begin{lemma}[(determinacy of $\inlletplus$)] 
	$\forall n \in \mathbb{N}.~ \forall t, t_1, t_2.
		(t \inlletarr^{n} {t_1} \bwedge t \inlletarr^{n} {t_2}) \brarr
			t_1 = t_2$.	
	\label{inllet-determ-p}	
\end{lemma}

\begin{proof}
Start by proving the base case (\textsc{$I_1$-step}) by case analysis, for each possible form of $t$, on the leftmost immediate sub-term of $t$ containing an occurrence of some second-order variable $F$. 
	  Do the remaining  (\textsc{$I_1$-trans}) case	by strong induction on $n$.  Back to \ref{inllet-determ-l}.
\end{proof}	
	
\begin{lemma}[($\inlletarr$ Preservation Properties)]
For any well-typed term $t$ such that\\ $\typerule{t}{\tau}{\theta}{\rho}$, if $\inllet{t}{t'}$ then
\begin{displaymath}
\begin{array}{l@{\hspace*{1cm}}l@{\hspace*{1cm}}l}
	(1)& FV(t') \subseteq FV(t) & \textsc{(free variables inclusion)} \\
	(2)& \typerule{t'}{\tau}{\theta}{\rho} &\textsc{(typing preservation)} \\
	(3)& t' \in \inlT & \textsc{(A-normal form preservation)}
\end{array}
\end{displaymath}
 \label{inllet-prop-p}
\end{lemma}

\begin{proof}
 By induction on the derivation of $\inllet{t}{t'}$.
 \label{TODO-inllet-prop-p}
 Back to \ref{inllet-prop-l}.
 \end{proof}	
	
%  \begin{lemma}
% 	If $\inllet{t}{t'}$, then $FV(t') \subseteq FV(t)$.
% 	\label{inllet-fv-p}
%  \end{lemma}
%
%\begin{proof}
% By induction on the derivation of $\inllet{t}{t'}$.  \\
% 	\noindent\textit{Case} \textsc{(Let$_0$)}\quad 
% 	$\tmlet{F}{s_1}{s_2} \hookdownarrow \tmsbst{s_2}{F}{s_1}$. 
% 	If $F \in FV(s_2)$, then 
% 	$$FV(t) = FV(s_1) \cup (FV(s_2) \backslash \{F\}) = FV(t') $$ 
% 	Otherwise  
% 	$$ FV(t') =  FV(s_2) \backslash \{F\} \subseteq (FV(s_1) \cup FV(s_2) \backslash \{F\}) =  FV(t)$$.
% Other cases are hold by straightforward induction. Back to \ref{inllet-fv-l}.
%\end{proof}	
%	
%	\begin{lemma}[($\inlletarr$, typing preservation)] For any well-typed term $t$
% such that\\ $\typerule{t}{\tau}{\theta}{\rho}$, if $\inllet{t}{t'}$
% then $\typerule{t'}{\tau}{\theta}{\rho}$.
% \label{inllet-ty-p}
%\end{lemma}
%
%\begin{proof} Observe that for the base case:
%$$\tmlet{F}{s_1}{s_2} \hookdownarrow \tmsbst{s_2}{F}{s_1} \quad \textsc{(Let$_0$)},$$ the restriction typing for term $s_1$, $\typerule{s_1}{\tau_{s_1}}{\bot_\theta}{\bot_\rho}$ guarantees that the only source of side effects or potential non-termination of $t$ is $s_2$, and the result follows immediately by LEMMA \label{TODO:typ-subst-lemma}. Other cases follow by straightforward induction on 
%the derivation of $\inllet{t}{t'}$. Back to \ref{inllet-ty-l}.
%\end{proof}
%	
%\begin{lemma}[($\inlletarr$, \textit{A-form})] 
% If $\inllet{t}{t'}$, then $t' \in \inlT$.
% \label{inllet-aform-p}
%\end{lemma}
%
%\begin{proof} Back to \ref{inllet-aform-l}.
%\end{proof}	
	
	
\begin{lemma}([Normal Forms For $\inlletarr^\star$]) = Output language S
 \label{inllet-nforms-p}.
\end{lemma}
\begin{proof}
Back to \ref{inllet-nforms-l}.
\end{proof}


\begin{theorem}([Termination of $\inlletarr^\star$])
\label{inllet-term-p}.
\end{theorem}
\begin{proof}
  Back to \ref{inllet-term-l}.
\end{proof}	
	
	
	
	\subsection{Inlining Second-Order Applications}



	\subsection{Semantic Equivalence Relation}
	\begin{lemma}
		$\forall t,t'.~ \eqv{t} \Leftrightarrow 
			(\forall v, v'.~\eqv{v}~\Rightarrow
			\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$
	\label{equiv-def-p}
	\end{lemma}

	\begin{proof}
		Let $v, v'$ be two arbitrary values satisfying $\eqv{v}$.
		From the formulation of lemma, it follows that
		$$	\typerule{t}{\tyarr[1][2][\theta_0][\rho_0]}{\theta}{\rho}{} ~~ 
				\typerule{t'}{\tyarr[1][2][\theta_0][\rho_0]}{\theta}{\rho}{}.$$
		where $\ty[2]$ can be either the some first-order type $\tyord{0}[2]$ or
		some arrow type $\tyarr[21][22][\theta_1][\rho_1].$ 
		We prove the lemma by induction on the structure of type $\ty[t]$.
	\begin{itemize}		
	
		\item[$(\Rightarrow)$] Assume $\eqv{t}$. Thus 		
		
		\begin{itemize}
		
		\item[$(\alpha)$] if $\ty[\tmapp{t'}{v'}] = \tyord{0}[2]$, then
		by definition of $\eqv{t}$, for any initial state $\mu_0$ either 
		$\tmapp{t'}{v'}$ and $\tmapp{t'}{v'}$ diverge both, 
		or there is some pair of values $v_1, v'_1$ and a state $\mu_1$ such that 
		$$\evalstar{\tmapp{t}{v}}{0}{{v_1}}{1} 
			\bwedge \evalstar{\tmapp{t'}{v'}}{0}{{v'_1}}{1} \bwedge~\eqv{v_1}.$$
		
		By the preservation of typing, $v_1$ and $v'_1$ are of some base 
		type $\tyord{0}[2]$, and from the fact that they are values, we deduce
		that $v_1 = v'_1$. Therefore,  $\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$.
			
		\item[$(\beta)$] Otherwise, 
		$\ty[\tmapp{t}{v}] = \tyarr[21][22][\theta_1][\rho_1]$.
		Let $v_0, v'_0$ be two arbitrary values satisfying $\eqv{v_0}$ and 
		$\ty[v_0] = \ty[21]$. We must show that for any initial state $\mu_0$,
		either both 
		$\tmapp{\tmapp{t}{v}}{v_0}$ and $\tmapp{\tmapp{t'}{v'}}{v'_0}$ diverge
		or there is a pair of values $v_1, v'_1$ and a state $\mu_1$ such that 
		$$\evalstar{\tmapp{\tmapp{t}{v}}{v_0}}{0}{{v_1}}{1} \bwedge
		\evalstar{\tmapp{\tmapp{t'}{v'}}{v'_0}}{0}{{v'_1}}{1} \bwedge~\eqv{v_1}.$$
		
		Obviously, if both $t$ and $t'$ both diverge,
		then so do $\tmapp{t}{v}$ and $\tmapp{t'}{v'}$, and consequently 
		$\tmapp{\tmapp{t'}{v'}}{v'_0}$ and $\tmapp{\tmapp{t'}{v'}}{v'_0}$.
		Otherwise, from the equivalence $\eqv{t}$ we can deduce that there are
		some values $v_2$, $v'_2$ and some intermediate state $\mu_2$ such that
		$$\evalstar{\tmapp{\tmapp{t}{v}}{v_0}}{0}{\tmapp{v_2}{v_0}}{2} \bwedge
		\evalstar{\tmapp{\tmapp{t'}{v'}}{v'_0}}{0}{\tmapp{v'_2}{v'_0}}{2} 
		\bwedge~\eqv{v_2}$$	
		By induction hypothesis on $\ty[\tmapp{t}{v}]=\ty[v]$, as $\eqv{v_2}$, we 
		get	$$ \tmapp{v_2}{v_0} \thicksim \tmapp{v'_2}{v'_0}.$$ Therefore, 
		$\tmapp{v_2}{v_0}$ diverges if and only if $\tmapp{v_2'}{v_0'}$ diverges 
		too, so again, $\tmapp{\tmapp{t'}{v'}}{v'_0}$ diverges if and only if 
		$\tmapp{\tmapp{t'}{v'}}{v'_0}$ diverges (by determinism of 
		$\rightarrow^\star$). Otherwise for some values $v_1, v'_1$ and a state
		$\mu_1$:
		$$\evalstar{\tmapp{v_2}{v_0}}{2}{{v_1}}{1} \bwedge
		\evalstar{\tmapp{v_2}{v'_0}}{2}{{v'_1}}{1} 
		\bwedge~\eqv{v_1}.$$ There, putting reduction chains together allow us to 
		conclude that $\tmapp{t}{v} \thicksim \tmapp{t'}{v'}.$ 
		\end{itemize}
		
	
		\item[$(\Leftarrow)$] Assume $(\forall v_0, v'.~\eqv{v}~\Rightarrow
		\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$. From the definition of 
		\mbox{$\tmapp{t}{v}\thicksim\tmapp{t'}{v'}$} we almost immediate have 
		that $\eqv{t}$. Back to \ref{equiv-def-l}.
				
		\end{itemize}	
	\end{proof}

	\begin{lemma}
		For any pair of states $\mu_0$, $\mu_1$ such that
		$\evalstar{{t_0}}{0}{{t_1}}{1}$ and $\evalstar{{t'_0}}{0}{{t'_1}}{1}$
		if $\eqv{t_0}$ then $\eqv{t_1}$.
		\label{equiv-red2-p}
	\end{lemma}
	
	\begin{proof}
		By induction on the structure of type of $t_0$. 
		\begin{itemize}
		\item[$(\alpha)$] if $\ty = \ty^0$ for some base type $\ty^0$, then
		
			\begin{itemize}
			\item[$(\alpha_1)$] if $t_0$ diverges, then by definition of 
			$\eqv{t_0}$, $t'_0$ diverges too. Also, $\rightarrow^\star$ being 
			deterministic, both $t_1$ and $t'_1$ diverge. Symmetrically, if 
			$t'_0$ diverges, $t_1$ and $t'_1$ diverge both as well. Therefore,
			$$\eqv{t_1}.$$
						
			\item[$(\alpha_2)$] Otherwise, neither $t_0$ or $t_{0}'$ diverge. Then
				as $\eqv{t_0}$ by hypothesis, it follows that 
					$$ \exists \mu_2 \exists v: 
					\evalstar{{t_0}}{0}{v}{2} \bwedge \evalstar{{t'_0}}{0}{v}{2}.$$
				The evaluation $\rightarrow^\star$ being deterministic, we have 
				necessarily that
					$$\evalstar{{t_1}}{1}{v}{2} \bwedge \evalstar{{t'_1}}{1}{v}{2}.$$
				As the state $\mu_1$ depends uniquely on the arbitrarily chosen 
				$\mu_0$, we deduce again that $$\eqv{t_1}.$$					
			\end{itemize}			
			
		\item[$(\beta)$] if $\ty$ is an arrow type $\tyarr$ for some types 
		$\ty[1], \ty[2]$,	let $v_0, v'_0$ be two arbitrary values satisfying:
		$$~\eqv{v_0}~\bwedge \typerule{v_0}{\ty[1]}{\bot_\theta}{\bot_\rho}{}.$$
		By hypothesis, we have the reduction steps:
		$$\evalstar{{t_0}}{0}{{t_1}}{1}\quad\evalstar{{t'_0}}{0}{{t'_1}}{1}$$						which induce respectively: 
		$$\evalstar{\tmapp{t_0}{v_0}}{0}{\tmapp{t_1}{v_0}}{1} \quad
		\evalstar{\tmapp{t'_0}{v'_0}}{0}{\tmapp{t'_1}{v'_0}}{1}$$	
		From the definition of $\eqv{t_0}$, it follows that
		$${\tmapp{t_0}{v_0}} \thicksim {\tmapp{t'_0}{v'_0}}.$$
		Therefore, the induction hypothesis on $\ty[2]$ yields 
		$${\tmapp{t_1}{v_0}}\thicksim{\tmapp{t'_1}{v'_0}}.$$
		Finally, as $v_0, v'_0$ are arbitrary chosen values (satisfying the
		two conditions above), the result holds for any such values, 
		therefore by lemma \ref{equiv-def-l},
		$$\eqv{t_1}.$$ Back to \ref{equiv-red2-l}.	
		\end{itemize}	
	\end{proof}		

	\begin{lemma}

	\label{equiv-subst-p}
	\end{lemma}

	\begin{proof}
	Back to \ref{equiv-subst-l}.
	\end{proof}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{References} 
%\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{abbrevs,demons,demons2,demons3,team,crossrefs}

\end{document}

(*
Local Variables:
compile-command: "rubber -d main"
End:
*)
