%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{article}
\pagestyle{headings}
\label{packages}
\usepackage[sc]{mathpazo}
\usepackage[scaled]{helvet} % ss
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[a4paper,pdftex,colorlinks=true,
	urlcolor=blue,pdfstartview=FitH]{hyperref}
\usepackage{graphicx}
\usepackage{amssymb,amsfonts,amsthm,amsmath}
\usepackage{titlesec}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[dvipsnames]{xcolor,colortbl}
\usepackage{caption}
\protect\usepackage{semantic}
\usepackage{bcprules, proof}
\usepackage{stmaryrd}
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
 \usepackage{float}
\usepackage{changepage}
\usepackage{setspace}
\usepackage{pstricks,pstricks-add,pst-math,pst-xkey}
\usepackage{multicol}
\usepackage[small,nohug,heads=vee]{diagrams}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage{xargs}
\usepackage{chngcntr}
\usepackage{ulem}
\usepackage{cancel}
\crefname{enumi}{position}{positions}
\diagramstyle[labelstyle=\scriptstyle]
\titleformat{\section}[hang]% style du titre
  {\normalfont\LARGE\bfseries}% police du titre + numéro
  {\thesection}% numérotation
  {0.4in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\section}
  {-0.7in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite

\titleformat{\subsection}[hang]% style du titre
  {\normalfont\Large\bfseries}% police du titre + numéro
  {\thesubsection}% numérotation
  {0.2in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\subsection}
  {-0.6in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite


\titleformat{\subsubsection}[hang]% style du titre
  {\normalfont\large\bfseries}% police du titre + numéro
  {\thesubsubsection}% numérotation
  {0.1in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\subsubsection}
  {-0.5in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite


\titleformat{\paragraph}[hang]% style du titre
  {\normalfont\large\bfseries}% police du titre + numéro
  {\paragraph}% numérotation
  {0.1in}% espacement numéro/titre <--- valeur à changer
  {}% police spécifique du titre
\titlespacing*{\paragraph}
  {0.0in}% espacement gauche
  {0.2in}% espacement avant
  {0.2in}% espacement après
  [0.1in]% espacement à droite

\RequirePackage{listings}
\RequirePackage{amssymb}

\lstset{
  basicstyle={\ttfamily},
  framesep=2pt,
  frame=single,
  keywordstyle={\color{blue}},
  stringstyle=\itshape,
  commentstyle=\itshape,
  columns=[l]fullflexible,
  showstringspaces=false,
}

\lstdefinelanguage{why3}
{
morekeywords={namespace,predicate,function,inductive,type,use,clone,%
import,export,theory,module,end,in,with,%
let,rec,for,to,do,done,match,if,then,else,while,try,invariant,variant,%
absurd,raise,assert,exception,private,abstract,mutable,ghost,%
downto,raises,writes,reads,requires,ensures,returns,val,model,%
goal,axiom,lemma,forall},%
string=[b]",%
sensitive=true,%
morecomment=[s]{(*}{*)},%
keepspaces=true,
}
%literate=%
%{'a}{$\alpha$}{1}%
%{'b}{$\beta$}{1}%
%{<}{$<$}{1}%
%{>}{$>$}{1}%
%{<=}{$\le$}{1}%
%{>=}{$\ge$}{1}%
% {<>}{$\ne$}{1}%
% {/\\}{$\land$}{1}%
% {\\/}{ $\lor$ }{3}%
% {\ or(}{ $\lor$(}{3}%
% {not\ }{$\lnot$ }{1}%
% {not(}{$\lnot$(}{1}%
% {+->}{\texttt{+->}}{2}%
% % {+->}{$\mapsto$}{2}%
% {-->}{\texttt{-\relax->}}{2}%
% %{-->}{$\longrightarrow$}{2}%
% {->}{$\rightarrow$}{2}%
% {<->}{$\leftrightarrow$}{2}%

\lstnewenvironment{whycode}{\lstset{language=why3}}{}
\lstnewenvironment{ocamlcode}{\lstset{language={[Objective]Caml}}}{}

%\lstset{basicstyle={\ttfamily}}
\let\why\lstinline
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


\label{proclamations}
\newtheoremstyle{plain}
{\topsep}{\topsep}{\upshape}{}{}{:~}{ }
{\textsc{\hspace{-1.55cm} #2 \quad #1} \textsc{#3}}
\theoremstyle{plain}
\newtheorem{definition}{Definition}[subsection]
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{corr}[definition]{Corrolary}


\label{ML-Terms marcos}
\newcommand{\mlt}[1]{#1}
\newcommand{\tmapp}[2]{(#1 ~ #2)}
\newcommand{\tmlet}[3]{let~#1=#2~in~#3}
\newcommandx{\tmrec}[5][5=]{rec~#1_{#5}~#2 : #3.#4}
\newcommand{\varslash}[2]{#1 / #2}
\newcommand{\tmsbst}[3]{#1 [#2 \mapsfrom #3] }
\label{ML-Types marcros}
\newcommand{\ty}[1][]{\tau_{#1}}
\newcommandx{\tyarr}[4][1=1, 2=2, 3=\theta, 4=\rho]
	{\tau_{#1}\hspace*{-0.2cm}\stackrel{(#3,#4)}
	{\Rightarrow}\hspace*{-0.2cm}\tau_{#2}}
\newcommandx{\tyord}[2][2=]{\ty[#2]^{#1}}

%
%\newcommand{\tarrS}[4]
%	{\tau^{\mf{B}_{#3}}_{#1}
%	\stackrel{\Sigma_#4}{\longrightarrow} \tau_{#2}}


\newcommand{\bwedge}{\boldsymbol{~\wedge~}}
\newcommand{\bvee}{\boldsymbol{~\vee~}}
\newcommand{\brarr}{\boldsymbol{~\Rightarrow~}}
\label{ML-Typing marcos}
\newcommandx{\typerule}[5]{~\vdash  #1 : (#2, #3, #4) #5}

\label{Semantics marcos}
\newcommand{\evalstep}[4]{~#1_{|\mu_#2} \rightarrow #3_{|\mu_#4} ~}
\newcommand{\evalstar}[4]{~#1_{|\mu_#2} \rightarrow^{\star} #3_{|\mu_#4} ~}
\newcommand{\evalinfty}[2]{~#1_{|#2} \rightarrow \infty ~}
\newcommand{\eqv}[1]{#1 \thicksim #1'}
\newcommand{\eqvsbst}[2]{#1 \thicksim_{#2} #1'}
\label{Inlining macros}

\newcommand{\inlS}{\mathcal{S}}
\newcommand{\inlU}{\mathcal{U}}
\newcommand{\inlsrc}{\textit{ML}^{^2}}
\newcommand{\inlT}{\inlsrc}

\newcommand{\hookdownarrow}{\mathrel{\rotatebox[origin=c]{180}{$\hookleftarrow$}}}
\newcommand{\inlletarr}{\hookdownarrow}
\newcommand{\inlletplus}{\hookdownarrow^{+}}
\newcommand{\inlletNF}{\overset{\inlletplus}{NF}}
\newcommand{\inllet}[2]{#1 \hookdownarrow #2}
\newcommand{\inllett}[2]{#1 \inlletplus #2}


\newcommand{\ilarr}{\hookdownarrow}
\newcommand{\ilarrt}{\ilarr^{+}}
\newcommand{\ilNF}{\overset{\ilarrt}{NF}}
\newcommand{\il}[2]{#1 \ilarr #2}
\newcommand{\ilt}[2]{#1 \ilarrt #2}

\newcommand{\icarr}{\hookrightarrow}
\newcommand{\icarrt}{\icarr^{+}}
\newcommand{\icNF}{\overset{\icarrt}{NF}}
\newcommand{\ic}[2]{#1 \icarr #2}
\newcommand{\ict}[2]{#1 \icarrt #2}

%
\let\mf\mathfrak


\addtolength{\textwidth}{1.5cm}

\def\nrepeat#1#2{\count0=#1 \loop \ifnum\count0>0 \advance\count0 by -1 #2\repeat}

%\swapnumbers




\newcommand{\mem}{_{|\mu}}\newcommand{\memp}{_{|\mu'}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\glam}{\textit{ghost}-$\lambda$~}
\newcommand{\gml}{\textit{ghost}-ml~}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\var}[3]{#1^{#2}_{#3}}
\newcommand{\gvar}[3]{#1^{\mathfrak{B_{#2}}}_{\tau_{#3}}}
\newcommand{\gref}[3]
{#1^{\mathfrak{B_{#2}}}_{\mathtt{ref}~\tau_{#3}}}
\let\rvar\gref
\newcommand{\gvarT}[2]{#1^{\top}_{\tau_{#2}}}
\newcommand{\gvarF}[2]{#1^{\bot}_{\tau_{#2}}}
\newcommand{\gabst}[4]{\lambda \gvar{#1}{#2}{#3}. #4}
\newcommand{\gghost}[1]{\mathtt{ghost}~ #1}
\newcommand{\glet}[5]
{\mathtt{let}~\gvar{#1}{#2}{#3} = #4 ~ \mathtt{in}~ #5}
\newcommand{\gif}[3]{\mathtt{if}~#1~\mathtt{then}~#2~\mathtt{else}~#3}
\newcommand{\grech}[6]
	{\mathtt{rec}~\var{#1}{\mf{B_{#2}}}{}~\gvar{#3}{#4}{#5}~:~\tau_{#6}. t}
\newcommand{\grec}[4]
	{\mathtt{rec}~\var{f}{\mf{B_{#1}}}{}~\gvar{x}{#3}{#4}:\tau_{#2}.~t}
\newcommand{\gread}[3]{!\gref{#1}{#2}{#3}}
\newcommand{\gwrite}[4]{\gref{#1}{#2}{#3} := #4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%SEMANTICS
\newcommand{\leval}[4]{~#1_{|#2} \rightarrow_{\lambda} #3_{|#4} ~}
\newcommand{\geval}[4]{~#1_{|#2} \rightarrow_{g\lambda} #3_{|#4} ~}

\newcommand{\levalh}[4]{~#1_{|#2} \stackrel{\epsilon}{\rightarrow}_{\lambda} #3_{|#4} ~}
\newcommand{\gevalh}[4]{~#1_{|#2} \stackrel{\epsilon}{\rightarrow}_{g\lambda} #3_{|#4} ~}

\newcommand{\levalstar}[4]{~#1_{|#2} \rightarrow_{\lambda}^{\star} #3_{|#4} ~}
\newcommand{\gevalstar}[4]{~#1_{|#2} \rightarrow_{g\lambda}^{\star} #3_{|#4} ~}
\newcommand{\gstep}[2]{~#1 ~ {\rightarrow}_{g\lambda} ~ #2~}
\newcommand{\ghead}[2]{~#1~\stackrel{\epsilon}{\rightarrow}~#2~}
\newcommand{\gstar}[2]{~#1 ~ {\rightarrow}^{\star}_{g\lambda} ~ #2~}
\newcommand{\glhead}[2]{#1~\stackrel{\epsilon\quad}
										{\rightarrow_{g\lambda}}~#2}
\newcommand{\stepone}[2]{#1 ~ {\rightarrow}~ #2}
\let\eval\stepone





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\tarr}[3]{\tau^{\mf{B}_{#3}}_{#1} \rightarrow \tau_{#2}}
\newcommand{\tarrS}[4]
	{\tau^{\mf{B}_{#3}}_{#1}
	\stackrel{\Sigma_#4}{\longrightarrow} \tau_{#2}}

\newcommand{\sbst}[3]{#1 [#2 \mapsfrom #3] }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\grtitle}[2]{#1 & ::= &  & \textit{#2} \\}
\newcommand{\grhead}[3]{#1 & ::= & #2 & \textit{#3} \\}
\newcommand{\grcase}[2]{&  & #1 & \textit{#2} \\}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TYPING
\newcommand{\tystepone}[3]{\vdash_{g\lambda}  #1 : (#2, #3) }
\newcommand{\typrule}[5]{~\vdash_{g\lambda}  #1 : (#2, #3, #4) #5}

% ERASURE
\newcommand{\e}{\mathcal{E}}
\newcommand{\ebot}[1]{\e_{\bot}(#1)}
\newcommand{\etop}[1]{\e_{\top}(#1)}
\newcommand{\evar}[2]{\e_{#1}(#2)}


% CONSTANTS
\newcommand{\glvar}{\gvar{x}{}{}}
\newcommand{\glref}{\gref{r}{}{}}
\newcommand{\glabst}{\gabst{x}{}{}{t}}
\newcommand{\glapp}{t_1 ~ t_2}
\newcommand{\gltyping}{~\typrule{t}{\tau}{\mf{B}}{\Sigma}{}~}
\newcommand{\vardecl}{\text{var }\glref = v}
\newcommand{\gllet}{\glet{x}{}{}{t}{t}}
\newcommand{\glif}{\gif{t}{t}{t}}
\newcommand{\glrec}{\grec{}{}{}{}}
\newcommand{\glread}{!\gref{r}{}{}}
\newcommand{\glwrite}{\gref{r}{}{} := t}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Longdownarrow}{\rotatebox{90}{$\Longleftarrow$}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\lgvar}[2]{#1_{#2}}
\newcommand{\lgvarc}{x_{\tau}}

\newcommand{\lgabs}[3]{\lambda \lgvar{#1}{#2}.{#3}}
\newcommand{\lgabsc}{\lgabs{x}{\tau_2}{t_1}}

\newcommand{\lgapp}[2]{#1~#2}
\newcommand{\lgappc}{t_1~t_2}

\newcommand{\lglet}[4]{\text{let } \lgvar{#1}{#2} = #3 \text{ in } #4}
\newcommand{\lgletc}{\lglet{x}{\tau_2}{t_2}{t_1}}

\newcommand{\lgif}[3]{\text{ if } #1 \text{ then } #2 \text{ else } #3}
\newcommand{\lgifc}{\lgif{t_1}{t_2}{t_3}}

\newcommand{\lgrec}[5]{\text{rec } #1~\lgvar{#3}{#4} : #2 = #5}
\newcommand{\lgrecc}{\lgrec{g}{\tau_1}{x}{\tau_2}{t_1}}

\newcommand{\lgand}[2]{#1 \wedge #2}
\newcommand{\lgandc}{\lgand{t_1}{t_2}}

\newcommand{\lgor}[2]{#1 \bvee #2}
\newcommand{\lgorc}{\lgor{t_1}{t_2}}

\newcommand{\lgneg}[1]{\neg #1}

\newcommand{\lgexist}[3]{\exists \glvar{#1}{#2}. #3}
\newcommand{\lgexistc}{\lgexist{x}{\tau_2}{f_1}}

\newcommand{\lgforall}[3]{\forall \glvar{#1}{#2}. #3}
\newcommand{\lgforallc}{\lgforall{x}{\tau_2}{f_1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{TITLE}
\author{Léon}
%\date{\today}
\counterwithin{figure}{subsection}
\sloppy 
\addtolength{\hoffset}{-0.5in}
\addtolength{\textwidth}{0.8in}
\begin{document}

\maketitle

\tableofcontents

\begin{abstract}
  This is the abstract...
\end{abstract}

\section{Introduction}

context: deductive program verification~\cite{filliatre11sttt}

main idea = if a program is using a HO function to write a loop, its
proof of correctness should not be more difficult than its imperative
counterpart using a for/while loop

motivating examples

related work 

\section{Programming Language}

mini-ML + global references + recursive functions

\subsection{Syntax}

\subsection{Semantics}

\subsection{Type System with Effects}

side effects + termination, independently
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Inlining}

Inlining of higher-order programs is a syntactic transformation that turns
each higher-order expression into an expression of first-order degree. Local
variables are replaced by functional expression they introduce; formal
parameters of functional type are substituted by actual arguments inside
applications, and more generally every higher-order expression inside a
program is progressively simplified until no higher-order expression is
left. The rest of the source program, that is, any expression of first-order
type, remains syntactically unchanged.

Obviously, for programs whose return type is some base type, the inlining
transformation must be \textit{total}. That is, for any program that only
\textit{makes use} of high-order expressions, but should return some
first-order data like \texttt{int} or \textit{list bool}, the inlining must
\textit{always} result in a purely first-order program. (Indeed, programs
being \textit{closed}, \textit{well-typed} terms, the only higher-order
expressions that might appear inside, are either local definitions or
applications of a functional to functions, and these are precisely what
inlining aims to simplify). \\

So can we take the entire set of ML programs as the domain of inlining
function ?  Would it always be possible to transform a higher-order program
into a first-order program that contains no higher-order content ?

The most important thing to understand about inlining is that, by its
nature, inlining is a \textit{syntactic} transformation; there is a little
chance of any correlation between inlining of a source program and its
formal semantics. Therefore, our main concern will be the
\textbf{correctness} of inlining: it should be \textit{deterministic} and
always \textit{terminating} transformation, whose output has exactly the
same \textit{meaning} that the corresponding source program. Unfortunately,
the entire set of ML contains programs for which inlining would be
incorrect. Let us illustrate this statement with the following two
examples. \\

The interesting feature of ML is its possibility to write programs with side
effects: we can assign a reference
 or write a recursive function that loops (which is rather a bug, than a
 feature). Suppose now that we want to inline
	$$ t \triangleq 
	\tmlet 
            {\textcolor{blue}
            {F_{(int \rightarrow int) \rightarrow int}}}
	{(r_{int}:= 42; \lambda f_{int \rightarrow int}. t_0)}{t_1} $$
Intuitively, inlining operation should not modify the bounded expression
$(r_{int}:= 42; \lambda f_{int \rightarrow int}. t_0)$ in order to prevent an
assignment of variable $r$, so the result of inlining should be directly a
substitution
	$$ I(t) \approx 
	\tmsbst{t_1}
		{\textcolor{blue}{F}}
		{(r_{int}:= 42; \lambda f_{int \rightarrow int}. t_0)} $$ 
Unfortunately, the semantics of $t_1$ is not preserved by inlining: if
$\textcolor{blue}{F}$ has multiple occurrences in $t_1$, the variable
assignment $r:=42$ will be multiplied, and if $f$ does not occur in $t_1$,
then it will be lost. Even if $\textcolor{blue}{F}$ occurs just once in
$t_1$, we cannot be sure, that the initial order of assignments is
preserved. And if we replace $r:=42$ in the example above by some recursive
call that loops, from an always looping program $t$ we get an eventually
terminating $I(t)$, so again the semantics is not preserved.

Recursive functions with  higer-order parameters is another (de)motivating
example: suppose we want to inline two different programs $t$ and $t'$ :
	\begin{footnotesize}
	$$ t \triangleq 
		\texttt{ let } \textcolor{blue}{F} =
  		\tmrec{f}{\textcolor{blue}{g_{int \rightarrow int}}~x_{int}}{int} 
  		{\texttt{ if } x = 0 
  		\texttt{ then } (\textcolor{blue}{g}~x) 
  		\texttt{ else }((f~\textcolor{Sepia}{\boldsymbol{g}})~(x - 1))} 
  		\texttt{ in }
  		(\textcolor{blue}{F}~\textcolor{red}{\lambda y_{int}. t_0})$$ 
  $$ t' \triangleq 
  \texttt{ let } \textcolor{blue}{F} =
  \tmrec{f}{\textcolor{blue}{g_{int \rightarrow int}}~x_{int}}{int} 
  {\texttt{ if } x = 0 
  \texttt{ then } (\textcolor{blue}{g}~x) 
  \texttt{ else } ((f~\textcolor{Sepia}{\boldsymbol{\lambda y. 0}})~(x-1))} 
  \texttt{ in }(\textcolor{blue}{F}~\textcolor{red}{\lambda y_{int}.t_0})$$
\end{footnotesize}
As we suggested above, the inlining of both programs consists in replacing,
inside application $(\textcolor{blue}{F}~\textcolor{red}{\lambda y_{int}. t_0})$, 
local variable $\textcolor{blue}{F}$ by its definition and
then substituting inside the body of recursive function $f$ the formal parameter
$\textcolor{blue}{g}$ by actual argument 
$\textcolor{red}{\lambda y_{int}. t_0}$. 
However substituting $\textcolor{blue}{g}$ inside recursive call 
$((f~\textcolor{Sepia}{\boldsymbol{g}})~(x - 1))$ does not make any sense,
because the output would still contain a higher order expression that cannot be
simplified, that is, inlining would fail. The only solution would be then to
simply erase inside every recursive call any formal parameter of functional
type:
	\begin{footnotesize}
	$$ I(t) \approx
  \tmrec{f}{\textcolor{blue}{\text{\textvisiblespace}}~x_{int}}{int}
  	{\texttt{ if } x = 0\texttt{ then }(\textcolor{red}{\lambda y_{int}.t_0}~x)
    \texttt{ else } (f~\textcolor{blue}{\text{\textvisiblespace}}~(x-1))} $$
	$$ I(t') \approx
  \tmrec{f}{\textcolor{blue}{\text{\textvisiblespace}}~x_{int}}{int} 
  	{\texttt{ if }x = 0\texttt{ then }(\textcolor{red}{\lambda y_{int}.t_0}~x)
    \texttt{ else }(f~\textcolor{blue}{\text{\textvisiblespace}}~(x-1))} $$
	\end{footnotesize}
By chance, the formal parameter $g$ remains unchanged inside recursive call
$((f~g)~x)$, So $t$ and $I(t)$ do have the same semantics. Unfortunately, in the
recursive call of program $t'$, instead of $g$ we have a constant function
$\lambda y. 0$, and the safety of inlining is broken: for instance, if for some
non-null integer x the call $(\lambda y. t_0~x)$ loops, then while $(t'~x)$ will
return zero, $(I(t')~x)$ will loop too.

Of course, the incompleteness of inlining for such expressive language as ML is
not a surprise; some restrictions should be imposed on the source language.  
However, the aim of this work is not to describe a most general
class of higher-order expressions that can be inlined, but a more
practical investigation about the potential of higer-order inlining in deductive
verification discipline. As we will show later in evaluation section, the
immense majority of higher-order definitions of real projects does not require
all the power of ML.
\paragraph*{Outline}
 We begin a more formal description of inlining by imposing some
restrictions on the typing system of ML. Without reducing drastically ML
expressiveness, the source language will still cover a great number of real-life
programming examples.

Once we formally specified the domain and codomain of inlining transformation,
we will give a precise definition \textit{small-step} of procedure itself,
described as rewriting strategy by a set of inference rules in a
\textit{small-step} manner.

We will then state and prove that this definition corresponds to the procedure
that is deterministic, always terminate and results in a entirely first-order
program.

Finally, after all syntactical problems pointed out and solved, we will
concentrate our attention on the \textit{total correctness} of inlining
transformation: using a well-know \textit{logical relations} technique, we will
formalize the notion semantic equivalence between programs and show that for
every couple of source and target programs, these programs are semantically
equivalent.
 
The correctness of inlining we establish is \textit{total}: source language is
not confined to terminating programs and an input program's non-termination is
preserved by inlining. As \textit{Kahn natural semantics} is limited to
establishing the \textit{partial} correctness, that explains our choice of an
overall small-step style of programs operational semantics and inlining.


\subsection{The Source Language $\inlsrc$}

As we have seen in the previous example TODO, recursive definitions shall
operate only on arguments of some base type like \texttt{int}, \texttt{bool},
etc. That does not mean we cannot parametrize the body of recursive function by
a variable of some higher-order type:
\begin{footnotesize}
$$ \lambda f_{int \rightarrow int}. \texttt{ rec } \text{apply } x_{int} .
  \texttt{ if } x = 0 \texttt{ then } 42 \texttt{ else} \text{ apply } (f~x)$$
\end{footnotesize}
To make this idea a little more general, if we order the formal
parameters according to their type's degree in \textit{any} functional
definition, that would make inlining more easy to define 
and more easy to proof sound. 
Formally, we force ML types to obey the following hierarchy :

\begin{definition}[($ML^{^{n}}$)]
\begin{displaymath}
	\begin{array}{lll@{\hspace*{2cm}}l}
	\tau^0 & ::= & int~|~bool~|~unit~|~list~int~|~\dots~ & \textsc{base
          type} \\ \tau^1 & ::= & \tau^0 \stackrel{\theta, \rho}{\rightarrow}
        \tau^0 ~|~ \tau^0 \stackrel{\theta, \rho}{\rightarrow} \tau^1 &
        \textsc{first-order functions}\\ \tau^2 & ::= & \tau^1 \stackrel{\theta,
          \rho}{\rightarrow} \tau^0 ~|~ \tau^1 \stackrel{\theta,
          \rho}{\rightarrow} \tau^1 ~|~ \tau^1 \stackrel{\theta,
          \rho}{\rightarrow} \tau^2
%	\tau^1 \stackrel{\bot_{\theta}, \bot_{\rho}}{\rightarrow} \tau^2 
	& \textsc{second-order functions} \\ \dots & & \dots & \dots
        \\ \tau^{n+1} & ::= & \tau^{n} \stackrel{\theta, \rho}{\rightarrow}
        \tau^0 ~|~ \tau^{n} \stackrel{\theta, \rho}{\rightarrow} \tau^1 ~|~
        \dots ~|~ \tau^{n} \stackrel{\theta, \rho}{\rightarrow} \tau^{n} ~|~
        \tau^{n} \stackrel{\theta, \rho}{\rightarrow}\tau^{n+1}
%	\tau^1 \stackrel{\bot_{\theta}, \bot_{\rho}}{\rightarrow} \tau^2 
	& \textsc{higher-order functions} \\
	
	\end{array}
\end{displaymath}
\label{MLn-ty-d}

This hierarchy is defined inductively (by strong induction on type's degree
$i$): if $i=0$, then the base case consist of all base types such as $int$,
$bool$, etc; otherwise, for $i > 0$, the set of possible types of degree $i+1$
is an enumeration $\{\tau^{i} \rightarrow \tau^{k} ~|~ k \in [ 0 \dots (i+1) ]
\}$ of all possible codomain inferior degrees including $(i+1)$.
We shall name such hierarchy by $ML^{^{n}}$ and the initial $ML$ typeset by
$ML^\star$.
\end{definition}

Note that the set of $ML^{^{n}}$ types is totally ordered: indeed, for every
couple of types $\tau^i \rightarrow \tau^k$ $\tau^j \rightarrow \tau^l$ we can
compare them lexicographically starting by comparing their domain degrees $i$
and $j$, and if those are equal, then by comparing their codomain degrees $k$
and $l$.

\paragraph*{The syntax and Semantics of $ML^{^{2}}$}

So far, we defined $ML^{^{n}}$ types for an arbitrary degree $n$. In
practice, however, TODO the immense majority of high-order expressions
limits on second-order programs like $folders$, $iterators$, $mappings$,
etc.  For that reason, and for the sake of simplicity, we continue our
presentation limiting it to $ML^{^{2}}$, an ML programs bounded to
second-order degree.

It is important to point out that $ML^{^{n}}$ is isomorphic $ML^{star}$,
therefore restraining the source language typing to $ML^{^{n}}$ does not
reduce the $ML^{star}$ expressiveness (though, the typing rules below will
do).

To simplify our presentation little further (especially for the semantic
equivalence and the inlining correctness proof), we confine mutable
variables type $r_{\tau^i}$ to degree zero.  That is, the global store
contains first-order values only.  Note, however, that all definitions,
theorems and proofs for below can be easily extended for $ML^{^{n}}$ of
arbitrary degree $n$ without store typing confinement.

Overall, the syntax of source language $\inlT$ remains  identical to $ML$, 
except the explicit typing annotation of variables :
%\begin{displaymath}
%	\begin{array}{lll@{\hspace*{3cm}}l}
%	t &::=& x_{\tau^{i}} ~|~ v~|~(t~v) ~|~\text{let } x_{\tau^{i}} = t
%        \text{ in } t ~|~ r_{\tau^i} := v ~|~ !r_{\tau^i} & \textsc{terms}\\ v
%        &::=& \lambda x_{\tau^{i}}. t ~|~ \text{rec } f x_{\tau^{i}}:~\tau^{i}.t
%        ~|~ c & \textsc{values} \\ c &::=& \text{()} ~|~
%        \mathbb{N}~|~\mathbb{B}~|~+~|~-~|~\bwedge~|~\dots & \text{constants}
%	\end{array}
%\end{displaymath}
Likewise, the semantics $\inlsrc$ is given by exactly the same small-step 
inferences rules we presented in TODO for ML.

\paragraph*{The Typing Rules for $ML^{^{2}}$}

Ordering parameter types and putting language into $A-normal form$ only
changes the source language syntax, without altering ML's expressiveness. To
restraint $\inlsrc$ programs to the set of initial programs for which the
inlining procedure will be \textit{total} and \textit{sound} is precisely
the goal of typing rules.
 
Obviously, the typing of variables,constants and mutable variable
manipulation remains the same as for $ML$ (except explicit typing
annotations):
\begin{footnotesize}
	\begin{multicols}{2}	
		\infrule[T$_{ML^{^2}}$-Var]
			{}
			{\vdash x_{\tau^{i}} : \tau^{i}, 
			\bot_{\theta},
  		\bot_{\rho} } 
  	\infrule[T$_{ML^{^2}}$-Const]
  	{\text{Typeof}(c) = \tau^i}
  	{\vdash c_{\tau^{i}} : \tau^{i}, \bot_{\theta}, \bot_{\rho}}
	\end{multicols}

	\begin{multicols}{2}	
		\infrule[T$_{ML^{^2}}$-Assign] 
		{\vdash v:\tau^{0}, \bot_{\theta}, \bot_{\rho}}
    {\vdash r_{\tau^{0}} := v : unit, \top_{\theta}, \bot_{\rho}}
	
		\infrule[T$_{ML^{^2}}$-Deref] 
			{} 
			{\vdash !r_{\tau^{0}} : \tau^{0}, \bot_{\theta},\bot_{\rho}}
	\end{multicols}
\end{footnotesize}

Maybe less obviously, the typing of function definitions and applications
does not change either.  Indeed, the inlining of such expression as
$$ (\lambda f_{int \rightarrow int}.t~ (r_{int}:=42; \lambda x_{int}. x))$$
would be incorrect. Fortunately, we have put $\inlsrc$ into $A-normal form$,
so the term above is rejected by syntax, so keeping the same typing for
abstractions and applications becomes possible: 

	\begin{footnotesize}
		\begin{multicols}{2}	
	\infrule[T$_{ML^{^2}}$-Fun] 
		{\vdash t : \tau^{j}, \theta, \rho} 
		{\vdash \lambda x_{t^i}. t : 
			\tau^{i} \stackrel{\theta, \rho}{\rightarrow} \tau^{j}, 
			\bot_{\theta},
 			\bot_{\rho}}

	\infrule[T$_{ML^{^2}}$-App] 
		{\vdash t: \tau^{i} \stackrel{\theta, \rho}{\rightarrow}
  	\tau^{j}, \theta', \rho' 
  	\qquad \vdash v:\tau^{i}, \bot_{\theta}, \bot_{\rho}}
    {\vdash (t~v) : \tau^{j}, (\theta \bvee \theta'), (\rho \bvee \rho')}
		\end{multicols}
	\end{footnotesize}

The interesting part is the typing of recursive functions and local
variables.  As example above TODO shows, recursive functions should operate
on first-order arguments only. Taking a currification into account, the
typing of recursive functions is restraint to
	\begin{footnotesize}
		\infrule[T$_{ML^{^2}}$-Rec] 
		{\vdash t : \tau^{1}, \theta, \rho} 
		{\vdash \text{rec }  f~x_{\tau^0}~. t : 
			\tau^{0} \stackrel{\theta, \top_{\rho}}{\rightarrow}\tau^{1}, 
			\bot_{\theta}, 
			\bot_{\rho}}
	\end{footnotesize}
Finally, as we illustrated in another example TODO, in expressions such as 
"$\texttt{let } F_{\boldsymbol{i^{2}}} = t_2 \texttt{ in } t_1 $",
the second-order term $t_2$ should free from any possible side-effects.
So the general typing of \texttt{let} expression is given by
	\begin{footnotesize}
		\infrule[T$_{ML^{^2}}$-Let] 
			{\vdash t_1 : \tau^i, \theta, \rho 
			\qquad \vdash t' : \tau^j, \theta', \rho' 
			\qquad (i = 2) \Rightarrow 
			\boldsymbol{(\theta = \bot_{\theta}\bwedge \rho = \bot_{\rho})}} 
			{\vdash \text{ let } x_{\tau^i} = t \text{ in } t' 
				: \tau^{j}, 
				(\theta \bvee \theta'), 
				(\rho \bvee \rho')}
	\end{footnotesize}

\paragraph*{Notations}

TODO

\begin{displaymath}
	\begin{array}{lll@{\hspace*{3cm}}l}
			L &::=& F ~|~ l \qquad \text{with}\qquad l~::=~ x ~|~ f &
        \textsc{binders} \\ 
      t &::=& l ~|~ v~|~(t~v) ~|~\text{let } L = t 
        \text{ in } t ~|~ r := v ~|~ !r & 
        \textsc{terms}\\ 
      v &::=& \lambda l. t ~|~
        \text{rec } f x :~\tau . t ~|~ c ~|~ & 
        \textsc{values} \\ 
      c &::=&
        \text{()} ~|~ \mathbb{N}~|~\mathbb{B}~|~+~|~-~|~\bwedge~| ~\dots &
        \textsc{constants} \\
	\end{array}
\end{displaymath}


\subsection{Inlining As Rewriting Strategy}

Short description of two steps 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Inlining Second-Order Variables}

Our first goal is to transform the input language $\inlT$ in such way that it
would contain no more second order binders. As we are interested in programs, 
i.e. well-typed closed terms, the only possible way for a variable $F$ to 
appear in a term $t$ of $\inlT$ is to be introduced by some local binding 
expression $\tmlet{F}{t_1}{t_2}$ (programs like $\lambda F. t$ will be
rejected by typing system). Of course, that does not mean that we have to define 
the inlining procedure for programs only. The definition we are going to give
should simply eliminate all local second-order bindings, ignoring the eventual
free second-order variables.

That is, with respect to our notations, the syntax of the resulting language
 $\inlS$ should respect the following grammar :\\[1em]\indent 
  $ s ::= l~|~w~|~(s~w) ~|~ \tmlet{l}{s_1}{s_2} ~|~ r:= c ~|~ !r \hfill \textsc{(Terms)}$ \\\indent 
  $ w ::= \lambda l. s ~|~ \tmrec{f}{x}{\tau}{s}\hfill \textsc{(Values)}$ \\\indent 
  $ l ::= x ~|~ f \hfill \textsc{(Binders)}$ \\\indent 
  $ c ::= x ~|~ \overline{n}~|~... \hfill \textsc{(Constants)}$\\[1em]

It is straightforward to see that $\inlS \subsetneq \inlT$. In particular,
terms of $S$ are in \textit{A-Normal Forms}, respects all typing restrictions 
we imposed on terms of $\inlT$ and has exactly the same \textit{CBV} semantics. 

Our goal is then to define the inlining procedure and show that it always
terminates, resulting in some term $s \in \inlS$.
%Most importantly, we will
%show that inlining procedure preserves the meaining of the source p 
To acheive this goal, let us start by describing all possible forms that
inlining procedure can take in \textit{one step}.

\begin{definition}[(One Step local bindings Inlining, $\hookdownarrow$)]
   Let $t$ be a term of the source language $\inlT$ such that $t \not\in
   \inlS$ and $t \neq F $. Thus $t$ contains at least one local binding of
   some second-order variable $F$ introduced by $\tmlet{F}{t_0}{t_1}$
   construction.

Then the inlining of local bindings of $t$, is defined as a rewriting
strategy $\inllet{t}{t'}$ by the set of inference rules of
\cref{fig:inl-let-d}.

\label{inlletrule-macro}
\newcommandx{\inlletrule}[5]
{\infrule[$I_1$-#1]
	{\inllet{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\inllet{#4}{#5}}}
	
\label{inllettrulet-macro}	
	\newcommandx{\inllettrule}[5]
{\infrule[$I_1$-#1]
	{\inllett{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\inllett{#4}{#5}}}


 	\begin{figure}[H]
  \begin{footnotesize}
	\begin{spacing}{1.01}
	\hrulefill
	\begin{adjustwidth}{6em}{-14em}
		\begin{multicols}{2}
		\infrule[$I_1$-Let$_0$]{}
			{\boldsymbol{\tmlet{F}{s_1}{s_2} \hookdownarrow 				
			\tmsbst{s_2}{F}{s_1}}}
		\end{multicols}
		\vspace*{-2em}
	\end{adjustwidth}
	\begin{adjustwidth}{-8em}{-4em}
		\begin{multicols}{2}	
		\inlletrule{Fun}
			{t_1}{t'_1}
 			{\lambda l. \boldsymbol{t_1}}{\lambda l.\boldsymbol{t'_1}}
		\inlletrule{App$_1$}
			{t_1}{t'_1}
			{(\boldsymbol{t_1}v)}{(\boldsymbol{t'_1}v)}
		\inlletrule{Let$_1$}
			{t_1}{t'_1}
			{\tmlet{\varslash{l}{F}}{\boldsymbol{t_1}}{t_2}}
			{\tmlet{\varslash{l}{F}}{\boldsymbol{t'_1}}{t_2}}
		\inlletrule{Rec}{t_1}{t'_1}
 			{\tmrec{f}{x}{\tau}{\boldsymbol{t_1}}}
 			{\tmrec{f}{x}{\tau}{\boldsymbol{t'_1}}}
		\inlletrule{App$_2$}
			{v}{v'}
			{(s\boldsymbol{v})}{(s\boldsymbol{v'})}	
		\inlletrule{Let$_2$}
			{t_2}{t'_2}
			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t_2}}}
			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t'_2}}}
		\end{multicols}
	\end{adjustwidth}	
	\hrulefill
	\end{spacing}
	\caption{ \textbf{Inlining of Second-Order Local Bindings}\hfill}
 	\label{fig:inl-let-d}
 	\end{footnotesize}
	\end{figure}
\end{definition}

As we can see, the $\ilarr$ relation consist in the head reduction rule
\textsc{I$_1$-Let$_0$} and the set of contextual reductions are defined
recursively, from left to right, on the immediate sub-term where a
second-local binding take place. Then, the first phase of inlining is
defined as follows:

\begin{definition}([Multi-Step Inlining, $\inlletplus$]) The multi-step
  inlining $\inlletplus$ is the transitive closure of one-step
  inlining. That is, it is the smallest relation defined by the following
  inference rules:


$$\dfrac{\inllet{t}{t'}}{\inllett{t}{t'}}{~~(\textsc{$I_1$-step})}
\quad\dfrac{\inllett{t}{t'} 
\qquad \inllett{t'}{t''}}{\inllett{t}{t''}}{~~(\textsc{$I_1$-trans})}$$
\end{definition}

To achieve the goal we have fixed above, it is useful to state the following
auxiliary lemmas and definitions :

\begin{lemma}[(Determinacy of $\inlletplus$)] 
	$\forall n \in \mathbb{N}.~ \forall t, t_1, t_2.
		(t \inlletarr^{n} {t_1} \bwedge t \inlletarr^{n} {t_2}) \brarr
			t_1 = t_2$.	\label{inllet-determ-l}	
\end{lemma}
\begin{proof} See \ref{inllet-determ-p}. \end{proof}

\begin{lemma}[($\inlletplus$ Preservation Properties)]
For any well-typed term $t$ such that\\ $\typerule{t}{\tau}{\theta}{\rho}$, if $\inllett{t}{t'}$ then
\begin{displaymath}
\begin{array}{l@{\hspace*{1cm}}l@{\hspace*{1cm}}l}
	(1)& FV(t') \subseteq FV(t) & \textsc{(free variables inclusion)} \\
	(2)& \typerule{t'}{\tau}{\theta}{\rho} &\textsc{(typing preservation)} \\
	(3)& t' \in \inlT & \textsc{(A-normal form preservation)}
\end{array}
\end{displaymath}
 \label{inllet-prop-l}
\end{lemma}
\begin{proof}
 By induction on the derivation of $\inllet{t}{t'}$. For detailed proof see
 \ref{inllet-prop-p}.
 \end{proof}



\begin{definition}[(Normal Forms For $\inlletplus$)]
	The set of normal forms for $\inlletplus$,  $\inlletNF$, is defined as follows: \quad
 $ \inlletNF \triangleq \{ t | t \in \inlT \bwedge 
 \forall t' \in \inlT. t~\cancel{\inlletplus}~t' \} $
\end{definition}

\begin{lemma}[(Normal Forms For $\inlletarr^\star$)] 
$ \inlletNF \backslash \{ F \} = \inlS.$
\label{inllet-nforms-l}
\end{lemma}
\begin{proof}
For detailed proof see \ref{inllet-nforms-p}.
\end{proof}

\begin{theorem}[(Termination of $\inlletplus$)] 
		The multi-step inlining always terminates: \\
		$\forall t_0~
	 			!\exists t_n : 
	 				  (\inllett{t_0}{t_n}) \brarr (t_n \in \inlletNF).$
\label{inllet-term-l}
\end{theorem}
\begin{proof} For detailed proof see \ref{inllet-term-p}. \end{proof}
 
\begin{corr}[(Second-Order Local Bindings Inlining)] blah\\
 $\forall t.~ 
	 			!\exists s : 
	 				(t \in \inlT \bwedge t \not\in \inlS) \brarr 
	 				  (\inllett{t}{s} \bwedge s \in \inlS).$
\end{corr}


\newpage
\subsubsection*{Inlining Second-Order Applications}

- output language subset

\label{icrule-macro}
\newcommandx{\icrule}[5]
{\infrule[$I_2$-#1]
	{\ic{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\ic{#4}{#5}}}

\newcommandx{\icrulehead}[3]
{\infrule[$I_2$-#1]
	{}
	{\ic{#2}{#3}}}
	

\label{ictrule-macro}	
	\newcommandx{\ictrule}[5]
{\infrule[$I_1$-#1]
	{\ict{\boldsymbol{#2}}{\boldsymbol{#3}}}
	{\ict{#4}{#5}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[(One Step Inlining Of Second-Order Calls, $\icarr$)]
bla	
	\begin{figure}[H]
	\begin{spacing}{1.01}
	\hrulefill
	\begin{adjustwidth}{-12em}{-4em}
	\begin{multicols}{2}
	\icrulehead{App$_0$}
		{(\lambda f. u~\omega)}
		{\tmsbst{u}{f}{\omega}}
	\icrulehead{Let$_0$}
		{(\boldsymbol{(}\tmlet{l}{u_1}{u_2}\boldsymbol{)} \boldsymbol{\omega})}
		{\tmlet{l}{u_1}{\boldsymbol{(u_2~\omega)}}}	
	\end{multicols}
	\vspace*{1em}
	\begin{multicols}{2}	
	\icrule{Fun}
		{s}{s'}
		{\lambda l. \boldsymbol{s}}{\lambda l. \boldsymbol{s'}}	
	\icrule{App$_1$}
		{s}{s'}
		{(\boldsymbol{s}w)}{(\boldsymbol{s'}w)}
	\icrule{Let$_1$}
		{s_1}{s'_1}
		{\tmlet{l}{\boldsymbol{s_1}}{s_2}}{\tmlet{l}{\boldsymbol{s'_1}}{s_2}}
	\icrule{Rec}
		{s}{s'}
		{\tmrec{f}{x}{\tau}{\boldsymbol{s}}}{\tmrec{f}{x}{\tau}{\boldsymbol{s'}}}	
	\icrule{App$_2$}
		{w}{w'}
		{(u\boldsymbol{w})}{(u\boldsymbol{w'})}
	\icrule{Let$_2$}
		{s_2}{s'_2}
		{\tmlet{l}{u_1}{\boldsymbol{s_2}}}{\tmlet{l}{u_1}{\boldsymbol{s'_2}}}
	\end{multicols}
	\end{adjustwidth}
	\hrulefill
	\caption{ \textbf{Inlining of Second-Order Applications}\hfill}
 	\label{fig:inl-app-d}
	\end{spacing}
	\end{figure}
\end{definition}

\begin{definition}([Multi-Step Inlining, $\inlletplus$]) 
The multi-step inlining $\inlletplus$ is the transitive closure of one-step
inlining.  That is, it is the smallest relation defined by the following
inference rules:

%\begin{figure}[H]
%	\begin{spacing}{1.01}
%	\hrulefill
%	\begin{adjustwidth}{-8em}{0em}
%
%		\begin{multicols}{3}
%		\infrule[$I_1$-Step]{\inllet{t}{t'}{\inllett{t}{t'} 			
%			\tmsbst{s_2}{F}{s_1}}}
%		\inllettrule{$I_1$-Trans}{t_2}{t'_2}
%			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t_2}}}
%			{\tmlet{\varslash{l}{F}}{t_1}{\boldsymbol{t'_2}}}
%		\end{multicols}
%	\end{adjustwidth}	
%	\hrulefill
%	\end{spacing}
%	\caption{ \textbf{Multi-Step Inlining of Second-Order Local Bindings}\hfill}
% 	\label{fig:inl-let-d}
%	\end{figure}

$$\dfrac{\inllet{t}{t'}}{\inllett{t}{t'}}{~~(\textsc{$I_1$-step})}
\quad\dfrac{\inllett{t}{t'} 
\qquad \inllett{t'}{t''}}{\inllett{t}{t''}}{~~(\textsc{$I_1$-trans})}$$
\end{definition}

- sos definition
- theorem 2	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Semantic Equivalence Relation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Semantic Equivalence Between Closed Terms}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{semantic equivalence}
\begin{definition}[(Semantic Equivalence)]
	Let $t$ and $t'$ be two well-typed closed terms of the source 
	language such that 
	
	$$
		\typerule{t}{\tau}{\theta}{\rho}{} \quad \typerule{t'}{\tau}{\theta}{\rho}{} 
	$$

	We define $\eqv{t}$, the \textit{semantic equivalence} between $t$ and $t'$, 
	by induction on the structure of type $\ty$ :
	
	\begin{itemize}
		\item[$(\alpha)$]

			if $\ty{} = \ty{}^0$ for some base type $\ty{}^0$, then $\eqv{t}$ iff
			$$	\forall \mu_0.(\evalinfty{t}{\mu_0} \bwedge \evalinfty{t'}{\mu_0})~
					\bvee ~ \exists \mu_1 \exists v: 
					\evalstar{t}{0}{v}{1} \bwedge \evalstar{t'}{0}{v}{1} $$
		
		\item[$(\beta)$]
			if $\ty = \tyarr$ for some types $\ty[1], \ty[2]$,
			then\\[0.2cm]
			$\hspace*{0em}\forall v_0, v'_0. ~ \eqv{v_0} ~ 
			\bwedge \typerule{v_0}{\ty[1]}{\bot_\theta}{\bot_\rho}{} ~~
			\bwedge \typerule{v'_0}{\ty[1]}{\bot_\theta}{\bot_\rho}{} $ \\[0.2cm]
			$\hspace*{1em}
			\Rightarrow \forall\mu_0.(\evalinfty{\tmapp{t}{v_0}}{\mu_0}
			\bwedge\evalinfty{\tmapp{t'}{v'_0}}{\mu_0})$\\[0.2cm]
			$\hspace*{2em}\bvee~(\exists \mu_1 \exists v_1, v'_1 : 
			 	\evalstar{\tmapp{t}{v_0}}{0}{{v_1}}{1} 
				\bwedge \evalstar{\tmapp{t'}{v'_0}}{0}{{v'_1}}{1}
				\bwedge~\eqv{v_1})$				
	\end{itemize}
	\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{lemma} 
		The semantic equivalence 	terms, $\thicksim$, is reflexive, 	
		symmetric and transitive relation.
	\end{lemma}
	
	\begin{proof}
		By straightforward induction on the structure of type of the terms, using 
		the fact that $\rightarrow^\star$ is an evaluation strategy, thus 
		deterministic.
	\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{lemma}
		$\forall t,t'.~ \eqv{t} \Leftrightarrow 
			(\forall v, v'.~\eqv{v}~\Rightarrow
			\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$
	\label{equiv-def-l}
	\end{lemma}
	
	\begin{proof} By induction on the structure of type $\ty[t]$.
	For Detailed proof, see \ref{equiv-def-p}.
	\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\begin{lemma}
		For any pair of states $\mu_0$, $\mu_1$ such that
		$\evalstar{{t_0}}{0}{{t_1}}{1}$ and $\evalstar{{t'_0}}{0}{{t'_1}}{1}$
		if $\eqv{t_0}$ then $\eqv{t_1}$.
		\label{equiv-red2-l}
	\end{lemma}
	
	\begin{proof}
		By induction on the structure of type of $t_0$. 
		For Detailed proof, see \ref{equiv-red2-p}.
	\end{proof}		

	\begin{corr} 
		For any pair of states $\mu_0$, $\mu_1$ such that
		$\evalstar{{t}}{0}{{v}}{1}$ and \mbox{$\evalstar{{t'}}{0}{{v'}}{1}$},
		if $\eqv{t}$ then $\eqv{v_1}$.
		\label{equivalence parallel preservation corr}
	\end{corr}
	
	
	
	\begin{lemma}
		For any state $\mu_0$, if $\evalstep{{t_0}}{0}{{t_1}}{0}$, then
		$t_0 \thicksim t_1$.
	\end{lemma}	
	\begin{proof}
		By Straightforward observation that $\rightarrow$ is an evaluation
		strategy, thus deterministic.
	\end{proof}		

	\begin{corr} 
		For any state $\mu_0$, if $\evalstar{{t}}{0}{{v}}{0}$, then		
		$t \thicksim v$.
	\end{corr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Semantics Equivalence Between Parallel Substitutions}

  



	\begin{definition}[(parallel substitutions)]
	Let $t$ be any well-typed term, $t_1, \dots t_n$ well-typed 
	\textit{\textbf{closed}} terms, and $x_1, \dots, x_n$ distinct variables.
	To fix the notation, 
	let $\sigma = [x_1 \mapsfrom t_1, \dots, x_n \mapsfrom t_n] $ be
	a finite map such that :  	
	$$\forall x\in\mathfrak{Dom}(\sigma).~x\notin BV(t)\bwedge\tau_x=
	\tau_{\sigma(x)}$$

	Then the parallel substitution $(t\sigma)$ is defined by induction on $t$ 
	as follows :
	\begin{displaymath}
	\begin{array}{lll}
	 (x_i\sigma)& \triangleq & \sigma(x_i)\\
	 (y\sigma)& \triangleq & y \\
	 ((t_1t_2)\sigma) & \triangleq & ((t_1\sigma)(t_2\sigma))\\
	 (\lambda y_{\tau}. t)\sigma & \triangleq & \lambda y_\tau. (t\sigma)\\
	 (rec~f~y_{\tau_1} : \tau_2 = t)\sigma & \triangleq 
	   & rec~f~y_{\tau_1} : \tau_2 = (t\sigma) \\
	 ((let~y_\tau = t_1~ in~ t_2)\sigma) & \triangleq 
	   & let~y_\tau = (t_1\sigma)~in~ (t_2\sigma)\\
	  (r_\tau := v)\sigma)	& \triangleq & r_\tau := (v\sigma) \\
	 (!r_\tau\sigma) & \triangleq & !r_\tau \\
	     	 
	\end{array}
	\end{displaymath}
	\label{}
	\end{definition}

	\begin{definition}[(equivalent parallel substitutions)]
	Let $t$ be a well-typed term. Then we define the semantic equivalence
	between two parallel substitutions $\sigma$ and $\sigma'$, 
	$\sigma \thicksim_t \sigma'$ as follows:
	\begin{itemize}
	\item[(1)] 
	  $(t\sigma)$ and $(t\sigma')$ are well-defined parallel substitutions
	\item[(2)]
	  $ \mathfrak{Dom}_\sigma = \mathfrak{Dom}_\sigma' = FV(t)$
	\item[(3)]
		$ \forall x \in \mathfrak{Dom}_\sigma.~ \sigma(x) \thicksim_t \sigma'(x)$
	\end{itemize}	 
	\label{equiv-subst-d}
	\end{definition}

	Note that from (1) it follows, that both $(t\sigma)$ and 
	$(t\sigma')$ are terms that well-typed, and from (2) and (3) it follows 
	that both $(t\sigma)$ and	 $(t\sigma')$ are \textit{\textbf{closed}} terms.
	
	The next lemma captures the intuition that plugging free variables
        inside a term by semantically equivalent, even thought syntactically
        different programs gives two programs for which the semantic
        equivalence is preserved:
	
	\begin{lemma} 
		$\forall t. \forall (\sigma, \sigma'). ~\eqvsbst{\sigma}{t}
		\Rightarrow \tmapp{t}{\sigma} \thicksim \tmapp{t}{\sigma'}.$ 
	\label{equiv-subst-l}
	\end{lemma}

	\begin{proof}
		By induction on the structure of term $t$. For detailed proof, see
		\ref{equiv-subst-p}.
	\end{proof}


\subsubsection*{Output Language}
TODO: Nice figure 

%\subsection{Inlining Higher-Order Programs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Specification Language}

\subsection{Ghost Code}

\begin{definition}[blah blah] blah
\end{definition}

\begin{theorem}[blah] 
blah
\end{theorem}

\begin{lemma}[blah blah blah]
blah
\end{lemma}

type system, erasure, proof of correctness of erasure

\subsection{Annotations}

requires, ensures, assert

\section{Putting Pieces Together}

\subsection{Orthogonality}

inlining adapted to specification language

\subsection{Experimental Evaluation}

\section{Conclusion and Perspectives}

blah blah

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section*{Appendices}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{Detailed proofs} 


	\subsection{Inlining Second-Order Local Bindings}
	

\begin{lemma}[(determinacy of $\inlletplus$)] 
	$\forall n \in \mathbb{N}.~ \forall t, t_1, t_2.
		(t \inlletarr^{n} {t_1} \bwedge t \inlletarr^{n} {t_2}) \brarr
			t_1 = t_2$.	
	\label{inllet-determ-p}	
\end{lemma}

\begin{proof}
Start by proving the base case (\textsc{$I_1$-step}) by case analysis, for each possible form of $t$, on the leftmost immediate sub-term of $t$ containing an occurrence of some second-order variable $F$. 
	  Do the remaining  (\textsc{$I_1$-trans}) case	by strong induction on $n$.  Back to \ref{inllet-determ-l}.
\end{proof}	
	
\begin{lemma}[($\inlletarr$ Preservation Properties)]
For any well-typed term $t$ such that\\ $\typerule{t}{\tau}{\theta}{\rho}$, if $\inllet{t}{t'}$ then
\begin{displaymath}
\begin{array}{l@{\hspace*{1cm}}l@{\hspace*{1cm}}l}
	(1)& FV(t') \subseteq FV(t) & \textsc{(free variables inclusion)} \\
	(2)& \typerule{t'}{\tau}{\theta}{\rho} &\textsc{(typing preservation)} \\
	(3)& t' \in \inlT & \textsc{(A-normal form preservation)}
\end{array}
\end{displaymath}
 \label{inllet-prop-p}
\end{lemma}

\begin{proof}
 By induction on the derivation of $\inllet{t}{t'}$.
 \label{TODO-inllet-prop-p}
 Back to \ref{inllet-prop-l}.
 \end{proof}	
	
%  \begin{lemma}
% 	If $\inllet{t}{t'}$, then $FV(t') \subseteq FV(t)$.
% 	\label{inllet-fv-p}
%  \end{lemma}
%
%\begin{proof}
% By induction on the derivation of $\inllet{t}{t'}$.  \\
% 	\noindent\textit{Case} \textsc{(Let$_0$)}\quad 
% 	$\tmlet{F}{s_1}{s_2} \hookdownarrow \tmsbst{s_2}{F}{s_1}$. 
% 	If $F \in FV(s_2)$, then 
% 	$$FV(t) = FV(s_1) \cup (FV(s_2) \backslash \{F\}) = FV(t') $$ 
% 	Otherwise  
% 	$$ FV(t') =  FV(s_2) \backslash \{F\} \subseteq (FV(s_1) \cup FV(s_2) \backslash \{F\}) =  FV(t)$$.
% Other cases are hold by straightforward induction. Back to \ref{inllet-fv-l}.
%\end{proof}	
%	
%	\begin{lemma}[($\inlletarr$, typing preservation)] For any well-typed term $t$
% such that\\ $\typerule{t}{\tau}{\theta}{\rho}$, if $\inllet{t}{t'}$
% then $\typerule{t'}{\tau}{\theta}{\rho}$.
% \label{inllet-ty-p}
%\end{lemma}
%
%\begin{proof} Observe that for the base case:
%$$\tmlet{F}{s_1}{s_2} \hookdownarrow \tmsbst{s_2}{F}{s_1} \quad \textsc{(Let$_0$)},$$ the restriction typing for term $s_1$, $\typerule{s_1}{\tau_{s_1}}{\bot_\theta}{\bot_\rho}$ guarantees that the only source of side effects or potential non-termination of $t$ is $s_2$, and the result follows immediately by LEMMA \label{TODO:typ-subst-lemma}. Other cases follow by straightforward induction on 
%the derivation of $\inllet{t}{t'}$. Back to \ref{inllet-ty-l}.
%\end{proof}
%	
%\begin{lemma}[($\inlletarr$, \textit{A-form})] 
% If $\inllet{t}{t'}$, then $t' \in \inlT$.
% \label{inllet-aform-p}
%\end{lemma}
%
%\begin{proof} Back to \ref{inllet-aform-l}.
%\end{proof}	
	
	
\begin{lemma}([Normal Forms For $\inlletarr^\star$]) = Output language S
 \label{inllet-nforms-p}.
\end{lemma}
\begin{proof}
Back to \ref{inllet-nforms-l}.
\end{proof}


\begin{theorem}([Termination of $\inlletarr^\star$])
\label{inllet-term-p}.
\end{theorem}
\begin{proof}
  Back to \ref{inllet-term-l}.
\end{proof}	
	
	
	
	\subsection{Inlining Second-Order Applications}



	\subsection{Semantic Equivalence Relation}
	\begin{lemma}
		$\forall t,t'.~ \eqv{t} \Leftrightarrow 
			(\forall v, v'.~\eqv{v}~\Rightarrow
			\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$
	\label{equiv-def-p}
	\end{lemma}

	\begin{proof}
		Let $v, v'$ be two arbitrary values satisfying $\eqv{v}$.
		From the formulation of lemma, it follows that
		$$	\typerule{t}{\tyarr[1][2][\theta_0][\rho_0]}{\theta}{\rho}{} ~~ 
				\typerule{t'}{\tyarr[1][2][\theta_0][\rho_0]}{\theta}{\rho}{}.$$
		where $\ty[2]$ can be either the some first-order type $\tyord{0}[2]$ or
		some arrow type $\tyarr[21][22][\theta_1][\rho_1].$ 
		We prove the lemma by induction on the structure of type $\ty[t]$.
	\begin{itemize}		
	
		\item[$(\Rightarrow)$] Assume $\eqv{t}$. Thus 		
		
		\begin{itemize}
		
		\item[$(\alpha)$] if $\ty[\tmapp{t'}{v'}] = \tyord{0}[2]$, then
		by definition of $\eqv{t}$, for any initial state $\mu_0$ either 
		$\tmapp{t'}{v'}$ and $\tmapp{t'}{v'}$ diverge both, 
		or there is some pair of values $v_1, v'_1$ and a state $\mu_1$ such that 
		$$\evalstar{\tmapp{t}{v}}{0}{{v_1}}{1} 
			\bwedge \evalstar{\tmapp{t'}{v'}}{0}{{v'_1}}{1} \bwedge~\eqv{v_1}.$$
		
		By the preservation of typing, $v_1$ and $v'_1$ are of some base 
		type $\tyord{0}[2]$, and from the fact that they are values, we deduce
		that $v_1 = v'_1$. Therefore,  $\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$.
			
		\item[$(\beta)$] Otherwise, 
		$\ty[\tmapp{t}{v}] = \tyarr[21][22][\theta_1][\rho_1]$.
		Let $v_0, v'_0$ be two arbitrary values satisfying $\eqv{v_0}$ and 
		$\ty[v_0] = \ty[21]$. We must show that for any initial state $\mu_0$,
		either both 
		$\tmapp{\tmapp{t}{v}}{v_0}$ and $\tmapp{\tmapp{t'}{v'}}{v'_0}$ diverge
		or there is a pair of values $v_1, v'_1$ and a state $\mu_1$ such that 
		$$\evalstar{\tmapp{\tmapp{t}{v}}{v_0}}{0}{{v_1}}{1} \bwedge
		\evalstar{\tmapp{\tmapp{t'}{v'}}{v'_0}}{0}{{v'_1}}{1} \bwedge~\eqv{v_1}.$$
		
		Obviously, if both $t$ and $t'$ both diverge,
		then so do $\tmapp{t}{v}$ and $\tmapp{t'}{v'}$, and consequently 
		$\tmapp{\tmapp{t'}{v'}}{v'_0}$ and $\tmapp{\tmapp{t'}{v'}}{v'_0}$.
		Otherwise, from the equivalence $\eqv{t}$ we can deduce that there are
		some values $v_2$, $v'_2$ and some intermediate state $\mu_2$ such that
		$$\evalstar{\tmapp{\tmapp{t}{v}}{v_0}}{0}{\tmapp{v_2}{v_0}}{2} \bwedge
		\evalstar{\tmapp{\tmapp{t'}{v'}}{v'_0}}{0}{\tmapp{v'_2}{v'_0}}{2} 
		\bwedge~\eqv{v_2}$$	
		By induction hypothesis on $\ty[\tmapp{t}{v}]=\ty[v]$, as $\eqv{v_2}$, we 
		get	$$ \tmapp{v_2}{v_0} \thicksim \tmapp{v'_2}{v'_0}.$$ Therefore, 
		$\tmapp{v_2}{v_0}$ diverges if and only if $\tmapp{v_2'}{v_0'}$ diverges 
		too, so again, $\tmapp{\tmapp{t'}{v'}}{v'_0}$ diverges if and only if 
		$\tmapp{\tmapp{t'}{v'}}{v'_0}$ diverges (by determinism of 
		$\rightarrow^\star$). Otherwise for some values $v_1, v'_1$ and a state
		$\mu_1$:
		$$\evalstar{\tmapp{v_2}{v_0}}{2}{{v_1}}{1} \bwedge
		\evalstar{\tmapp{v_2}{v'_0}}{2}{{v'_1}}{1} 
		\bwedge~\eqv{v_1}.$$ There, putting reduction chains together allow us to 
		conclude that $\tmapp{t}{v} \thicksim \tmapp{t'}{v'}.$ 
		\end{itemize}
		
	
		\item[$(\Leftarrow)$] Assume $(\forall v_0, v'.~\eqv{v}~\Rightarrow
		\tmapp{t}{v} \thicksim \tmapp{t'}{v'})$. From the definition of 
		\mbox{$\tmapp{t}{v}\thicksim\tmapp{t'}{v'}$} we almost immediate have 
		that $\eqv{t}$. Back to \ref{equiv-def-l}.
				
		\end{itemize}	
	\end{proof}

	\begin{lemma}
		For any pair of states $\mu_0$, $\mu_1$ such that
		$\evalstar{{t_0}}{0}{{t_1}}{1}$ and $\evalstar{{t'_0}}{0}{{t'_1}}{1}$
		if $\eqv{t_0}$ then $\eqv{t_1}$.
		\label{equiv-red2-p}
	\end{lemma}
	
	\begin{proof}
		By induction on the structure of type of $t_0$. 
		\begin{itemize}
		\item[$(\alpha)$] if $\ty = \ty^0$ for some base type $\ty^0$, then
		
			\begin{itemize}
			\item[$(\alpha_1)$] if $t_0$ diverges, then by definition of 
			$\eqv{t_0}$, $t'_0$ diverges too. Also, $\rightarrow^\star$ being 
			deterministic, both $t_1$ and $t'_1$ diverge. Symmetrically, if 
			$t'_0$ diverges, $t_1$ and $t'_1$ diverge both as well. Therefore,
			$$\eqv{t_1}.$$
						
			\item[$(\alpha_2)$] Otherwise, neither $t_0$ or $t_{0}'$ diverge. Then
				as $\eqv{t_0}$ by hypothesis, it follows that 
					$$ \exists \mu_2 \exists v: 
					\evalstar{{t_0}}{0}{v}{2} \bwedge \evalstar{{t'_0}}{0}{v}{2}.$$
				The evaluation $\rightarrow^\star$ being deterministic, we have 
				necessarily that
					$$\evalstar{{t_1}}{1}{v}{2} \bwedge \evalstar{{t'_1}}{1}{v}{2}.$$
				As the state $\mu_1$ depends uniquely on the arbitrarily chosen 
				$\mu_0$, we deduce again that $$\eqv{t_1}.$$					
			\end{itemize}			
			
		\item[$(\beta)$] if $\ty$ is an arrow type $\tyarr$ for some types 
		$\ty[1], \ty[2]$,	let $v_0, v'_0$ be two arbitrary values satisfying:
		$$~\eqv{v_0}~\bwedge \typerule{v_0}{\ty[1]}{\bot_\theta}{\bot_\rho}{}.$$
		By hypothesis, we have the reduction steps:
		$$\evalstar{{t_0}}{0}{{t_1}}{1}\quad\evalstar{{t'_0}}{0}{{t'_1}}{1}$$						which induce respectively: 
		$$\evalstar{\tmapp{t_0}{v_0}}{0}{\tmapp{t_1}{v_0}}{1} \quad
		\evalstar{\tmapp{t'_0}{v'_0}}{0}{\tmapp{t'_1}{v'_0}}{1}$$	
		From the definition of $\eqv{t_0}$, it follows that
		$${\tmapp{t_0}{v_0}} \thicksim {\tmapp{t'_0}{v'_0}}.$$
		Therefore, the induction hypothesis on $\ty[2]$ yields 
		$${\tmapp{t_1}{v_0}}\thicksim{\tmapp{t'_1}{v'_0}}.$$
		Finally, as $v_0, v'_0$ are arbitrary chosen values (satisfying the
		two conditions above), the result holds for any such values, 
		therefore by lemma \ref{equiv-def-l},
		$$\eqv{t_1}.$$ Back to \ref{equiv-red2-l}.	
		\end{itemize}	
	\end{proof}		

	\begin{lemma}

	\label{equiv-subst-p}
	\end{lemma}

	\begin{proof}
	Back to \ref{equiv-subst-l}.
	\end{proof}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{References} 
%\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{abbrevs,demons,demons2,demons3,team,crossrefs}

\end{document}

(*
Local Variables:
compile-command: "rubber -d main"
End:
*)
