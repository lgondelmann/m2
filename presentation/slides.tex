%\documentclass{beamer}
%
%\usepackage[utf8]{inputenc}
%\usepackage[french]{babel}
%
%\begin{document}
%
%\title{Deductive Verification of Stateful Second-Order Programs}
%\author{Léon Gondelman}
%\date{M2 internship \\ \today}
%
%\begin{frame}
%  \maketitle
%\end{frame}


\documentclass[xcolor=dvipsnames]{beamer}
\usepackage{etex}
\usetheme{Pittsburgh}
\usepackage{lmodern} \linespread{1.1}
\usepackage[latin1]{inputenc}
\usepackage[sc]{mathpazo} \linespread{1.1}
\usepackage{changepage}
 \usepackage{float}
\usepackage{setspace}
\usepackage{pstricks,pstricks-add,pst-math,pst-xkey}
\usepackage{multicol}
\usepackage{bcprules, proof}

%\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{mathdots}
\usepackage[usenames,dvipsnames]{}
\usepackage{amssymb,amsfonts,amsthm,amsmath}
\RequirePackage{listings}
\RequirePackage{amssymb}
\usepackage{tikz}

\lstset{
	xleftmargin=\parindent,
  basicstyle={\ttfamily},
%  framesep=2pt,
%  frame=single,
  keywordstyle={\color{blue}},
  stringstyle=\itshape,
  commentstyle=\itshape,
  columns=[l]fullflexible,
  showstringspaces=false,
  mathescape=true
}

%\lstset{basicstyle={\ttfamily}}
\lstdefinelanguage{whycode}{
morekeywords=[1]{},%
string=[b]",%
showstringspaces=false,%
stringstyle=\itshape,%
commentstyle= \color{gray}\small\texttt, %
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true}
\lstset{language=whycode,
emph={namespace,predicate,module,fun,while,done,function,inductive,type,use,clone,%
import,export,theory,end,in,match,with,let,ghost,ensures,requires,ensures,invariant, rec,variant,then,if,else,%
goal,axiom,lemma,forall, induction},
emphstyle=\color{blue}}

\lstset{language=whycode}
\lstnewenvironment{whycode}{\lstset{language=whycode}}{}

\label{whygray}
\lstdefinelanguage{whygray}{
morekeywords=[1]{},%
string=[b]",%
showstringspaces=false,%
stringstyle=\itshape,%
commentstyle= \color{gray}\small\texttt, %
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true}

\lstnewenvironment{whygray}{
\lstset{
language=whygray, 
stringstyle=\color{gray},
emphstyle=\color{gray}}\gray}{\gray}





\let\why\lstinline
%\newcommand{\blue[1]}{\color{blue}}
\let\emph\alert
\beamertemplatenavigationsymbolsempty
\newcommand{\HRule}{\rule{\linewidth}{0.1mm}}

\newenvironment{aquote}[1]
  {\savebox\mybox{#1}\begin{quote}}
  {\signed{\usebox\mybox}\end{quote}}

\addtobeamertemplate{footline}{\hfill\insertframenumber/\inserttotalframenumber}



\newcommand{\bwedge}{\boldsymbol{~\wedge~}}
\newcommand{\bvee}{\boldsymbol{~\vee~}}
\newcommand{\brarr}{\boldsymbol{~\Rightarrow~}}
\setbeamertemplate{frametitle}{\vspace*{1em}\hfill\insertframetitle} 
\addtocounter{framenumber}{-1}

\newcommand{\crond}[2]{
\tikz \node[draw,circle,scale=0.21,fill=#2]{\black \Huge  \textbf{#1}};}
\newcommand{\rond}[1]{
\tikz \node[draw,circle,scale=0.21,fill=red]{\black \Huge  \textbf{#1}};}
\begin{document}
\section*{Title}
\begin{frame}
\begin{center}
\vspace{-1.cm}
%\HRule

\textsc{\blue{\Large Deductive Verification of \\[0.2cm] 
Stateful Second-Order Programs }}\\
%\HRule
 \textsc{ \scriptsize master's degree second year internship}\\[0.4cm]
{\small  L\'eon \textsc{Gondelman}}  \\[0.5cm]

%\includegraphics[scale=0.15]{image_title3}
\end{center}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% 1. contexte, problème, exemple introductif (array_iter)
% sum_loop et sum_iter en parallèle


\begin{frame}{Formal Verification Informally}
\begin{quotation}
 ''The most important property of a program is whether it accomplishes the intention of its user.''\\
\hfill{\blue{C.A.R. Hoare}}
\end{quotation}
\bigskip
\end{frame}

\begin{frame}
\frametitle{Deductive program verification}
Proof + program $\rightarrow$ mathematical statement  $\rightarrow$ proof \\[1cm]
\pause
  \begin{enumerate}
  \item {\red specify} an (existing) program \pause

  % \begin{center}
  %   \includegraphics{approach3.mps}
  % \end{center}
  \item {\red generate} verification conditions \pause
  \item {\red discharge} them, using
    \begin{itemize}
    \item ATP when possible
    \item proof assistants otherwise
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}
\frametitle{}
- used for  
	-  imperative programs written in languages such as C and Java.  \\
	-  first-order 
	-  OK with ATPs

- Recently, emergence of research works on the verification of higher-order \\
	- functional programs (Yann, Coq, ...)\\
	- stateful programs (Kanig, F-star, Arthur, ...)\\
  - higher-order logic

Challenge: proof automation ...
\end{frame}

\section*{Introduction}
\subsection*{Computing the sum of array elements}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-0.3cm}{1.0cm}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_loop (a: int array)
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do
    s := !s + a.(!i);
    i := !i + 1
  done;
  !s
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ref 0 in
  Array.iter 
    (fun x -> s := !s + x) a;
  !s
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\end{frame}

\subsection*{Verifying Sum\_loop}
\subsubsection*{Code}
\newcommand{\OliveGreen}[1]{\textcolor{OliveGreen}{#1}}
\newcommand{\Rouge}[1]{\textcolor{red}{#1}}
\newcommand{\Noir}[1]{\textcolor{black}{#1}}
\begin{frame}[fragile]
\frametitle<1>
{sum example with {loop}}
\frametitle<2>
{\quad program specification}
\frametitle<3>
{\quad loop invariant}
\frametitle<4>
{precondition}
\frametitle<5>
{array bound check}
\frametitle<6>
{preservation}
\frametitle<7>
{postcondition}
\vspace*{-3em}
\begin{displaymath} 	
\begin{array}{@{\hspace*{0em}}l@{\hspace*{1.5em}}ll@{\hspace*{1em}}l}

\only<-3>{\vspace*{2em}}
\only<4>{
 \rond{vc1}	 
 &\textcolor{red}{\emptyset}
 &\textcolor{red}{\vdash}
 &\textcolor{red}{(0 \leq 0 \bwedge 0 \leq n) \bwedge 0 = \sum_{~0\leq j < 0} a[j] \phantom{ phantom of the opera is here right now}}}

\only<5>{
	\rond{vc2}
	&\textcolor{red}{\mathcal{I} \bwedge i < n}
	&\textcolor{red}{ \vdash} 
	&\textcolor{red}{ 0 \leq i < n} \phantom{phantom of the opera is here right now}}


\only<6>{
	\rond{vc3}
	&\textcolor{red}{\mathcal{I} \bwedge i < n}
	&\textcolor{red}{\vdash} 
	&\textcolor{red}{s + a[i] = \sum_{~0 \leq j < i+1} a[j] \bwedge (0 \leq (i+1) \leq n)   \phantom{phantom of the opera is here right now}}}


\only<7>{
	\rond{vc4}
	&\textcolor{red}{ \mathcal{I} \bwedge i \geq n} 
	&\textcolor{red}{ \vdash}
	&\textcolor{red}{ s = \sum_{~0 \leq j < n} a[j] \phantom{phantom of the opera is here right now}}}

\end{array}
\end{displaymath}
\vspace*{-2em}
\begin{normalsize}
	\begin{whycode}  
let sum_loop (a: int array) *?\only<2->{\\ 
	{\blue ensures} $\{\texttt{ {\blue result} = }{\red~\sum_{~0 \leq j < \text{a.length}} a[j]}~\}$}?* 
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  *?\only<4>{\hspace*{-2em}\crond{vc1}{red}~}\only<5->{\hspace*{-2em}\crond{vc1}{gray}~}?*while !i < n do *?
  
  \only<3->{\\    
  ${ \blue \hspace*{1em} \texttt{invariant}}  
   ~\{{\red~\mathcal{I}: \texttt{!s = } \sum_{0\leq j < !i} a[j] \bwedge 0 \leq !i \leq \texttt{n}}~\}$} 
  ?*
	 	*?
	 	\only<5>{\hspace*{-2em}\crond{vc2}{red}~}
	 	\only<4,6->{\hspace*{-2em}\crond{vc2}{gray}~}?*  s := !s + a.(!i);  
    i := !i + 1
 *?\only<6>{\hspace*{-1.5em}\crond{vc3}{red}\hspace*{-0.0em}}
 	\only<4-5,7->{\hspace*{-1.5em}\crond{vc3}{gray}\hspace*{-0.0em}}?* done;
 *?\only<4-6>{\hspace*{-1.5em}\crond{vc4}{gray}}\only<7->{\hspace*{-1.5em}\crond{vc4}{red}}?* !s 
\end{whycode}\vspace*{-0.5em}
\end{normalsize}
\end{frame}

\subsubsection*{Conclusion}
\begin{frame}
\frametitle{automated proof}
\begin{itemize}
\item All verification conditions {\tiny \rond{vc1} - \rond{vc4}} are first-order formulas.
\item Automated theorem provers easily prove them. 
%\item<4-> {\color{red} Can we generate first-order VCs from that specification ?}
\end{itemize}
\bigskip\pause
\begin{center}
 {\color{red} Can we prove \texttt{sum\_iter} in a similar way ?}
\end{center}
\end{frame}

\subsection*{Verifying Sum\_iter}
\subsubsection*{Code}


\begin{frame}[fragile]
\frametitle<1>{sum example with {iterator}}
\frametitle<2>{program specification}
\frametitle<3>{invariant formula}
\begin{whycode}
 let sum_iter (a: int array) *?\only<2->{\\
	{\blue \texttt{ ensures }}\{\texttt{ {\blue result} =} 
	${\red ~\sum_{~0 \leq j < \text{a.length}} a[j]~}$\}}?* 
 = let s = ref 0 in
   Array.iter*?
   \only<3->{\\\hspace*{3.5em}
   {\red(fun i -> !s = $\sum_{~0\leq j < i} a[j]$)}\\}?* 
       (fun x ->  s := !s + x) a; 
     !s 
\end{whycode}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{iterator specification}
\frametitle<2>{additional parameter}
\frametitle<3>{loop initial and final states}
\frametitle<4>{loop preservation}
\frametitle<5-6>{pros and cons}
\frametitle<7>{an existing solution}
\frametitle<8>{inlining}
\begin{whycode}  
let iter *?\only<2->{{\red \texttt{(inv:int -> prop) }}}?*(f:int -> unit) (b: int array) *?\only<3->{\\ 
\texttt{\blue requires }\{{\red \texttt{ inv 0 }}\} \\
\texttt{\blue ensures~  }\{{\red \texttt{ inv b.length }}\}}?* 
= let rec aux (i: int) *?\only<4->{\\
\texttt{~~\blue requires }\{{\red \texttt{ inv i} $\bwedge (0 \leq i \leq b.length)$}        \} \\
\texttt{~~\blue ensures~   }\{{\red \texttt{ inv b.length }}\}}?*  
  = if i < Array.length b 
    then (f b[i] ; aux (i + 1)) 
  in aux 0
\end{whycode} 
\bigskip
\only<5>{
$$ \fbox{\texttt{{\blue pros}: specification above is {\blue modular}}} $$}
\only<6>{
$$ \fbox{\texttt{{\red cons}: specification above is {\red partial}}} $$}
\only<7>{
 $$\texttt{\OliveGreen{complete the specification}}$$\vspace*{-1.5em} 
$$ \textcolor{purple}{\texttt{may be difficult to prove automatically}}$$
}
\only<8>{
$$ \texttt{\OliveGreen{\underline{inline} the definition of iterator}} $$
\vspace*{-1.5em} 
$$ \hspace*{0.5em}\texttt{\OliveGreen{\underline{instantiate} functional arguments}}$$}
\end{frame}


%
%\subsubsection*{Problem}
%\begin{frame}
%\frametitle<1-3>{\quad  Yes, but ...}
%\frametitle<4->{\quad Pragmatic approach:}
%\begin{itemize}
%\item[-]<1-> function \texttt{Array\_iter} is second-order code;
%\item[-]<2-> invariant \texttt{inv} is a second-order formula;
%\item[-]<3-> {\color{red} we cannot generate first-order VCs.}\\[1cm]
%%\item[-]<4-> { Yes, by second-order inlining !}\\[1em]
%\only<4->{ A simple solution:}~\\[0.5em]
%\begin{itemize}
%\item[\color{blue} 1)]<4-> {\color{blue} inline the definition of array\_iter};\\[1em]
%\item[\color{blue} 2)]<4-> {\color{blue} instantiate functional parameters \texttt{f} and \texttt{inv} }.
%\end{itemize}
%\end{itemize}
%\end{frame}
%

\subsubsection*{Solution:Second-Order Inlining}
\begin{frame}[fragile]
%\frametitle{\OliveGreen{inline definition of iterator}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode} 
module Array 
... 
   let iter (inv:int -> prop) (f:int -> unit) (b: int array)
   requires { inv 0 } 
   ensures  { inv b.length } 
   = let rec aux (i: int)
     requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{b.length}$ }
     ensures  { inv b.length }
     = if i < Array.length b
       then (f b[i] ; aux (i + 1)) 
     in aux 0
...
end

let sum_iter (a: int array) 
ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
= let s = ref 0 in
  Array.iter 
    (fun i -> !s = $\sum_{~0\leq j < i} a[j]$) (fun x -> s := !s + x) a; 
  !s
\end{whycode} 
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}




\begin{frame}[fragile]
\frametitle{\OliveGreen{inline iter}}
\vspace*{0em}
\begin{footnotesize}
\begin{whygray}
let sum_iter (a: int array) 
ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
= let s = ref 0 in 
\end{whygray}\vspace*{-1.15em} 
\begin{whycode}
  let iter (inv:int -> prop) (f:int -> unit) (b: int array)
  requires { inv 0 } 
  ensures  { inv b.length } 
  = let rec aux (i: int)
    requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{b.length}$ }
    ensures  { inv b.length }
    = if i < Array.length b
      then (f b[i] ; aux (i + 1)) 
    in aux 0 \end{whycode} \vspace*{-1.15em} 
 \begin{whygray}
  in iter (fun i -> !s = $\sum_{~0\leq j < i} a[j]$) (fun x -> s := !s + x) a; 
  !s
\end{whygray}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\subsubsection*{instantiate invariant}
\begin{frame}[fragile]
\frametitle{\OliveGreen{instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
= let s = ref 0 in 
  let iter ${\red \texttt{(inv:int -> prop)}}$ (f:int -> unit) (b: int array)
  requires { inv 0 } 
  ensures  { inv b.length } 
  = let rec aux (i: int)
    requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{b.length}$ }
    ensures  { inv b.length }
    = if i < Array.length b
      then (f b[i] ; aux (i + 1)) 
    in aux 0
  in iter ${\red \texttt{(fun i -> !s = } \sum_{~0\leq j < i} a[j])}$ (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\begin{frame}[fragile]
\frametitle{\OliveGreen{instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${\red \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
  ensures  { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{b.length}} \texttt{a[j]}})$ } 
  = let rec aux (i: int)
    requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{b.length}$ }
    ensures  { inv b.length }
    = if i < Array.length b
      then (f b[i] ; aux (i + 1)) 
    in aux 0
  in iter (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}



\begin{frame}[fragile]
\frametitle{\OliveGreen{instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${\red \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
  ensures  { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{b.length}} \texttt{a[j]}})$ } 
  = let rec aux (i: int)
    requires { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{b.length}$ }
    ensures  { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{b.length}} \texttt{a[j]}}$ }
    = if i < Array.length b
      then (f b[i] ; aux (i + 1)) 
    in aux 0
  in iter (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\subsubsection*{Instantiate function f}
\begin{frame}[fragile]
\frametitle{\OliveGreen{instantiate f}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${ \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
  ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{b.length}} \texttt{a[j]}})$ } 
  = let rec aux (i: int)
    requires { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{b.length}$ }
    ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{b.length}} \texttt{a[j]}}$ }
    = if i < Array.length b
      then (${\red\texttt{f}}$ b[i] ; aux (i + 1)) 
    in aux 0
  in iter ${\red\texttt{(fun x -> s := !s + x)}}$ a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
\frametitle{\OliveGreen{instantiate f}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${ \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
  ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{b.length}} \texttt{a[j]}})$ } 
  = let rec aux (i: int)
    requires { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{b.length}$ }
    ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{b.length}} \texttt{a[j]}}$ }
    = if i < Array.length b
      then (${\red\texttt{s := !s + b[i]}}$ ; aux (i + 1)) 
    in aux 0
  in iter a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\section*{Inlining}
\begin{frame}
 \begin{itemize}
 	\item[] $${\large \red \texttt{Inlining}}$$
 	\begin{center}
% 	\includegraphics[scale=0.31]{GhostBusters}
 	\end{center} 
 \end{itemize}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{our contribution}
\begin{frame}[fragile]
\frametitle{our contribution}

figure TODO \\
\bigskip
\begin{enumerate}
\item we identified the fragment of ML where inlining can be done
\begin{itemize}
\item syntax, semantics, type system with effects, typing restrictions
\item inlining formal description
\end{itemize} 
\item we proved that our inlining procedure is sound:
\begin{itemize}
\item inlining always terminates
\item inlining preserves the semantics
\end{itemize}
\end{enumerate}
\end{frame}



% 2. quelles difficultés
%    ce qui nous amène à Mini-ML = ML + références globales
%    syntaxe, sémantique, système de types avec effets, preuve de type soundness
%    identification d'un fragment de Mini-ML + définition inlining + preuve

%\begin{frame}\frametitle<1->{\quad Generalizing approach for second-order programs}
%%\frametitle<2->{\quad \color{red} }
%\vspace*{-4em}
%An annotated {\red second-order} program $\mathcal{P}$ of some language $\mathcal{L}$ with 
%\begin{itemize}
%\item[-]<1-> data structures: arrays, second-order functions, ...
%\item[-]<1-> side effects: mutable references, recursive functions, ...
%\end{itemize}
%becomes a {\red first-order} annotated program $\mathcal{I(P)}$.\\[2em]
%
%\only<2->{\textbf{Can we use the VCs generated from $\mathcal{I(P)}$ to verify  $\mathcal{P}$}? } ~ \\[0.5em]
%\only<4->{{\blue \quad Yes, but we must prove that $\mathcal{P}$ and $\mathcal{I(P)}$ are equivalent.}} ~ \\[0.5em]
%\only<3->{\textbf{ Can we generalize our approach for \textit{any} such program $\mathcal{P}$?}} ~ \\[0.5em]
%\only<5->{{\blue \quad It depends on what is $\mathcal{L}$.}} 
%%\only<5->{{\blue \quad No for any \textit{arbitrary} second-order program.} } ~ \\
%%\only<5->{{\blue \quad Yes for any program of some restricted \textit{subset} of programs similar to \texttt{sum\_iter}}}.
%\end{frame}

\subsection*{identify fragment}
\begin{frame}[fragile]\frametitle{les liaisons dangereuses}
\begin{small}
\begin{whycode} 
${\red \only<1>{\mathcal{P}_1}\only<2->{\mathcal{P}_2}}$: 
   let F = 
      ($\only<1>{\texttt{\red r:= !r + 1;}}\only<2->{\texttt{\red diverge(); }}$ fun (f:int -> int) -> f !r)
   in $\only<1>{\texttt{(F id) + (F id)}}\only<2->{\texttt{()}}$
   
*?%$\hspace*{8em}\only<2>{{\red \mathcal{P}_{1_{\{r=0\}}} \longrightarrow^{\star} 2_{\{ r=1\}}}}\only<4>{\red \mathcal{P}_{2_{\{r=0\}}} \longrightarrow^{\star} \infty}$
?* 
${\red\only<1>{ \mathcal{I}(P_1)}\only<2->{\mathcal{I}(P_2)}}: \only<1>{\texttt{(r:= !r + 1; !r) + (r:= !r + 1; !r)}}
\only<2->{\texttt{()}}$
   
*?%$\hspace*{8em}\only<2>{\mathcal{I}(P_1)_{\{r=0\}} \longrightarrow^{\star} 3_{\{r=2\}}}\only<4>{\mathcal{I}(P_2)_{\{r=0\}} \longrightarrow^{\star} ()_{\{r=0\}}}$      
?*
\end{whycode}
\end{small}
\end{frame}

\subsection*{type system with effects}
\begin{frame}[fragile]
\frametitle{experimental language}
%\hspace*{-2em} \mbox{{\blue Our approach}: identify the subset of ML language in which we can write}\vspace*{-0.5em}
%\begin{itemize}
%\item[-] interesting examples like sum\_iter;
%\item[-] only programs we can inline correctly.\\[1em]
%\end{itemize}\pause
%{\hspace*{-2em} \blue A hint of the solution}: 
a fragment of ML with
\begin{itemize}
	\item[-] references, recursion, integers, integer lists
	\item[-] {\red second-order} typed terms\\[0.5em]
		\begin{itemize}	
		\begin{footnotesize} 
			\item[] \qquad$\tau^{\red 0}:\{\texttt{ int, bool,... }\}$
			\item[] \qquad$\tau^{\red 1}:\{\texttt{ int -> bool, int -> (int -> bool), ... }\}$
			\item[] \qquad$\tau^{\red 2}:\{\texttt{ (int -> int) -> bool, ... }\}$\\[1em]
		\end{footnotesize}
		\end{itemize}
		 \pause
	\item[-] a type system {\red with effects}:\\[0.5em]
		\begin{itemize}
			\item[] \qquad $\Gamma \vdash t^{i}: \tau, {\red \theta, \rho} $
		\end{itemize}
\end{itemize}
\end{frame}


\subsection*{Example: typing of local bindings}
\begin{frame}[fragile]
\frametitle{Example: typing rule for local bindings}
\begin{small}
%\begin{adjustwidth}{-1.5em}{0em}
%\begin{displaymath}
%		\dfrac
%		 {\Gamma_1 \vdash t_1 : \tau^i, \theta_1, \rho_1
%		  \qquad \Gamma_2, x:\tau^i  \vdash t_2 : \tau^j, \theta_2, \rho_2 
%		  \qquad \only<1>{\phantom{\textcolor{red}{(i = 2) \Rightarrow 
%			\boldsymbol{(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}}}}			
%			\only<2->{ \textcolor{red}{(i = 2) \Rightarrow 
%			\boldsymbol{(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}}}}
%		 {\Gamma_1 \vdash \text{ let } x = t_1 \text{ in } t_2 
%				: \tau^{j}, 
%				(\theta_1 \bvee \theta_2), 
%				(\rho_1 \bvee \rho_2)}
%\end{displaymath}		
%\end{adjustwidth}	

		\infrule[] 
			{\vspace*{0.5em}\hspace*{-2.1em}\Gamma_1 \vdash t_1 : \tau^i, \Rouge{\theta_1}, \Rouge{\rho_1} 
			\quad \Gamma_2, x:\tau^i  \vdash t_2 : \tau^j, \Rouge{\theta_2}, \Rouge{\rho_2} 
			\quad 
			\only<1>{\phantom{\textcolor{blue}{(i = 2) \Rightarrow 
			\boldsymbol{(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}}}}			
			\only<2->{ \textcolor{blue}{(i = 2) \Rightarrow 
			(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}}} 
			{\vspace*{-1em}\hspace*{-2.1em}\Gamma_1 \vdash \text{ let } x = t_1 \text{ in } t_2 
				: \tau^{j}, 
				(\Rouge{\theta_1 \bvee \theta_2}), 
				(\Rouge{\rho_1 \bvee \rho_2})}
	\end{small}
	%\end{adjustwidth}	
\end{frame}

\subsection*{Properties of Inlining}
\begin{frame}\frametitle{To summarize, in our work}\vspace*{-4em}
\begin{itemize}
	\item[\blue$-$]  we described of the inlining by the set of rewriting rules; \\[1em]
	\item[\blue$-$]  we proved that the procedure described by these rules \\[0.5em]
	
	\begin{itemize}
		\item[$\blacktriangleright$]
		{\normalsize always {\red terminates } giving a first-order output term} \\[0.3em]
		\item[$\blacktriangleright$]  
		{\normalsize {\red preserves} the semantics of the initial term} \\[1em]
	\end{itemize}
	\item[\blue $-$] we formalized the notion of {\red ghost code}
\end{itemize}
\end{frame}

\section*{Ghost Code}

\begin{frame}
 \begin{itemize}
 	\item[] $${\large \red \texttt{Ghost Code}}$$
 	\begin{center}
 	\includegraphics[scale=0.31]{GhostBusters}
 	\end{center} 
 \end{itemize}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{Ghost properties informally}
\begin{frame}
\frametitle{\red{Ghost code}}
	may be inserted for the purpose of specification and/or proof.
	\begin{itemize}
	\item[\red $\bullet$] regular code does not see ghost data
	\item[\red $\bullet$] ghost code may read regular data (but cannot modify it)
	\end{itemize}
in particular, ghost code may be removed without observable modification


\end{frame}

\subsection*{List example} 
\begin{frame}[fragile]
\frametitle{Annotating \texttt{sum\_iter} with list}
\begin{footnotesize}
\begin{whycode}
  let sum_list (l0: list int) : int
    ensures { result = $\sum$ l0 }
  = let s = ref 0 in
    list_iter $\texttt{(}{\red \lambda \texttt{before.!s = } \sum \texttt{before)}}$ (fun x -> s := !s + x) l0; 
    !s     
\end{whycode}
\end{footnotesize}
\end{frame}


\begin{frame}[fragile]
\frametitle{invariant precondition and postcondition}
\begin{footnotesize}
\begin{whycode}
let list_iter ($\textcolor{red}{\text{inv:int list -> unit}})$ 
    (f:int -> unit) (l: int list)
     requires  $\text{\{\text{inv } Nil \}}$
     ensures $\text{~~}\{ \text{inv (reverse l)
     	 }\}$    
 = ${\gray\texttt{let rec loop (ai: int list) (bi: int list)}}$
      ${\gray\texttt{requires \{ inv (rev bi) \} }}$
      ${\gray\texttt{ensures  \{ inv (rev\_append ai bi) \}}}$  
    ${\gray\texttt{= match ai with}}$
       ${\gray\texttt{| Nil       -> ()}}$
       ${\gray\texttt{| Cons x xs -> f x; loop xs (Cons x bi) end}}$
   ${\gray\texttt{in loop l Nil}}$
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\begin{frame}[fragile]
\frametitle{invariant preservation}
\begin{footnotesize}
\begin{whycode}
${\gray\texttt{let list\_iter (inv:int list -> int list -> unit)}}$ 
    ${\gray\texttt{(f:int -> unit) (l: int list)}}$
     ${\gray\texttt{requires \{ inv Nil \}}}$
     ${\gray\texttt{ensures \{ inv (reverse l)\}}}$    
 = let rec loop (ai: int list) $(\textcolor{red}{\text{bi: int list}})$
      requires  $\texttt{\{  inv {\red (rev bi)} \}}$
      ensures   $\texttt{\{  inv {\red(rev\_append ai bi)} }\}$  
    = match ai with 
       | Nil       -> ()
       | Cons x xs -> f x; loop xs $(\textcolor{red}{\text{Cons x bi}})$) end
   in loop l Nil
\end{whycode}
\end{footnotesize}
\end{frame}

\subsection*{Intro example}
%\begin{frame}[fragile]
%\frametitle{Verification: there and back again}
%%We can inline and prove sum\_iter with lists alike we did with arrays. \\
%%What if we want to go back to unspecified version of list\_iter ?
%\begin{footnotesize}
%\begin{whycode}
%let list_iter ($\textcolor{red}{\text{inv:int list -> unit}})$ 
%    (f:int -> unit) (l: int list)
% = let rec loop (ai: int list) $(\textcolor{red}{\text{bi: int list}})$
%    = match ai with 
%       | Nil       -> ()
%       | Cons x xs -> f x; loop xs $(\textcolor{red}{\text{Cons x bi}})$) end
%   in loop l Nil
%\end{whycode}
%\end{footnotesize}
%%OK for \texttt{inv}. What to do with \texttt{bi} ?
%\end{frame}
%\addtocounter{framenumber}{-1}


%\begin{frame}[fragile]
%\frametitle{Program specification: there and back again}
%%We can inline and prove sum\_iter with lists alike we did with arrays. \\
%%What if we want to go back to unspecified version of list\_iter ?
%\begin{footnotesize}
%\begin{whycode}
%let list_iter (f:int -> unit) (l: int list)
% = let rec loop (ai: int list) $(\textcolor{red}{\text{bi: int list}})$
%    = match ai with 
%       | Nil       -> ()
%       | Cons x xs -> f x; loop xs $(\textcolor{red}{\text{Cons x bi}})$) end
%   in loop l Nil
%\end{whycode}
%\end{footnotesize}
%%OK for \texttt{inv}. What to do with \texttt{bi} ?
%\end{frame}
%\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
\frametitle{Ghost Code}
\begin{footnotesize}
\begin{whycode}
let list_iter (ghost $\textcolor{black}{\text{inv:int list -> unit}})$ 
    (f:int -> unit) (l: int list)
     ${\gray\texttt{requires \{ inv Nil \}}}$
     ${\gray\texttt{ensures \{ inv (reverse l)\}}}$    
 = let rec loop (ai: int list) (ghost$\textcolor{black}{\text{ bi: int list}})$
      ${\gray\texttt{requires \{ inv (rev bi) \} }}$
      ${\gray\texttt{ensures  \{ inv (rev\_append ai bi) \}}}$  
    = match ai with 
       | Nil       -> ()
       | Cons x xs -> f x; loop xs $(\textcolor{red}{\text{Cons x bi}})$) end
   in loop l Nil
\end{whycode}
\end{footnotesize}
\end{frame}

\subsection*{Ghost formalisation}

% un pgm avec du code ghost :
%  - pour le prouver, je prends *tout* le code, sans distinction
%  - pour l'exécuter, j'oublie le code ghost
% tout est dans le typage, qui garantit la non-interférence
\section*{Conclusion}

	
% In this work (1) formalize domain 
% prove soundness 

% Formaliziation : typing
% Correctness : equivalence
% Example

%\subsubsection*{Spec of array_inter}
%\begin{frame}[fragile]{blabla}
%\begin{footnotesize}
%\begin{whycode}  
%   let array_iter ($\textcolor{red}{\text{f:int -> unit}}$) (b: array int) ($\textcolor{red}{\text{inv:int -> array int -> prop}}$)    
%     $\textcolor{OliveGreen}{\text{requires \{ \textcolor{red}{\text{inv }} 0~b \}}}$
%     $\textcolor{OliveGreen}{\text{ensures~~}\{ \text{ \textcolor{red}{inv} b.length~b }\}}$  
%   = let rec loop (i: int)
%       $\textcolor{OliveGreen}{ \text{requires \{~\textcolor{red}{inv} i b} \bwedge \text{0 <= i <= b.length}~\}}$
%       $\textcolor{OliveGreen}{\text{ensures~~}\{ \text{ \textcolor{red}{inv} b.length~b}\}}$ =    
%       = if i < b.length then ($\textcolor{red}{\text{f}}$ b[i]; loop (i+1)) 
%     in loop 0       
%                                          (*array_iter partial specification*)
%\end{whycode}
%\begin{whycode} 
% let sum_iter (a: array int) =$\pause$		 
%   let s = ref 0 in 
%   array_iter $\textcolor{red}{\text{(fun x -> s := !s + x)}}~$ a $\textcolor{red}{(\lambda i_{int}.\lambda c_{\texttt{array int}}. \sum_{~0\leq j < i} a[j])}$                    
%                                   (*invariant instantiation in the source code *)
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%
%\subsubsection*{Annot of sum_iter}
%\begin{frame}[fragile]{blabla}
%d
%\end{frame}

%\subsubsection*{Inlining}
%\begin{frame}[fragile]{blabla}
%d
%\end{frame}


% solution technique = inlining, dérouler sur l'exemple de sum_iter

% 2. quelles difficultés
%    ce qui nous amène à Mini-ML = ML + références globales
%    syntaxe, sémantique, système de types avec effets, preuve de type soundness
%    identification d'un fragment de Mini-ML + définition inlining + preuve
%\subsection*{Inlining procedure}
%
%\begin{frame}\frametitle{}
%\end{frame}
%
%\begin{frame}\frametitle{}
%\end{frame}
%
%\begin{frame}\frametitle{}
%\end{frame}

% 3. maintenant list_iter, servant à introduire l'idée de code ghost

%  d'abord le code de list_iter + le code client sum_list

%  puis la spec avec un argument supplémentaire

% => introduit la notion de code ghost

% 4. formalisation de Ghost-ML
%    syntaxe, sémantique, typage avec effets (montrer le jugement),
%      bien expliquer qu'il y a des choix à faire (mais aussi des*)
%      obligations), l'opération erasure et la preuve

\end{document}


%\subsubsection*{VCs}
%\begin{frame}[fragile]\frametitle{Verification Conditions}
%
%\begin{footnotesize}
%\begin{displaymath}
%\begin{array}{@{\hspace*{-2.5em}}l@{\hspace*{1.5em}}rl@{\hspace*{1em}}l}
%% \textsc{\scriptsize (Notations)} 
%%  &  &  n:~~ \text{a.length} & \\
%%  
%%  & & & P:~~ s = \sum_{~0\leq j < i} a[j] ~\bwedge~ 0 \leq i \leq n \\[1em]
%
% \textsc{\scriptsize (loop initialisation)}  
% & \emptyset 
% &\vdash 
% &(0 \leq 0 \bwedge 0 \leq n) \bwedge 0 = \sum_{~0\leq j < 0} a[j]	
% \\[1em]
%
%	\textsc{\scriptsize (loop preservation)} 
%	& P \bwedge i < n 
%	&\vdash 
%	&	(0 \leq (i+1) \leq n) \bwedge s + a[i] = \sum_{~0 \leq j < i+1} a[j]
%	\\[1em]
%
%	\textsc{\scriptsize (array bound check)} 
%	& P \bwedge i < n 
%	& \vdash 
%	& 0 \leq i \leq n 
%	\\[1em]
%
%	\textsc{\scriptsize (postcondition)}  
%	& P \bwedge i \geq n 
%	& \vdash 
%	& s = \sum_{~0 \leq j < n} a[j] 
%
%\end{array}
%\end{displaymath}
%\end{footnotesize}
%\end{frame}


%\begin{frame}[fragile]
%\frametitle{Specifying \texttt{list\_iter}}
%\begin{footnotesize}
%\begin{whycode}
%let list_iter ($\textcolor{red}{\text{inv:int list -> int list -> unit}})$ 
%    (f:int -> unit) (l: int list)
%     requires  $\text{\{\text{inv } Nil~l \}}$
%     ensures $\text{~~}\{ \text{inv (reverse l)~Nil
%     	 }\}$    
% =
%\end{whycode}
%\end{footnotesize}
%\vspace*{6em}
%\end{frame}
%\addtocounter{framenumber}{-1}

%\begin{footnotesize}
%\begin{whycode}
%let list_iter ($\textcolor{red}{\text{inv:int list -> unit}})$ 
%    (f:int -> unit) (l: int list)
%     ${\gray\texttt{requires \{ inv Nil \}}}$
%     ${\gray\texttt{ensures \{ inv (reverse l)\}}}$    
% = let rec loop (ai: int list) $(\textcolor{red}{\text{bi: int list}})$
%      ${\gray\texttt{requires \{ inv (rev bi) \} }}$
%      ${\gray\texttt{ensures  \{ inv (rev\_append ai bi) \}}}$  
%    = match ai with 
%       | Nil       -> ()
%       | Cons x xs -> f x; loop xs $(\textcolor{red}{\text{Cons x bi}})$) end
%   in loop l Nil
%\end{whycode}
%\end{footnotesize}

% Local Variables:
% compile-command: "rubber -d slides"
% ispell-local-dictionary: "francais"
% End:



