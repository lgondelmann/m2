


\documentclass[xcolor=dvipsnames]{beamer}
\usepackage{etex}
\usetheme{Pittsburgh}
\usepackage{lmodern} \linespread{1.1}
\usepackage[latin1]{inputenc}
\usepackage[sc]{mathpazo} \linespread{1.1}
\usepackage{changepage}
 \usepackage{float}
\usepackage{setspace}
\usepackage{pstricks,pstricks-add,pst-math,pst-xkey}
\usepackage{multicol}
\usepackage{bcprules, proof}

%\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{mathdots}
\usepackage[usenames,dvipsnames]{}
\usepackage{amssymb,amsfonts,amsthm,amsmath}
\RequirePackage{listings}
\RequirePackage{amssymb}
\usepackage{tikz}

\lstset{
	xleftmargin=\parindent,
  basicstyle={\ttfamily},
%  framesep=2pt,
%  frame=single,
  keywordstyle={\color{blue}},
  stringstyle=\itshape,
  commentstyle=\itshape,
  columns=[l]fullflexible,
  showstringspaces=false,
  mathescape=true
}

%\lstset{basicstyle={\ttfamily}}
\lstdefinelanguage{whycode}{
morekeywords=[1]{},%
string=[b]",%
showstringspaces=false,%
stringstyle=\itshape,%
commentstyle= \color{gray}\small\texttt, %
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true}
\lstset{language=whycode,
emph={namespace,result,predicate,module,fun,while,done,function,inductive,type,use,clone,%
import,export,theory,end,in,match,with,do,let,ghost,ensures,requires,ensures,invariant, rec,variant,then,if,else,%
goal,axiom,lemma,forall, induction},
emphstyle=\color{blue}}

\lstset{language=whycode}
\lstnewenvironment{whycode}{\lstset{language=whycode}}{}

\label{whygray}
\lstdefinelanguage{whygray}{
morekeywords=[1]{},%
string=[b]",%
showstringspaces=false,%
stringstyle=\itshape,%
commentstyle= \color{gray}\small\texttt, %
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true}

\lstnewenvironment{whygray}{
\lstset{
language=whygray, 
stringstyle=\color{gray},
emphstyle=\color{gray}}\gray}{\gray}


\newcommand{\OliveGreen}[1]{\textcolor{OliveGreen}{#1}}
\newcommand{\Rouge}[1]{\textcolor{red}{#1}}
\newcommand{\Noir}[1]{\textcolor{black}{#1}}


\let\why\lstinline
%\newcommand{\blue[1]}{\color{blue}}
\let\emph\alert
\beamertemplatenavigationsymbolsempty
\newcommand{\HRule}{\rule{\linewidth}{0.1mm}}

\newenvironment{aquote}[1]
  {\savebox\mybox{#1}\begin{quote}}
  {\signed{\usebox\mybox}\end{quote}}

\addtobeamertemplate{footline}{\hfill\insertframenumber/\inserttotalframenumber}


\newcommand{\rouge}[1]{\textcolor{red}{#1}}
\newcommand{\bwedge}{\boldsymbol{~\wedge~}}
\newcommand{\bvee}{\boldsymbol{~\vee~}}
\newcommand{\brarr}{\boldsymbol{~\Rightarrow~}}
\setbeamertemplate{frametitle}{\vspace*{1em}\hfill\insertframetitle} 
\addtocounter{framenumber}{-1}

\newcommand{\gb}{\beta}
\newcommand{\gba}[1]{\beta_{#1}}
\newcommand{\gbb}{\bot_\beta}
\newcommand{\gbt}{\top_\beta}

\newcommand{\gbr}{\textcolor{red}{\gb}}
\newcommand{\gbra}[1]{\textcolor{red}{\gba{#1}}}
\newcommand{\gbbr}{\textcolor{red}{\gbb}}
\newcommand{\gbtr}{\textcolor{red}{\gbt}}
\newcommand{\gbran}[1]{\textcolor{red}{\neg\gba{#1}}}
\newcommand{\bth}{\bot_\theta}
\newcommand{\brh}{\bot_\rho}  
\newcommand{\tth}{\top_\theta}
\newcommand{\trh}{\top_\rho}   

\newcommand{\ghosttyping}[6]{\vdash_{gh}~#1~:~#2,~(#3,~#4,~\rouge{#5})~\textcolor{blue}{\boldsymbol{#6}}}

\newcommand{\crond}[2]{
\tikz \node[draw,circle,scale=0.21,fill=#2]{\black \Huge  \textbf{#1}};}
\newcommand{\rond}[1]{
\tikz \node[draw,circle,scale=0.21,fill=red]{\black \Huge  \textbf{#1}};}

\definecolor{cblue}{RGB}{90,110,160}


\begin{document}
\section*{Title}
\begin{frame}
\begin{center}
\vspace{-1.cm}
%\HRule

\textsc{\blue{\Large Deductive Verification of \\[0.2cm] 
Stateful Second-Order Programs }}\\
%\HRule
 \textsc{ \scriptsize master's degree second year internship}\\[2cm]
%{\small  L\'eon \textsc{Gondelman}}  \\[0.5cm]
%{\small Advisor: Jean-Christophe \textsc{Filli\a^tre}}
\bigskip
\begin{minipage}{0.3\textwidth}
\begin{flushleft} 
\emph{Author:}\\
L\'eon \textsc{Gondelman}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{flushright} 
\emph{Supervisor:} \\
Jean-Christophe \textsc{Filli\^atre}
\end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\small \today}



%\includegraphics[scale=0.15]{image_title3}
\end{center}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% 1. contexte, problème, exemple introductif (array_iter)
% sum_while et sum_iter en parallèle

\section*{Idea}
\begin{frame}{Idea}
\begin{quotation}
 ''The most important property of a program is whether it accomplishes the intention of its user.''\\
\hfill{\blue{C.A.R. Hoare}}
\end{quotation}
\bigskip
\end{frame}

\section*{Method}
\begin{frame}
\frametitle{Method}
\includegraphics{definition_en.mps}
\bigskip\pause
  \begin{enumerate}
  \item {\red specify} a program 
  \item {\red generate} verification conditions 
  \item {\red discharge} them, using
    \begin{itemize}
    \item ATP when possible
    \item proof assistants otherwise
    \end{itemize}
  \end{enumerate}
\end{frame}


\section*{A vantage point}
\begin{frame}

\frametitle{A vantage point}
\hspace*{-1.5em}
\only<1->{ verification of {\red imperative} programs (C, Java, ...)}
\begin{itemize}
\item<2->[] \hspace*{-2em} ${\blue \bullet}$  first-order logic {\small(Hoare Logic, Weakest Precondition Calculus)}
\item<3->[] \hspace*{-2em}  ${\blue \bullet}$ fully automatic first-order provers (Nqthm, Otter, SPASS)
\item<4->[] \hspace*{-2em}  ${\blue \bullet}$ efficient SMT provers (Alt-Ergo, Z3, ...) 
\end{itemize}
\bigskip
\hspace*{-1.5em}
\only<1->{verification of {\red functional } \underline{stateful} programs (OCaml, F$\sharp$, ...)}
\begin{itemize}
\item<5->[] \hspace*{-2em}  ${\blue \bullet}$ higher-order logic {CIC, \small(Hoare Type Theory, Kanig PhD, ...)} 
%\item<6->[] \hspace*{-2em}  ${\blue \bullet}$ purely functional programs (Coq, PVS, Pangolin)
\item<6->[] \hspace*{-2em}  ${\blue \bullet}$ stateful functional programs (F$^{\star}$, Who, CFML)
\item<7->[]  \hspace*{-2em}  ${\blue \bullet}$ interactive proof assistants (Coq, Isabelle, ...)
\end{itemize}\bigskip
\only<9>{$$\fbox{\texttt{{\blue challenge}:{\red HO programs proof automation}}}$$}
\end{frame}


\section*{Two sum programs}
\subsection*{code}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-0.3cm}{1.0cm}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do
    s := !s + a.(!i);
    i := !i + 1
  done;
  !s
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ref 0 in
  Array.iter 
    (fun x -> s := !s + x) a;
  !s
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{imperativeness}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-0.3cm}{1.0cm}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ${\red \texttt{ref 0}}$ in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do
    ${\red \texttt{s := !s + a.(!i)}}$;
    i := !i + 1
  done;
  ${\red \texttt{!s}}$
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ${\red \texttt{ref 0}}$ in
  Array.iter 
    (fun x -> ${\red \texttt{s := !s + x}}$) a;
   ${\red \texttt{!s}}$
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{while vs imperative}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-0.3cm}{1.0cm}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  ${\red \texttt{while}}$ !i < n ${\red \texttt{do}}$
    s := !s + a.(!i);
    i := !i + 1
  ${\red \texttt{done}}$;
  !s
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ref 0 in
  ${\red \texttt{Array.iter}}$ 
    ${\red \texttt{(fun x -> s := !s + x)}}$ a;
  !s
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\end{frame}

\subsection*{same spec}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-1em}{2em}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do
    s := !s + a.(!i);
    i := !i + 1
  done;
  !s
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ref 0 in
  Array.iter 
    (fun x -> s := !s + x) a;
  !s
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\only<1>{$$\textcolor{blue}{\texttt{programs are different}}$$
$$~$$}
\only<2>{$${\blue \texttt{but their meaning is the same:}}$$
$${ \red \texttt{ result =} \hspace*{-1em}\sum_{~0 \leq j < \text{a.length}}\hspace*{-1em} a[j]~}$$}
\end{frame}
\addtocounter{framenumber}{-1}


\section*{Verifying sum_while}
\begin{frame}[fragile]
\frametitle<1>
{Proving Sum\_while}
\frametitle<2>
{\quad Program specification}
\frametitle<3>
{\quad Loop invariant}
\frametitle<4>
{\quad {First-Order VCs}}
\frametitle<5->
{\quad {Automated proof}}
\vspace*{-1em}
\begin{normalsize}
	\begin{whycode}  
let sum_while (a: int array) *?\only<2->{\\ 
	{\blue ensures} \{ \texttt{{\blue result} = {\red sum 0 (length a) a }}\}}?* 
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do *?
    \only<3->{\\    
  ${ \blue \hspace*{1em} \texttt{invariant}}  
   ~\{{\red~\mathcal{I}: \texttt{!s = sum 0 !i a} \bwedge \texttt{0} \leq \texttt{!i} \leq \texttt{n}}~\}$} 
  ?*
	 	s := !s + a.(!i);  
    i := !i + 1
  done;
  !s 
\end{whycode}\vspace*{-0.5em}
\end{normalsize}


\begin{center}
\only<4>{\OliveGreen{we used only first-order formulae}}
\only<5>{\OliveGreen{generated verification conditions can be easily proved by ATPs}}
\only<6>{\red Can we prove \texttt{sum\_iter} in a similar way ?}
\end{center}
\end{frame}




\section*{Verifying Sum_iter}
\begin{frame}[fragile]
\frametitle<1>{Sum example with {iterator}}
\frametitle<2>{Program specification}
\frametitle<3>{Invariant formula}
\begin{whycode}
 let sum_iter (a: int array) *?\only<2->{\\
	{\blue \texttt{ ensures }}\{\texttt{ {\blue result} =} 
	{\red \texttt{ sum 0 (length a) a }}\}}?* 
 = let s = ref 0 in
   Array.iter*?
   \only<3->{\\\hspace*{3.5em}
   {\red\texttt{(fun i -> !s = sum 0 i a)}}\\}?* 
       (fun x ->  s := !s + x) a; 
     !s 
\end{whycode}
\end{frame}

\section*{Verifying Iterator}
\begin{frame}[fragile]
\frametitle<1>{Iterator specification}
\frametitle<2>{Additional parameter}
\frametitle<3>{Loop initial and final states}
\frametitle<4>{Loop iteration}
\frametitle<5-6>{Pros and cons}
\frametitle<7>{An existing solution}
\frametitle<8>{Pragmatic approach}
\begin{whycode}  
let iter *?\only<2->{{\red \texttt{(inv:int -> prop) }}}?*(f:int -> unit) (b: int array) *?\only<3->{\\ 
\texttt{\blue requires }\{{\red \texttt{ inv 0 }}\} \\
\texttt{\blue ensures~  }\{{\red \texttt{ inv (length b) }}\}}?* 
let n = Array.length b in
= let rec aux (i: int) *?\only<4->{\\
\texttt{~~\blue requires }\{{\red \texttt{ inv i}$\bwedge \texttt{0} \leq \texttt{i} \leq \texttt{n}$}        \} \\
\texttt{~~\blue ensures~   }\{{\red \texttt{ inv n }}\}}?*  
  = if i < n 
    then (f b.(i) ; aux (i + 1)) 
  in aux 0
\end{whycode} 
\bigskip
\only<5>{
$$ \fbox{\texttt{{\blue pros}: specification above is {\blue modular}}} $$}
\only<6>{
$$ \fbox{\texttt{{\red cons}: specification above is {\red partial}}} $$}
\only<7>{
 $$\texttt{\OliveGreen{complete the specification}}$$\vspace*{-1.5em} 
$$ \textcolor{purple}{\texttt{may be difficult to prove automatically}}$$
}
\only<8>{
$$ \texttt{\OliveGreen{\underline{inline} the definition of iterator}} $$
\vspace*{-1.5em} 
$$ \hspace*{0em}\texttt{\OliveGreen{\underline{instantiate} the invariant formula}}$$}
\end{frame}


\section*{Inlining Sum_iter}
\subsection*{Source code}
\begin{frame}[fragile]
%\frametitle{\OliveGreen{inline definition of iterator}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode} 
module Array 
... 
   let iter (inv:int -> prop) (f:int -> unit) (b: int array)
   requires { inv 0 } 
   ensures  { inv (length b) } 
   = let n = Array.length n in
     let rec aux (i: int)
     requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
     ensures  { inv n }
     = if i < n
       then (f b.(i) ; aux (i + 1)) 
     in aux 0
...
end

let sum_iter (a: int array) 
ensures { result = sum 0 (length a) a }
= let s = ref 0 in
  Array.iter 
    (fun i -> !s = sum 0 i a) (fun x -> s := !s + x) a; 
  !s
\end{whycode} 
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{Inlining iter code}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Inline iter}}
\vspace*{0em}
\begin{footnotesize}
\begin{whygray}
let sum_iter (a: int array) 
ensures { result = sum 0 (length a) a }
= let s = ref 0 in 
\end{whygray}\vspace*{-1.15em} 
\begin{whycode}
  let iter (inv:int -> prop) (f:int -> unit) (b: int array)
  requires { inv 0 } 
  ensures  { inv (length b) } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
    ensures  { inv n }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0 \end{whycode} \vspace*{-1.15em} 
 \begin{whygray}
  in iter (fun i -> !s = sum 0 i a) (fun x -> s := !s + x) a; 
  !s
\end{whygray}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{instantiate invariant 0}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter ${\red \texttt{(inv:int -> prop)}}$ (f:int -> unit) (b: int array)
  requires { inv 0 } 
  ensures  { inv (length b) } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
    ensures  { inv n }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0
  in iter ${\red \texttt{(fun i -> !s = sum 0 i a)}}$ (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{instantiate invariant 1}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${\red \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${\red \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { !s = sum 0 i a$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
    ensures  { !s = sum 0 n a }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0
  in iter (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{instantiate invariant 2}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { ${\red\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
    ensures  { ${\red\texttt{!s = sum 0 n a}}$ }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0
  in iter (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}



\subsection*{Instantiate f 1}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate f}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter ${\red\texttt{(f:int -> unit)}}$ (b: int array)
  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { ${\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
    ensures  { ${\texttt{!s = sum 0 n a}}$ }
    = if i < n
      then (${\red\texttt{f}}$ b.(i) ; aux (i + 1)) 
    in aux 0
  in iter ${\red\texttt{(fun x -> s := !s + x)}}$ a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


% TODO : conclusion we get FO program + FO spec -> (OK for provers) 
\subsection*{Instantiate f 2}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate f}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter (b: int array)
  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { ${\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
    ensures  { ${\texttt{!s = sum 0 n a}}$ }
    = if i < n
      then (${\red\texttt{s := !s + b.(i)}}$ ; aux (i + 1)) 
    in aux 0
  in iter a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}

% TODO : conclusion we get FO program + FO spec -> (OK for provers) 
\subsection*{Proving the result}
\begin{frame}[fragile]
\frametitle<1-4>{\OliveGreen{Instantiate f}}
\frametitle<5>{\normalsize \red Seems to be a good idea}
\vspace*{-2em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter (b: int array)
  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { ${\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
    ensures  { ${\texttt{!s = sum 0 n a}}$ }
    = if i < n
      then (${\red\texttt{s := !s + b.(i)}}$ ; aux (i + 1)) 
    in aux 0
  in iter a; 
  !s
\end{whycode}
\vspace*{-4em}
\begin{center} 
\only<2>{$$\fbox{\OliveGreen{\textbf{we get a first-order program}}}$$}
\only<3>{$$\fbox{\OliveGreen{\textbf{spec is first-order and complete}}}$$}
\only<4>{$$\fbox{\OliveGreen{\textbf{generated VCs can be proved automatically}}}$$}
\only<5>{$$\texttt{\Rouge{\textbf{\normalsize Let's work it out !}}}$$}
\end{center}
\end{footnotesize}
\end{frame}


%
\section*{Our first contribution}
\begin{frame}[fragile]
\frametitle{\red Our contribution}
\begin{displaymath}
\begin{array}{@{\hspace*{-1.2em}}llllllll}
  \begin{minipage}{0.2\textwidth}
  {\texttt{{\red HO} program}}\vspace*{-0.5em} \\
 	\hspace*{2em}+\vspace*{-0.5em}\\ 
	{\hspace*{0.5em}\texttt{{\blue FO} spec}}
  \end{minipage} & 
	\stackrel{\texttt{\normalsize \red inlining}}{\texttt{---------->}} \hspace*{0.1em} 
& 
	  \begin{minipage}{0.2\textwidth}
  {\texttt{\color{cblue}{FO} \gray program}}\vspace*{-0.5em} \\
 	\hspace*{2em}\color{cblue}{+}\vspace*{-0.5em}\\ 
	{\hspace*{0.5em}\texttt{\color{cblue}{FO} \gray spec}}
  \end{minipage}
& \stackrel{\texttt{\normalsize \gray VCs generator}}{{\gray \texttt{------------->}}}  & \texttt{\color{cblue}{FO} \gray VCs} 
\end{array}
\end{displaymath}\bigskip\pause
\begin{itemize}
\item[{\red 1.}] identify a fragment of ML where inlining can be done correctly \pause
\item[{\red 2.}] define inlining procedure on that fragment \pause
\item[{\red 3.}] prove that inlining procedure  
\begin{itemize}	
\item[{\red $\bullet$}] {\normalsize always {\red terminates}}
\item[{\red $\bullet$}] {\normalsize {\red preserves} semantics} \pause
\end{itemize}
\end{itemize}
\end{frame}

% 2. quelles difficultés
%    ce qui nous amène à Mini-ML = ML + références globales
%    syntaxe, sémantique, système de types avec effets, preuve de type soundness
%    identification d'un fragment de Mini-ML + définition inlining + preuve

\section*{Fragment of ML}
\begin{frame}[fragile]
\frametitle{A fragment of ML with}
 \pause
\begin{itemize}
	\item[-] {\red second-order} closures  
	\begin{footnotesize}
	\begin{whycode}
	    'apply2' : (int -> int -> bool) -> (int -> (int -> bool)) \end{whycode}
	\end{footnotesize}	\pause
	\item[-] global {\red mutable} references (with int, int list, ...) \pause
	\item[-] {\red first-order} recursion 
	\begin{small}
	\begin{whycode}
	      let h (f: int -> int)
        = let rec g (x: int)
          = if x = 0 then ${\red\texttt{(f x)}}$ else g${\red\texttt{ (f (x-1))}}$ \end{whycode}
	\end{small}\pause
	\item[-] a type system {\red with effets}
\end{itemize}
\end{frame}

\section*{Type system with effects}
\begin{frame}[fragile]
\frametitle<1>{Type system with effects}
\frametitle<2>{Ordering types}
%\frametitle<3>{Ordering types}
\frametitle<3>{Reference assignment}
\frametitle<4>{Recursive calls}
\frametitle<5-6>{Inlining correctness}
\frametitle<7>{Restrictions on typing system}
\begin{large}
\only<1>{
$$\Gamma \vdash t: \tau^{\texttt{\textbf{i}}}{, \theta, \rho}$$\bigskip
$$~$$
$$~$$
$$~$$}
%$$ \hspace*{0em}\OliveGreen{\small \texttt{restricts the order of references and recursive functions}} $$
%$$\hspace*{-7.5em}\OliveGreen{\small \texttt{gathers information about side-effects}}$$
%$$\OliveGreen{\small \texttt{guarantees that well-typed terms can be inlined correctly}}$$
%$$~$$}
\only<2>{
$$\hspace*{3em}\Gamma \vdash t: \tau^{\red \texttt{\textbf{i}}}, \theta, \rho \quad {\small \red \texttt{i = 0,1,2}} $$\bigskip
$$\hspace*{-16.5em}\texttt{{\blue ref} x:}~\tau^{\red 0}$$
$$\hspace*{-5em}\texttt{{\blue rec} g:}~\tau^{\red 0} \texttt{ -> } \texttt{(} \tau^{\red 0} \texttt{ -> ... -> } \tau^{\red 0} \texttt{)}$$
$$\hspace*{2.5em}\texttt{{\blue fun} h:}~\tau^{\red 1} \texttt{ -> } \texttt{(} \tau^{\red 1} \texttt{ -> ... -> (} \tau^{{\red 0}} \texttt{ -> ... -> } \tau^{{\red 0}} \texttt{))}$$}
%\only<3>{
%$$\Gamma \vdash t: \tau^{\red \texttt{\textbf{i}}}{\white, \theta, \rho} $$\bigskip
%$$\hspace*{-1em}\texttt{{\blue fun} h:}~\tau^{\red 1} \texttt{ -> } \texttt{(} \tau^{\red 1} \texttt{ -> ... -> (} \tau^{{\red 0}} \texttt{ -> ... -> } \tau^{{\red 0}} \texttt{))}$$ $$~$$}
\only<3>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, {\red \theta}, \rho $$ \bigskip
$$ \texttt{\red t may modify the global state}$$ $$~$$ $$~$$}
\only<4>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, {\red \rho} $$\bigskip 
$$ \texttt{\red t may diverge} $$
$$~$$
$$~$$}
\only<5>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
$$\OliveGreen{\texttt{well-typed terms {\red =} terms inlined correctly}}$$
$$~$$
$$~$$}
\only<6>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
$$\OliveGreen{\texttt{well-typed terms {\red -->} terms inlined correctly}}$$
$$~$$
$$~$$}
\only<7>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
$$\OliveGreen{\texttt{well-typed terms {\red <--} terms inlined correctly}}$$
$$~$$
$$~$$}
%\only<6>{
%$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
%$$\OliveGreen{\texttt{well-typed terms {\red -->} terms inlined correctly}}$$
%$$\quad \OliveGreen{\texttt{restrictions typing rules}}$$
%$$~$$}
%\only<7>{
%$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
%$$\OliveGreen{\texttt{well-typed terms {\red -->} terms inlined correctly}}$$
%$$\quad \OliveGreen{\bullet \texttt{restrictions typing rules}}$$
%$$\quad \OliveGreen{\bullet \texttt{proving semantics preservation}}$$}

\end{large}
\end{frame}

\section*{typing of let in examples}
\subsection*{let 0}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em} \vdash t_1 : \phantom{tttttttttttttttttt}
			\quad   \vdash t_2 : \phantom{ttttttttttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em} {\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: \phantom{ttttttttttttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{let 1}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \Rouge{\theta_1}, \Rouge{\rho_1}}  \phantom{ttttttttttt} 
			\quad  \vdash t_2 : \phantom{ttttttttttttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: \phantom{ttttttttttttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{let 2}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \Rouge{\theta_1}, \Rouge{\rho_1}}  \phantom{tttttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: \phantom{tttttttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{let 3a}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}} \phantom{tttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{let 3b}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}, 
				(\theta_1 \bvee \theta_2)} \phantom{tttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{let 3c}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}, 
				(\theta_1 \bvee \theta_2), 
				(\rho_1 \bvee \rho_2)} \phantom{tttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{restriction on typing}
\begin{frame}[fragile]
\frametitle{restriction on typing}
		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{ttttt} {\blue \texttt{\textbf{Cond}}}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}, 
				(\theta_1 \bvee \theta_2), 
				(\rho_1 \bvee \rho_2)} \phantom{tttttttt}}

\bigskip
$$ \textcolor{blue}{\texttt{Cond: } \texttt{(i = 2)} \Rightarrow 
			(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}$$
\end{frame}
\addtocounter{framenumber}{-1}

\section*{liaisons dangereuses}
\begin{frame}[fragile]
\frametitle{les liaisons dangereuses}
\hspace*{-1em}
\begin{small}
\begin{whycode} 
${\red \only<1-2>{\mathcal{P}_1}\only<3-4>{\mathcal{P}_2}}$: 
   let F = ($\only<1-2>{\texttt{\red r:= !r + 1;}}\only<3-4>{\texttt{\red diverge(); }}$ fun (f:int -> int) -> f !r)
   in $\only<1-2>{\texttt{(F id) + (F id)}}\only<3-4>{\texttt{()}}$
   
*?%$\hspace*{8em}\only<2>{{\red \mathcal{P}_{1_{\{r=0\}}} \longrightarrow^{\star} 2_{\{ r=1\}}}}\only<4>{\red \mathcal{P}_{2_{\{r=0\}}} \longrightarrow^{\star} \infty}$
?* 
${\red\only<1-2>{ \mathcal{I}(P_1)}\only<3-4>{\mathcal{I}(P_2)}}:$ 
$\only<1-2>{\qquad \texttt{(r:= !r + 1; !r) + (r:= !r + 1; !r)}}
\only<3-4>{\qquad \texttt{()}}$ 
   
*?%$\hspace*{8em}\only<2>{\mathcal{I}(P_1)_{\{r=0\}} \longrightarrow^{\star} 3_{\{r=2\}}}\only<4>{\mathcal{I}(P_2)_{\{r=0\}} \longrightarrow^{\star} ()_{\{r=0\}}}$      
?*
\end{whycode}
\end{small} \bigskip
\only<1>{
$$ \texttt{\red effect is duplicated} $$}
\only<3>{
$$ \texttt{\red  semantics is not preserved} $$}
\only<2,4>{
$$ \OliveGreen{ \texttt{rejected by type system}} $$}
\end{frame}

%voici un autre exemple que l'on a sur lequel on a evalué notre approche

\section*{Experimental evaluation}
\begin{frame}
\frametitle{Experimental evaluation}
\begin{itemize}
\item apply inlining manually on various 
\begin{itemize}
\item {\red HO functions} (iterators, maps, folders,...)
\item {\red data structures} (arrays, lists, binary trees, ...) \pause \bigskip
\end{itemize}
\item use existing {\red verification tools (Why3, Alt-Ergo)} to compare VCs generated from inlined programs vs loop programs
\end{itemize}
\end{frame}

\section*{sum of list elements} 
\begin{frame}[fragile]
\frametitle{example: sum\_list}
\hspace*{-1em}
\begin{whycode}
 let sum_list (l: int list) : int
 ensures { ${\red \texttt{result =  sum l}}$ }
 = let s = ref 0 in
   List.iter 
     (${\red\texttt{fun before after -> !s = }\sum \texttt{ before}}$) 
     (fun x -> s := !s + x) l; 
   !s     
\end{whycode}
\end{frame}


\section*{iter spec}
\subsection*{Invariant parameter}
\begin{frame}[fragile]
\frametitle{Invariant parameter}
\hspace*{-1em}
%\begin{small}
\begin{whycode}
let iter ($\textcolor{red}{\texttt{inv:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
\end{whycode}\vspace*{-1em}\begin{whygray} 
= let rec loop (${ \texttt{before:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${ \texttt{(Cons x before)}}$ xs
  in loop ${\texttt{Nil}}$ l
\end{whygray}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{before and after}
\begin{frame}[fragile]
\frametitle<1>{Before and after}
\frametitle<2->{Reversed order}
\hspace*{-1em}
%\begin{small}
\begin{whycode}
let iter ($\textcolor{red}{\texttt{inv:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
= let rec loop (${\red \texttt{before:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${\red \texttt{(Cons x before)}}$ xs
  in loop ${\red\texttt{Nil}}$ l
\end{whycode}
%\end{small}

\begin{displaymath}\hspace*{-1.5em}
\begin{array}{lccccl}
\only<2->{{ \{} \texttt{x}_{\red 1} & \texttt{...} & \texttt{x}_{\red k} { \}} & 
{ \{}  \texttt{x}_{\red k+1} & \texttt{...} & \texttt{x}_{\red n} { \}} \\}

\only<2->{
&\stackrel{\texttt{\red before}}{\texttt{<-----------------}} & 
& 
&\stackrel{\texttt{\red after}}{\texttt{---------------->}} & \\
{\{}  \texttt{b}_{\red k} & \texttt{...} & \texttt{b}_{\red 0} { \}}  
&\hspace*{-1em}  {\{} \texttt{a}_{\red 1} & \texttt{...} & \texttt{x}_{\red n-k} { \}}}
\end{array}
\end{displaymath}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{pre and post}
\begin{frame}[fragile]
\frametitle{Precondition and postcondition}
\hspace*{-4em}
\begin{footnotesize}
\begin{whycode}
let iter ($\textcolor{red}{\text{inv:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
requires { ${\red \texttt{inv Nil l}}$ }
ensures  { ${\red \texttt{inv (reverse l) Nil}}$ } 
= ${\gray\texttt{let rec loop (before:int list) (after:int list)}}$
  ${\gray\texttt{requires \{ inv before after \} }}$
  ${\gray\texttt{ensures~ \{ inv ((reverse after) ++ before)) Nil \}}}$  
  ${\gray\texttt{= match after with}}$
     ${\gray\texttt{| Nil~~~~~~ -> ()}}$
     ${\gray\texttt{| Cons x xs -> f x; loop (Cons x before) xs}}$
  ${\gray\texttt{in loop Nil l }}$
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
\frametitle{Loop invariant}
\hspace*{-1em}
\begin{footnotesize}
\begin{whycode}
${\gray\texttt{let iter (inv:int list -> int list -> prop)}}$
${\gray\texttt{(f:int -> unit) (l:int list)}}$
${\gray\texttt{requires \{ inv Nil l \}}}$
${\gray\texttt{ensures~ \{ inv (reverse l) Nil\}}}$    
= let rec loop $(\textcolor{red}{\text{before:int list}})$ (after: int list) 
  requires $\texttt{\{ inv {\red before after} \}}$
  ensures  $\texttt{\{ inv {\red((reverse after) ++ before) Nil }}\}$  
  ${\gray\texttt{= match after with}}$
     ${\gray\texttt{| Nil~~~~~~ -> ()}}$
     ${\gray\texttt{| Cons x xs -> f x; loop (Cons x before) xs}}$
  ${\gray\texttt{in loop Nil l }}$
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{Ghost code}
\begin{frame}[fragile]
\frametitle{Regular code}
\hspace*{-1em}
\begin{whycode}
let iter (${\texttt{{\red inv}:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
= let rec loop (${\texttt{{\red before}:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${\red \texttt{(Cons x before)}}$ xs
  in loop ${\red\texttt{Nil}}$ l
\end{whycode}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
\frametitle{{\red Ghost code}}
\hspace*{-1em}
\begin{whycode}
let iter (${\texttt{{\red ghost inv}:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
= let rec loop (${ \texttt{{\red ghost before}:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${\red \texttt{(Cons x before)}}$ xs
  in loop ${\red\texttt{Nil}}$ l
\end{whycode}
\end{frame}
\addtocounter{framenumber}{-1}


\section*{Ghost Code}

%\begin{frame}
% \begin{itemize}
% 	\item[] $${\large \red \texttt{Ghost Code}}$$
% 	\begin{center}
% 	\includegraphics[scale=0.2]{Ghostbusters2}
% 	\end{center} 
% \end{itemize}
%\end{frame}
%\addtocounter{framenumber}{-1}

\subsection*{ghost properties informally}
% un pgm avec du code ghost :
%  - pour le prouver, je prends *tout* le code, sans distinction
%  - pour l'exécuter, j'oublie le code ghost

\begin{frame}
\frametitle{{Idea}}
	may be inserted for the purpose of specification and/or proof \\[1em]
	\pause	
	\begin{itemize}
	\item[\red $\bullet$] regular code does not see ghost data
	\item[\red $\bullet$] ghost code may read regular data (but cannot modify it)\\[1em]
	\end{itemize}
in particular, ghost code may be removed without observable modification
\end{frame}


\subsection*{Ghost formalisation}

% 4. formalisation de Ghost-ML
%    syntaxe, sémantique, typage avec effets (montrer le jugement),
%      bien expliquer qu'il y a des choix à faire (mais aussi des*)
%      obligations), l'opération erasure et la preuve

\begin{frame}
\frametitle{Our second contribution}
\begin{itemize}
\item formalize {\red Ghost-ML}: syntax, semantics \pause
\item extend type system with {\red ghost effects} \pause
\item prove ghost code {\red non-interference} with regular code \pause
\item define ghost {\red erasure} and prove {\red semantics preservation}
\end{itemize}
\end{frame}

%\begin{frame}
%\frametitle{ghost code non-interference}
%type system with effects 
%$$\Gamma \vdash_{gh} t: \tau^{i}, (\theta, \rho, {\red \beta}) $$
%
%\bigskip\pause
%typing invariant 
%$$\Gamma \vdash_{gh} t : \tau, (\theta, \rho, \gbr) 
% ~~ \Rightarrow ~~
%\models (\gbr = \gbtr) \Rightarrow (\theta = \bth \bwedge \rho = \brh) $$
%\end{frame}
%
%
%\begin{frame}
%\frametitle{ghost code propagation}
%\begin{footnotesize}	
%\begin{displaymath}
%\begin{array}{l}
%\dfrac
%	{
%		\ghosttyping
%			{t_1}
%			{\tau_1}
%			{\theta_1}
%			{\rho_1}
%			{\gbra{1}^{\rouge{'}}}
%			{} \qquad
%		\ghosttyping
%			{t_2}
%			{\tau_2}
%			{\theta_2}
%			{\rho_2}
%			{\gbra{2}}
%			{  \quad \models \gba{1} \Rightarrow \gba{1}^{'}}
%	}
%	{\ghosttyping
%		{let~x^{\gbra{1}}_{\tau_1} = t_1~in~t_2}
%		{\tau_2}
%		{\theta_1 \bvee \theta_2}
%		{\rho_1 \bvee \rho_2}
%		{\gbra{2} \bvee (\gbran{1} \bwedge \gbra{1}^{\rouge{'}})}
%		{}}
%	{}
%	\end{array}	
%\end{displaymath}
%\end{footnotesize}	
%\end{frame}

\section*{Future Work}
\begin{frame}
\frametitle{Future work}
\begin{itemize}
\item continue {\red experimental evaluation}  \pause
\begin{itemize} 
	\item make a {quantitative study} of HO programs used in practice \pause
	\item { implement} a prototype    \pause \bigskip
\end{itemize} 
\item submit a {\red research paper} \pause
\begin{itemize}
\item on inlining (PEPM 2014) \pause
\item on ghost code (PLPV 2014)
\end{itemize}
\end{itemize}
\end{frame}

%\begin{frame}[fragile]
%\frametitle{\red{ghost code}}
%\begin{footnotesize}
%\begin{whycode}
%let iter ($\textcolor{red}{\text{ghost inv:int list -> int list -> prop}}$) (f:int -> unit) (l: int list)
%requires { ${ \texttt{inv Nil l }}$ }
%ensures  { ${ \texttt{inv (reverse l) Nil}}$ }
%= let rec loop $(\textcolor{red}{\text{ghost before:int list}})$ (after: int list) 
%  requires $\texttt{\{ inv { before after} \}}$
%  ensures  $\texttt{\{ inv {((reverse after) ++ before)} }\}$     
%  = match after with 
%     | Nil       -> ()
%     | Cons x xs -> f x; loop ($\textcolor{red}{\text{Cons x before}}$) xs 
%  in loop $\texttt{\red Nil}$ l 
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%\begin{frame}[fragile]
%\frametitle{regular code}
%\hspace*{-1em}
%\begin{footnotesize}
%\begin{whycode}
%${\gray\texttt{let iter (inv:int list -> int list -> prop)}} ~
%{\gray\texttt{(f:int -> unit) (l:int list)}}$
%${\gray\texttt{requires \{ inv Nil l \}}}$
%${\gray\texttt{ensures~ \{ inv (reverse l) Nil \}}}$    
%= ${\gray\texttt{let rec loop (before:int list) (after:int list)}}$
%  ${\gray\texttt{requires \{ inv before after \} }}$
%  ${\gray\texttt{ensures~ \{ inv ((reverse after) ++ before) Nil \}}}$
%  = match after with 
%     | Nil       -> ()
%     | Cons x xs -> f x; loop ($\textcolor{red}{\text{Cons x before}}$) xs 
%  in loop $\texttt{\red Nil}$ l 
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}

%\begin{frame}
%\frametitle{Related work}
%{\red last 40 years}
%	\begin{itemize}
%		\item[] formal verification of imperative programs 
%		\item[] emergence of efficient ATPs (Alt-Ergo, Z3, CVC4, ...)
%		\item[] first-order verification plateforms (Why3, Boogie, ...)
%	\end{itemize}\vspace*{1em} \pause
%{\red more recently}
%	\begin{itemize}
%		\item[] higher-order functional programs (Coq, PVS, Pangolin,...)
%		\item[] higher-order {\red stateful} programs (Who, F$^\star$, HTT, CFML, ...)
%	\end{itemize}
%\pause
%\bigskip
%{\red challenge}: proof automation
%\end{frame}

%\begin{frame}\frametitle{To summarize, in our work}\vspace*{-4em}
%\begin{itemize}
%	\item[\blue$-$]  we described of the inlining by the set of rewriting rules; \\[1em]
%	\item[\blue$-$]  we proved that the procedure described by these rules \\[0.5em]
%	
%	\begin{itemize}
%		\item[$\blacktriangleright$]
%		{\normalsize always {\red terminates } giving a first-order output term} \\[0.3em]
%		\item[$\blacktriangleright$]  
%		{\normalsize {\red preserves} the semantics of the initial term} \\[1em]
%	\end{itemize}
%	\item[\blue $-$] we formalized the notion of {\red ghost code}
%\end{itemize}
%\end{frame}

	
% In this work (1) formalize domain 
% prove soundness 

% Formaliziation : typing
% Correctness : equivalence
% Example
\end{document}

\begin{frame}[fragile]
%\frametitle{example: let in}
%\begin{small}
%		\infrule[] 
%			{\vspace*{0.5em}\Gamma \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \quad 
%			\quad \Gamma, x:\tau^i  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \quad {\footnotesize \textcolor{blue}{(i = 2) \Rightarrow 
%			(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}}} 
%			{\vspace*{-1em}\hspace*{-2.1em}\Gamma \vdash \text{ let } x = t_1 \text{ in } t_2 
%				: {\red \tau^{j}, 
%				(\theta_1 \bvee \theta_2), 
%				(\rho_1 \bvee \rho_2)} \phantom{ttttttttttt}}
%	\end{small}	
%	\begin{small}
%\begin{whycode} 
%${\red \only<1>{\mathcal{P}_1}\only<2->{\mathcal{P}_2}}$: 
%   let F = 
%      ($\only<1>{\texttt{\red r:= !r + 1;}}\only<2->{\texttt{\red diverge(); }}$ fun (f:int -> int) -> f !r)
%   in $\only<1>{\texttt{(F id) + (F id)}}\only<2->{\texttt{()}}$
%
%${\red\only<1>{ \mathcal{I}(P_1)}\only<2->{\mathcal{I}(P_2)}}: \only<1>{\texttt{(r:= !r + 1; !r) + (r:= !r + 1; !r)}}
%\only<2->{\texttt{()}}$
%\end{whycode}
%\end{small}
%\end{frame}
%\addtocounter{framenumber}{-1}
%\begin{itemize}	
%	\item[-] {\red } ordered simple types 
%	\begin{footnotesize} 
%		\item[] \qquad$\tau^{\red 0}:\{\texttt{ bool, int list,... }\}$
%		\item[] \qquad$\tau^{\red 1}:\{\texttt{ int -> bool, int -> (int -> bool), ... }\}$
%		\item[] \qquad$\tau^{\red 2}:\{\texttt{ (int -> int) -> bool, ... }\}$\\[1em]
%	\end{footnotesize}
%	\end{itemize}
%	\item[-] a type system {\red with effects}:\\[0.5em]
%		\begin{itemize}

%\begin{frame}[fragile]
%\frametitle{Experimental language}
%a fragment of ML with
%\begin{itemize}
%	\item[-] built-in data (int, int list, ...)
%	\item[-] zero-order global references 
%	\item[-] first-order recursion
%	\item[-] second-order closures 
%	\item[-] {\red second-order} programs with types \\[0.5em]
%		\begin{itemize}	
%		\begin{footnotesize} 
%			\item[] \qquad$\tau^{\red 0}:\{\texttt{ int, bool,... }\}$
%			\item[] \qquad$\tau^{\red 1}:\{\texttt{ int -> bool, int -> (int -> bool), ... }\}$
%			\item[] \qquad$\tau^{\red 2}:\{\texttt{ (int -> int) -> bool, ... }\}$\\[1em]
%		\end{footnotesize}
%		\end{itemize}
%		 \pause
%	\item[-] a type system {\red with effects}:\\[0.5em]
%		\begin{itemize}
%			\item[] \qquad $\Gamma \vdash t: \tau^{i}, {\red \theta, \rho} $
%		\end{itemize}
%\end{itemize}
%\end{frame}

%\begin{frame}[fragile]
%\frametitle{\OliveGreen{instantiate inv}}
%\vspace*{0em}
%\begin{footnotesize}
%\begin{whycode}
%let sum_iter (a: int array) 
%ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
%= let s = ref 0 in 
%  let iter (f:int -> unit) (b: int array)
%  requires { ${\red \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
%  ensures  { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}})$ } 
%  = let rec aux (i: int)
%    requires { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{(length b)}$ }
%    ensures  { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}}$ }
%    = if i < Array.length b
%      then (f b.(i) ; aux (i + 1)) 
%    in aux 0
%  in iter (fun x -> s := !s + x) a; 
%  !s
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%
%\subsubsection*{Instantiate function f}
%\begin{frame}[fragile]
%\frametitle{\OliveGreen{instantiate f}}
%\vspace*{0em}
%\begin{footnotesize}
%\begin{whycode}
%let sum_iter (a: int array) 
%ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
%= let s = ref 0 in 
%  let iter ${\red \texttt{(f:int -> unit)}}$ (b: int array)
%  requires { ${ \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
%  ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}})$ } 
%  = let rec aux (i: int)
%    requires { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{(length b)}$ }
%    ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}}$ }
%    = if i < Array.length b
%      then (${\red\texttt{f}}$ b.(i) ; aux (i + 1)) 
%    in aux 0
%  in iter ${\red\texttt{(fun x -> s := !s + x)}}$ a; 
%  !s
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%
%\begin{frame}[fragile]
%\frametitle{\OliveGreen{instantiate f}}
%\vspace*{0em}
%\begin{footnotesize}
%\begin{whycode}
%let sum_iter (a: int array) 
%ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
%= let s = ref 0 in 
%  let iter (b: int array)
%  requires { ${ \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
%  ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}})$ } 
%  = let rec aux (i: int)
%    requires { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{(length b)}$ }
%    ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}}$ }
%    = if i < Array.length b
%      then (${\red\texttt{s := !s + b.(i)}}$ ; aux (i + 1)) 
%    in aux 0
%  in iter a; 
%  !s
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%
%
%%\section*{Inlining}
%%\begin{frame}
%% \begin{itemize}
%% 	\item[] $${\large \red \texttt{Inlining}}$$
%% 	\begin{center}
%%% 	\includegraphics[scale=0.31]{GhostBusters}
%% 	\end{center} 
%% \end{itemize}
%%\end{frame}
%%\addtocounter{framenumber}{-1}
%



%\begin{frame}[fragile]
%\frametitle<1>
%{sum example with {loop}}
%\frametitle<2>
%{\quad program specification}
%\frametitle<3>
%{\quad loop invariant}
%\frametitle<4>
%{precondition}
%\frametitle<5>
%{array bound check}
%\frametitle<6>
%{preservation}
%\frametitle<7>
%{postcondition}
%\vspace*{-3em}
%\begin{displaymath} 	
%\begin{array}{@{\hspace*{0em}}l@{\hspace*{1.5em}}ll@{\hspace*{1em}}l}
%
%\only<-3>{\vspace*{2em}}
%\only<4>{
% \rond{vc1}	 
% &\textcolor{red}{\emptyset}
% &\textcolor{red}{\vdash}
% &\textcolor{red}{(0 \leq 0 \bwedge 0 \leq n) \bwedge 0 = \sum_{~0\leq j < 0} a[j] \phantom{ phantom of the opera is here right now}}}
%
%\only<5>{
%	\rond{vc2}
%	&\textcolor{red}{\mathcal{I} \bwedge i < n}
%	&\textcolor{red}{ \vdash} 
%	&\textcolor{red}{ 0 \leq i < n} \phantom{phantom of the opera is here right now}}
%
%
%\only<6>{
%	\rond{vc3}
%	&\textcolor{red}{\mathcal{I} \bwedge i < n}
%	&\textcolor{red}{\vdash} 
%	&\textcolor{red}{s + a[i] = \sum_{~0 \leq j < i+1} a[j] \bwedge (0 \leq (i+1) \leq n)   \phantom{phantom of the opera is here right now}}}
%
%
%\only<7>{
%	\rond{vc4}
%	&\textcolor{red}{ \mathcal{I} \bwedge i \geq n} 
%	&\textcolor{red}{ \vdash}
%	&\textcolor{red}{ s = \sum_{~0 \leq j < n} a[j] \phantom{phantom of the opera is here right now}}}
%
%\end{array}
%\end{displaymath}
%\vspace*{-2em}
%\begin{normalsize}
%	\begin{whycode}  
%let sum_while (a: int array) *?\only<2->{\\ 
%	{\blue ensures} $\{\texttt{ {\blue result} = }{\red~\sum_{~0 \leq j < \text{a.length}} a[j]}~\}$}?* 
%= let s = ref 0 in
%  let n = Array.length a in
%  let i = ref 0 in
%  *?\only<4>{\hspace*{-2em}\crond{vc1}{red}~}\only<5->{\hspace*{-2em}\crond{vc1}{gray}~}?*while !i < n do *?
%  
%  \only<3->{\\    
%  ${ \blue \hspace*{1em} \texttt{invariant}}  
%   ~\{{\red~\mathcal{I}: \texttt{!s = } \sum_{0\leq j < !i} a[j] \bwedge 0 \leq !i \leq \texttt{n}}~\}$} 
%  ?*
%	 	*?
%	 	\only<5>{\hspace*{-2em}\crond{vc2}{red}~}
%	 	\only<4,6->{\hspace*{-2em}\crond{vc2}{gray}~}?*  s := !s + a.(!i);  
%    i := !i + 1
% *?\only<6>{\hspace*{-1.5em}\crond{vc3}{red}\hspace*{-0.0em}}
% 	\only<4-5,7->{\hspace*{-1.5em}\crond{vc3}{gray}\hspace*{-0.0em}}?* done;
% *?\only<4-6>{\hspace*{-1.5em}\crond{vc4}{gray}}\only<7->{\hspace*{-1.5em}\crond{vc4}{red}}?* !s 
%\end{whycode}\vspace*{-0.5em}
%\end{normalsize}
%\end{frame}

%\subsubsection*{Conclusion}
%\begin{frame}
%\frametitle{automated proof}
%\begin{itemize}
%\item All verification conditions {\tiny \rond{vc1} - \rond{vc4}} are first-order formulas.
%\item Automated theorem provers easily prove them. 
%%\item<4-> {\color{red} Can we generate first-order VCs from that specification ?}
%\end{itemize}
%\bigskip\pause
%\begin{center}
% {\color{red} Can we prove \texttt{sum\_iter} in a similar way ?}
%\end{center}
%\end{frame}


%\documentclass{beamer}
%
%\usepackage[utf8]{inputenc}
%\usepackage[french]{babel}
%
%\begin{document}
%
%\title{Deductive Verification of Stateful Second-Order Programs}
%\author{Léon Gondelman}
%\date{M2 internship \\ \today}
%
%\begin{frame}
%  \maketitle
%\end{frame}

% Local Variables:
% compile-command: "rubber -d slides"
% ispell-local-dictionary: "francais"
% End:



