\documentclass[xcolor=dvipsnames]{beamer}
\usepackage{etex}
\usetheme{Pittsburgh}
\usepackage{lmodern} \linespread{1.1}
\usepackage[latin1]{inputenc}
\usepackage[sc]{mathpazo} \linespread{1.1}
\usepackage{changepage}
 \usepackage{float}
\usepackage{setspace}
\usepackage{pstricks,pstricks-add,pst-math,pst-xkey}
\usepackage{multicol}
\usepackage{bcprules, proof}
\usepackage{multirow}
\usepackage{array}
%\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{mathdots}
\usepackage[usenames,dvipsnames]{}
\usepackage{amssymb,amsfonts,amsthm,amsmath}
\RequirePackage{listings}
\RequirePackage{amssymb}
\usepackage{tikz}
\usepackage{tabularx}
\lstset{
	xleftmargin=\parindent,
  basicstyle={\ttfamily},
%  framesep=2pt,
%  frame=single,
  keywordstyle={\color{blue}},
  stringstyle=\itshape,
  commentstyle=\itshape,
  columns=[l]fullflexible,
  showstringspaces=false,
  mathescape=true
}

%\lstset{basicstyle={\ttfamily}}
\lstdefinelanguage{whycode}{
morekeywords=[1]{},%
string=[b]",%
showstringspaces=false,%
stringstyle=\itshape,%
commentstyle= \color{gray}\small\texttt, %
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true}
\lstset{language=whycode,
emph={namespace,result,predicate,module,fun,while,done,function,inductive,type,use,clone,%
import,export,theory,end,in,match,with,do,let,ghost,ensures,requires,ensures,invariant, rec,variant,then,if,else,%
goal,axiom,lemma,forall, induction},
emphstyle=\color{blue}}

\lstset{language=whycode}
\lstnewenvironment{whycode}{\lstset{language=whycode}}{}

\label{whygray}
\lstdefinelanguage{whygray}{
morekeywords=[1]{},%
string=[b]",%
showstringspaces=false,%
stringstyle=\itshape,%
commentstyle= \color{gray}\small\texttt, %
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true}

\lstnewenvironment{whygray}{
\lstset{
language=whygray, 
stringstyle=\color{gray},
emphstyle=\color{gray}}\gray}{\gray}


\newcommand{\OliveGreen}[1]{\textcolor{OliveGreen}{#1}}
\newcommand{\Rouge}[1]{\textcolor{red}{#1}}
\newcommand{\Noir}[1]{\textcolor{black}{#1}}


\let\why\lstinline
%\newcommand{\blue[1]}{\color{blue}}
\let\emph\alert
\beamertemplatenavigationsymbolsempty
\newcommand{\HRule}{\rule{\linewidth}{0.1mm}}

\newenvironment{aquote}[1]
  {\savebox\mybox{#1}\begin{quote}}
  {\signed{\usebox\mybox}\end{quote}}

\addtobeamertemplate{footline}{\hfill\insertframenumber/\inserttotalframenumber}


\newcommand{\rouge}[1]{\textcolor{red}{#1}}
\newcommand{\bwedge}{\boldsymbol{~\wedge~}}
\newcommand{\bvee}{\boldsymbol{~\vee~}}
\newcommand{\brarr}{\boldsymbol{~\Rightarrow~}}
\setbeamertemplate{frametitle}{\vspace*{1em}\hfill\insertframetitle} 
\addtocounter{framenumber}{-1}

\newcommand{\gb}{\beta}
\newcommand{\gba}[1]{\beta_{#1}}
\newcommand{\gbb}{\bot_\beta}
\newcommand{\gbt}{\top_\beta}

\newcommand{\gbr}{\textcolor{red}{\gb}}
\newcommand{\gbra}[1]{\textcolor{red}{\gba{#1}}}
\newcommand{\gbbr}{\textcolor{red}{\gbb}}
\newcommand{\gbtr}{\textcolor{red}{\gbt}}
\newcommand{\gbran}[1]{\textcolor{red}{\neg\gba{#1}}}
\newcommand{\bth}{\bot_\theta}
\newcommand{\brh}{\bot_\rho}  
\newcommand{\tth}{\top_\theta}
\newcommand{\trh}{\top_\rho}   

\newcommand{\ghosttyping}[6]{\vdash_{gh}~#1~:~#2,~(#3,~#4,~\rouge{#5})~\textcolor{blue}{\boldsymbol{#6}}}

\newcommand{\crond}[2]{
\tikz \node[draw,circle,scale=0.21,fill=#2]{\black \Huge  \textbf{#1}};}
\newcommand{\rond}[1]{
\tikz \node[draw,circle,scale=0.21,fill=red]{\black \Huge  \textbf{#1}};}

\definecolor{cblue}{RGB}{90,110,160}

\makeatletter
\def\hlinewd#1{%
\noalign{\ifnum0=`}\fi\hrule \@height #1 %
\futurelet\reserved@a\@xhline}
\makeatother
\begin{document}
\section*{Title}
\begin{frame}
\begin{center}


\textsc{\blue{\Large Deductive Verification of \\[0.2cm] 
Stateful Second-Order Programs }}\\
%\HRule
 \textsc{ \scriptsize master's degree second year internship defense}\\[1cm]
L\'eon \textsc{Gondelman}\\[1.5cm]
\end{center}\bigskip

\begin{normalsize}
\begin{center} 
\hspace*{-9em}{\blue Supervisor}: Jean-Christophe \textsc{Filli\^atre} \\
\hspace*{1em}{\blue Laboratoire}: LRI / Inria Saclay (Equipe Toccata), Orsay, France \\
\end{center}
\end{normalsize}
\vfill\begin{center}
\today
\end{center} 





%\includegraphics[scale=0.15]{image_title3}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% 1. contexte, problème, exemple introductif (array_iter)
% sum_while et sum_iter en parallèle

\section*{Idea}
\begin{frame}{Idea}
\begin{quotation}
 ''The most important property of a program is whether it accomplishes the intention of its user.''\\
\hfill{\blue{C.A.R. Hoare}}
\end{quotation}
\bigskip
\end{frame}

\section*{Approach}
\begin{frame}
\frametitle{Approach}
\includegraphics{definition_en.mps}
\bigskip\pause
  \begin{enumerate}
  \item {\red specify} a program 
  \item {\red generate} verification conditions 
  \item {\red discharge} them, using
    \begin{itemize}
    \item automated theorems provers
    \item interactive proof assistants
    \end{itemize}
  \end{enumerate}
\end{frame}

\section*{Related work}
\begin{frame}
\frametitle<1-6>{Related work}
\frametitle<7>{Today}
\begin{small}
\begin{center}\hspace*{-1.5em}
\begin{tabular}{|l|c|c|}
\hline
 {\red Programs}\phantom{ttt} & \phantom{ttttttttttt} {imperative} \phantom{ttttttttt}	& 
 
 \phantom{ttttttttt} {functional} \phantom{tttttttttt}	 \\  \hlinewd{1.2pt}  
{\red Specification} 
	& \only<2->{\phantom{ttt} first-order logic \phantom{ttt}} 
	& \only<2->{\phantom{ttt} higher-order logic \phantom{ttt} } \\ \hline
{\red VCs Generation} 
	& \only<3->{ Frama-C, Boogie, Why3, ...  }
	& \only<3->{  Pangolin, F$^{\star}$, Who, ...  } \\ \hline
{\red Proof}
  & \only<4->{{ automated theorem provers}}
		& \only<5->{{ interactive proof assistants}} \\ 
	& \only<4->{{\footnotesize Nqthm, Alt-Ergo, ...}} 
		&\only<5->{{\footnotesize Coq, Isabelle, ...}} \\ \hline
\end{tabular}
\end{center}
\end{small}\bigskip
\only<1-5>{
\begin{flushleft}~\end{flushleft}}
\only<6>{
\hspace*{-2em}
\texttt{{\red Scientific challenge}:~automated proof of HO programs}
}
\only<7>{
\hspace*{-2em}
{\texttt{{\blue This work}:~automated proof of {\blue SO stateful} programs}} 
}
\end{frame}

\section*{Two sum programs}
\subsection*{code}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-0.3cm}{1.0cm}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do
    s := !s + a.(!i);
    i := !i + 1
  done;
  !s
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ref 0 in
  Array.iter 
    (fun x -> s := !s + x) a;
  !s
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{imperativeness}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-0.3cm}{1.0cm}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ${\red \texttt{ref 0}}$ in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do
    ${\red \texttt{s := !s + a.(!i)}}$;
    i := !i + 1
  done;
  ${\red \texttt{!s}}$
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ${\red \texttt{ref 0}}$ in
  Array.iter 
    (fun x -> ${\red \texttt{s := !s + x}}$) a;
   ${\red \texttt{!s}}$
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{while vs imperative}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-0.3cm}{1.0cm}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  ${\red \texttt{while}}$ !i < n ${\red \texttt{do}}$
    s := !s + a.(!i);
    i := !i + 1
  ${\red \texttt{done}}$;
  !s
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ref 0 in
  ${\red \texttt{Array.iter}}$ 
    ${\red \texttt{(fun x -> s := !s + x)}}$ a;
  !s
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{same spec}
\begin{frame}[fragile]\frametitle{Computing the sum of array elements}
\begin{adjustwidth}{-1em}{2em}
\begin{small}
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode}  
let sum_while (a: int array)
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do
    s := !s + a.(!i);
    i := !i + 1
  done;
  !s
\end{whycode}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{whycode} 
let sum_iter (a: int array)
= let s = ref 0 in
  Array.iter 
    (fun x -> s := !s + x) a;
  !s
\end{whycode}	
\end{minipage}
\end{small}
\end{adjustwidth}
\only<1>{$$\textcolor{blue}{\texttt{programs are different}}$$
$$~$$}
\only<2>{$${\blue \texttt{but their meaning is the same:}}$$
$${ \red \texttt{ result =} \hspace*{-1em}\sum_{~0 \leq j < \text{a.length}}\hspace*{-1em} a[j]~}$$}
\end{frame}



\section*{Verifying sum_while}
\begin{frame}[fragile]
%\frametitle<1>
%{Proving Sum\_while}
\frametitle<1-2>
{\quad Program specification}
\frametitle<3>
{\quad Loop invariant}
\frametitle<4>
{\quad {First-Order VCs}}
\frametitle<5->
{\quad {Automated proof}}
\vspace*{-1em}
\begin{normalsize}
	\begin{whycode}  
let sum_while (a: int array) *?\only<1->{\\ 
	{\blue ensures} \{ \texttt{{\blue result} = {\red sum 0 (length a) a }}\}}?* 
= let s = ref 0 in
  let n = Array.length a in
  let i = ref 0 in
  while !i < n do *?
    \only<3->{\\    
  ${ \blue \hspace*{1em} \texttt{invariant}}  
   ~\{{\red~ \texttt{!s = sum 0 !i a} \bwedge \texttt{0} \leq \texttt{!i} \leq \texttt{n}}~\}$} 
  ?*
    s := !s + a.(!i);  
    i := !i + 1
  done;
  !s 
\end{whycode}\vspace*{-0.5em}
\end{normalsize}
\begin{center}
\only<2-3>{\texttt{{\red sum i j a} : axiomatic FO logical symbol}}
\only<4>{\OliveGreen{we used only first-order formulae}}
\only<5>{\OliveGreen{generated VCs can be easily proved by ATPs}}
\end{center}
\end{frame}


\section*{Verifying Sum_iter}
\begin{frame}[fragile]
\frametitle<1>{Program specification}
\frametitle<2>{Program modularity}
\frametitle<3>{Specification modularity}
\frametitle<4>{One known solution}
\frametitle<5>{Proof modularity}
\frametitle<6-8>{Difficulties of this solution}
\frametitle<9>{Our intuition}
\frametitle<10>{Our approach}
\frametitle<11>{Invariant formula}
\begin{whycode}
 let sum_iter (a: int array) *?\only<1->{\\
	{\blue \texttt{ ensures }}\{\texttt{ {\blue result} =} 
	{\red \texttt{ sum 0 (length a) a }}\}}?* 
 = let s = ref 0 in
   Array.iter*?
   \only<11>{\\\hspace*{3.5em}
   {\red\texttt{(fun i -> !s = sum 0 i a)}}\\}?* 
       (fun x ->  s := !s + x) a; 
   !s 
\end{whycode}
\begin{flushleft}
\only<1-8>{\texttt{{\blue program is modular}}}
\only<1>{\white \texttt{: we need to specify { Array.iter}}}
\only<2-8>{\texttt{: we need to specify {Array.iter}}\\}
\only<3-8>{\noindent \texttt{{\blue specification is modular}}}
\only<3>{\white \texttt{: we can to prove {Array.iter} too}}
\only<4-8>{\texttt{: we can prove {\red Array.iter}}\\}
\only<5-8>{\texttt{{\blue modular proof}}:}
\only<5>{\white\texttt{: Array.iter { body} is { second-order} program}}
\only<6>{\texttt{ Array.iter is {\red second-order} program}}
\only<7>{\texttt{ \quad ~{\red argument f}  a {\red stateful} function}}
\only<8>{\texttt{ \quad {\red may be difficult to automatize}}\\}
\end{flushleft}
\begin{center}
\vspace*{-2em}
\only<9>{\texttt{\blue the proof of \texttt{sum\_iter} and \texttt{sum\_iter} should be similar}}
\end{center}

\only<10>{\vspace*{-4em}\hrulefill
\begin{displaymath}
\begin{array}{@{\hspace*{-0.5em}}llllllll}
  \begin{minipage}{0.2\textwidth}
  {\texttt{{\red SO} program}}\vspace*{-0.5em} \\
 	\hspace*{2em}+\vspace*{-0.5em}\\ 
	{\hspace*{0.5em}\texttt{{\blue FO} spec}}
  \end{minipage} & 
	\stackrel{\texttt{\normalsize \red inlining}}{\texttt{--------->}} 
& 	  \begin{minipage}{0.2\textwidth}
  {\texttt{\color{cblue}{FO} \gray program}}\vspace*{-0.5em} \\
 	\hspace*{2em}\color{cblue}{+}\vspace*{-0.5em}\\ 
	{\hspace*{0.5em}\texttt{\color{cblue}{FO} \gray spec}}
  \end{minipage}
& \stackrel{\texttt{\normalsize \gray VCs generator}}{{\gray \texttt{---------->}}}  & \texttt{\color{cblue}{FO} \gray VCs} 
\end{array}
\end{displaymath}
\hrulefill}
\end{frame}


\section*{Verifying Iterator}
\begin{frame}[fragile]
\frametitle<1>{Iterator specification}
\frametitle<2>{Additional parameter}
\frametitle<3>{Loop initial and final states}
\frametitle<4>{Loop iteration}
\frametitle<5-6>{Pros and cons}
\frametitle<7>{Solution}
\begin{whycode}  
let iter *?\only<2->{{\red \texttt{(inv:int -> prop) }}}?*(f:int -> unit) (b: int array) *?\only<3->{\\ 
\texttt{\blue requires }\{{\red \texttt{ inv 0 }}\} \\
\texttt{\blue ensures~  }\{{\red \texttt{ inv (length b) }}\}}?* 
let n = Array.length b in
= let rec aux (i: int) *?\only<4->{\\
\texttt{~~\blue requires }\{{\red \texttt{ inv i}$\bwedge \texttt{0} \leq \texttt{i} \leq \texttt{n}$}        \} \\
\texttt{~~\blue ensures~   }\{{\red \texttt{ inv n }}\}}?*  
  = if i < n 
    then (f b.(i) ; aux (i + 1)) 
  in aux 0
\end{whycode} 
\bigskip
\only<5>{
$$ \fbox{\texttt{{\blue pros}: specification above is {\blue modular}}} $$}
\only<6>{
$$ \fbox{\texttt{{\red cons}: specification above is {\red partial}}} $$}
\only<7>{
\hspace*{3.5em}
\fbox{
\begin{minipage}[C]{0.7\textwidth}
\begin{center}
\texttt{\OliveGreen{inline} the definition of iterator}\\
\texttt{\OliveGreen{instantiate} the invariant formula}
\end{center}
\end{minipage}}}
\end{frame}


\section*{Inlining Sum_iter}
\subsection*{Source code}
\begin{frame}[fragile]
%\frametitle{\OliveGreen{inline definition of iterator}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode} 
module Array 
... 
   let iter (inv:int -> prop) (f:int -> unit) (b: int array)
   requires { inv 0 } 
   ensures  { inv (length b) } 
   = let n = Array.length n in
     let rec aux (i: int)
     requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
     ensures  { inv n }
     = if i < n
       then (f b.(i) ; aux (i + 1)) 
     in aux 0
...
end

let sum_iter (a: int array) 
ensures { result = sum 0 (length a) a }
= let s = ref 0 in
  Array.iter 
    (fun i -> !s = sum 0 i a) (fun x -> s := !s + x) a; 
  !s
\end{whycode} 
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{Inlining iter code}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Inline iter}}
\vspace*{0em}
\begin{footnotesize}
\begin{whygray}
let sum_iter (a: int array) 
ensures { result = sum 0 (length a) a }
= let s = ref 0 in 
\end{whygray}\vspace*{-1.15em} 
\begin{whycode}
  let iter (inv:int -> prop) (f:int -> unit) (b: int array)
  requires { inv 0 } 
  ensures  { inv (length b) } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
    ensures  { inv n }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0 \end{whycode} \vspace*{-1.15em} 
 \begin{whygray}
  in iter (fun i -> !s = sum 0 i a) (fun x -> s := !s + x) a; 
  !s
\end{whygray}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{instantiate invariant 0}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter ${\red \texttt{(inv:int -> prop)}}$ (f:int -> unit) (b: int array)
  requires { inv 0 } 
  ensures  { inv (length b) } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { inv i$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
    ensures  { inv n }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0
  in iter ${\red \texttt{(fun i -> !s = sum 0 i a)}}$ (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{instantiate invariant 1}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${\red \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${\red \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { !s = sum 0 i a$\bwedge 0 \leq \texttt{i} \leq \texttt{n}$ }
    ensures  { !s = sum 0 n a }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0
  in iter (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{instantiate invariant 2}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate inv}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter (f:int -> unit) (b: int array)
  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { ${\red\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
    ensures  { ${\red\texttt{!s = sum 0 n a}}$ }
    = if i < n
      then (f b.(i) ; aux (i + 1)) 
    in aux 0
  in iter (fun x -> s := !s + x) a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}



\subsection*{Instantiate f 1}
\begin{frame}[fragile]
\frametitle{\OliveGreen{Instantiate f}}
\vspace*{0em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter ${\red\texttt{(f:int -> unit)}}$ (b: int array)
  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { ${\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
    ensures  { ${\texttt{!s = sum 0 n a}}$ }
    = if i < n
      then (${\red\texttt{f}}$ b.(i) ; aux (i + 1)) 
    in aux 0
  in iter ${\red\texttt{(fun x -> s := !s + x)}}$ a; 
  !s
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


% TODO : conclusion we get FO program + FO spec -> (OK for provers) 
%\subsection*{Instantiate f 2}
%\begin{frame}[fragile]
%\frametitle{\OliveGreen{Instantiate f}}
%\vspace*{0em}
%\begin{footnotesize}
%\begin{whycode}
%let sum_iter (a: int array) 
%ensures { $\texttt{result = sum 0 (length a) a }$}
%= let s = ref 0 in 
%  let iter (b: int array)
%  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
%  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
%  = let n = Array.length b in
%    let rec aux (i: int)
%    requires { ${\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
%    ensures  { ${\texttt{!s = sum 0 n a}}$ }
%    = if i < n
%      then (${\red\texttt{s := !s + b.(i)}}$ ; aux (i + 1)) 
%    in aux 0
%  in iter a; 
%  !s
%\end{whycode}
%\end{footnotesize}
%\end{frame}

% TODO : conclusion we get FO program + FO spec -> (OK for provers) 
\subsection*{Proving the result}
\begin{frame}[fragile]
\frametitle<1-4>{\OliveGreen{Instantiate f}}
\vspace*{-2em}
\begin{footnotesize}
\begin{whycode}
let sum_iter (a: int array) 
ensures { $\texttt{result = sum 0 (length a) a }$}
= let s = ref 0 in 
  let iter (b: int array)
  requires { ${ \texttt{!s = sum 0 0 a}}$ } 
  ensures  { ${ \texttt{!s = sum 0 (length b) a}}$ } 
  = let n = Array.length b in
    let rec aux (i: int)
    requires { ${\texttt{!s = sum 0 i a}\bwedge 0 \leq \texttt{i} \leq \texttt{n}}$ }
    ensures  { ${\texttt{!s = sum 0 n a}}$ }
    = if i < n
      then (${\red\texttt{s := !s + b.(i)}}$ ; aux (i + 1)) 
    in aux 0
  in iter a; 
  !s
\end{whycode}
\vspace*{-4em}
\begin{center} 
\only<2>{$$\fbox{\OliveGreen{\textbf{we get a first-order program}}}$$}
\only<3>{$$\fbox{\OliveGreen{\textbf{spec is first-order and complete}}}$$}
\only<4>{$$\fbox{\OliveGreen{\textbf{generated VCs can be proved automatically}}}$$}
\end{center}
\end{footnotesize}
\end{frame}


%
\section*{Our first contribution}
\begin{frame}[fragile]
\frametitle{\red Our contribution}
\begin{displaymath}
\begin{array}{@{\hspace*{-1.2em}}llllllll}
  \begin{minipage}{0.2\textwidth}
  {\texttt{{\red SO} program}}\vspace*{-0.5em} \\
 	\hspace*{2em}+\vspace*{-0.5em}\\ 
	{\hspace*{0.5em}\texttt{{\blue FO} spec}}
  \end{minipage} & 
	\stackrel{\texttt{\normalsize \red inlining}}{\texttt{---------->}} \hspace*{0.1em} 
& 
	  \begin{minipage}{0.2\textwidth}
  {\texttt{\color{cblue}{FO} \gray program}}\vspace*{-0.5em} \\
 	\hspace*{2em}\color{cblue}{+}\vspace*{-0.5em}\\ 
	{\hspace*{0.5em}\texttt{\color{cblue}{FO} \gray spec}}
  \end{minipage}
& \stackrel{\texttt{\normalsize \gray VCs generator}}{{\gray \texttt{------------->}}}  & \texttt{\color{cblue}{FO} \gray VCs} 
\end{array}
\end{displaymath}\bigskip\pause
\begin{itemize}
\item[{\red 1.}] identify a fragment of ML where inlining can be done correctly \pause
\item[{\red 2.}] define inlining procedure on that fragment \pause
\item[{\red 3.}] prove that inlining procedure  
\begin{itemize}	
\item[{\red $\bullet$}] {\normalsize always {\red terminates}}
\item[{\red $\bullet$}] {\normalsize {\red preserves} semantics} \pause
\end{itemize}
\end{itemize}
\end{frame}

% 2. quelles difficultés
%    ce qui nous amène à Mini-ML = ML + références globales
%    syntaxe, sémantique, système de types avec effets, preuve de type soundness
%    identification d'un fragment de Mini-ML + définition inlining + preuve

\section*{Fragment of ML}
\begin{frame}[fragile]
\frametitle{A fragment of ML with}
 \pause
\begin{itemize}
	\item[-] {\red second-order} closures  
	\begin{footnotesize}
	\begin{whycode}
      iter : (int -> unit) -> int list -> unit)
      map  : (int -> $\tau$) -> int list -> $\tau$ list)
      fold : ($\tau$ -> int -> $\tau$) -> $\tau$ -> int list -> $\tau$) \end{whycode}
	\end{footnotesize}	\pause
	\item[-] global {\red mutable} references ({\blue ref} int, {\blue ref} (int list), ...) \pause
	\item[-] {\red first-order} recursion  \pause
%	\begin{small}
%	\begin{whycode}
%	      let h (f: int -> int)
%        = let rec g (x: int)
%          = if x = 0 then ${\red\texttt{(f x)}}$ else g${\red\texttt{ (f (x-1))}}$ \end{whycode}
%	\end{small}
	\item[-] a type system {\red with effects}
\end{itemize}
\end{frame}

\section*{Type system with effects}
\begin{frame}[fragile]
\frametitle<1>{Type system with effects}
\frametitle<2>{Ordering types}
%\frametitle<3>{Ordering types}
\frametitle<3>{Reference assignment}
\frametitle<4-5>{Recursive calls}
%\frametitle<6>{Inlining correctness}
\begin{large}
\only<1>{
$$\Gamma \vdash t: \tau^{\texttt{\textbf{i}}}{, \theta, \rho}$$\bigskip
$$~$$
$$~$$
$$~$$}
%$$ \hspace*{0em}\OliveGreen{\small \texttt{restricts the order of references and recursive functions}} $$
%$$\hspace*{-7.5em}\OliveGreen{\small \texttt{gathers information about side-effects}}$$
%$$\OliveGreen{\small \texttt{guarantees that well-typed terms can be inlined correctly}}$$
%$$~$$}
\only<2>{
$$\hspace*{3em}\Gamma \vdash t: \tau^{\red \texttt{\textbf{i}}}, \theta, \rho \quad {\small \red \texttt{i = 0,1,2}} $$\bigskip
$$\hspace*{-15.5em}\texttt{{\blue ref} x:}~\tau^{\red 0}$$
$$\hspace*{-5em}\texttt{{\blue rec} g:}~\tau^{\red 0} \texttt{ -> }  \tau^{\red 0} \texttt{ -> ... -> } \tau^{\red 0} $$
$$\hspace*{2.5em}\texttt{{\blue fun} h:}~\tau^{\red 1} \texttt{ -> }  \tau^{\red 1} \texttt{ -> ... -> } \tau^{{\red 0}} \texttt{ -> ... -> } \tau^{{\red 0}} $$}
%\only<3>{
%$$\Gamma \vdash t: \tau^{\red \texttt{\textbf{i}}}{\white, \theta, \rho} $$\bigskip
%$$\hspace*{-1em}\texttt{{\blue fun} h:}~\tau^{\red 1} \texttt{ -> } \texttt{(} \tau^{\red 1} \texttt{ -> ... -> (} \tau^{{\red 0}} \texttt{ -> ... -> } \tau^{{\red 0}} \texttt{))}$$ $$~$$}
\only<3>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, {\red \theta}, \rho $$ \bigskip
$$ \texttt{\red t may modify the global state}$$ 
 $$~$$
\infrule[T-assign] 
		{\Gamma \vdash \texttt{v}:\tau^{0}, \bot_{\theta}, \bot_{\rho}}
    {\Gamma \vdash \texttt{r}_{\tau^{0}} := \texttt{v} : \texttt{unit}, {\red \top_{\theta}}, \bot_{\rho}}
}
\only<4>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, {\red \rho} $$\bigskip 
$$ \texttt{\red t may diverge} $$
$$~$$
\infrule[T-Rec] 
		{\Gamma, 
		\texttt{f:}{\tau^{\textcolor{red}{0}} 
			\stackrel{\theta, {\red \boldsymbol{\top_{\rho}}}}{\Longrightarrow}\tau^{\textcolor{red}{1}}},~ 
		\texttt{x:}{\tau\textcolor{red}{^0}} \vdash \texttt{t} : 
		\tau^{\textcolor{red}{1}}, \theta, \rho} 
		{ \Gamma \vdash \texttt{rec f x = t} : 
			\tau^{\textcolor{red}{0}} \stackrel{\theta, {\red \top_{\rho}}}{\Longrightarrow}\tau^{\textcolor{red}{1}}, 
			{\blue \bot_{\theta}}, 
			\bot_{\rho}}}
\only<5>{
$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, {\red \rho} $$\bigskip 
$$ \texttt{\red t may diverge} $$
$$~$$
\infrule[T-App] 
	{\Gamma \vdash \texttt{f}: 
	\tau^{0} \stackrel{\theta, {\red \boldsymbol{\top_{\rho}}}}{\Longrightarrow}
  \tau^{1}, \bth, \brh 
  \qquad \Gamma \vdash \texttt{v}:
  	\tau^{0}, \bot_{\theta}, \bot_{\rho}}
   {\Gamma \vdash \texttt{(t~v)} : 
   	\tau^{1}, (\theta \bvee \theta'), {\red \boldsymbol{\top_{\rho}}}}}		
			
%\only<6>{
%$$~$$
%$$ \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho \texttt{ holds }~~ {\red \boldsymbol{\Rightarrow}}~~ \texttt{   t can be inlined correctly}$$
%$$~$$
%$$~$$}
%\only<6>{
%$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
%$$\OliveGreen{\texttt{well-typed terms {\red -->} terms inlined correctly}}$$
%$$~$$
%$$~$$}
%\only<7>{
%$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
%$$\OliveGreen{\texttt{well-typed terms {\red <--} terms inlined correctly}}$$
%$$~$$
%$$~$$}
%\only<6>{
%$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
%$$\OliveGreen{\texttt{well-typed terms {\red -->} terms inlined correctly}}$$
%$$\quad \OliveGreen{\texttt{restrictions typing rules}}$$
%$$~$$}
%\only<7>{
%$$\hspace*{1em} \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho $$\bigskip 
%$$\OliveGreen{\texttt{well-typed terms {\red -->} terms inlined correctly}}$$
%$$\quad \OliveGreen{\bullet \texttt{restrictions typing rules}}$$
%$$\quad \OliveGreen{\bullet \texttt{proving semantics preservation}}$$}

\end{large}
\end{frame}

\section*{typing of let in examples}
\subsection*{let 0}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em} \vdash t_1 : \phantom{tttttttttttttttttt}
			\quad   \vdash t_2 : \phantom{ttttttttttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em} {\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: \phantom{ttttttttttttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{let 1}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \Rouge{\theta_1}, \Rouge{\rho_1}}  \phantom{ttttttttttt} 
			\quad  \vdash t_2 : \phantom{ttttttttttttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: \phantom{ttttttttttttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{let 2}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \Rouge{\theta_1}, \Rouge{\rho_1}}  \phantom{tttttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: \phantom{tttttttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{let 3a}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}} \phantom{tttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{let 3b}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}, 
				(\theta_1 \bvee \theta_2)} \phantom{tttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{let 3c}
\begin{frame}[fragile]
\frametitle{example: let in}

		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{tttttttt}} 
			{\vspace*{-1em}\hspace*{-2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}, 
				(\theta_1 \bvee \theta_2), 
				(\rho_1 \bvee \rho_2)} \phantom{tttttt}}

	%\end{adjustwidth}	
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{Additional hypothesis}
\begin{frame}[fragile]
\frametitle{Additional hypothesis}
		\infrule[] 
			{\vspace*{0.5em}{\red \Gamma} \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \phantom{tttttttt} 
			\quad {\red \Gamma, x:\tau^i}  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \phantom{ttttt} {\blue \texttt{\textbf{H}}}} 
			{\vspace*{-1em}\hspace*{2.1em}{\red \Gamma} \vdash \text{ let } x = t_1 \text{ in } t_2 
				: {\red \tau^{j}, 
				(\theta_1 \bvee \theta_2), 
				(\rho_1 \bvee \rho_2)} \phantom{tttttttt}}

\bigskip
$$ \textcolor{blue}{\texttt{H: } \texttt{(i = 2)} \Rightarrow 
			(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}$$
\end{frame}
\addtocounter{framenumber}{-1}

\section*{liaisons dangereuses}
\begin{frame}[fragile]
\frametitle{les liaisons dangereuses}
\hspace*{-1em}
\begin{small}
\begin{whycode} 
${\red \only<1-2>{\mathcal{P}_1}\only<3-4>{\mathcal{P}_2}}$: 
   let F = ($\only<1-2>{\texttt{\red r:= !r + 1;}}\only<3-4>{\texttt{\red diverge(); }}$ fun (f:int -> int) -> f !r)
   in $\only<1-2>{\texttt{(F id) + (F id)}}\only<3-4>{\texttt{()}}$
   
*?%$\hspace*{8em}\only<2>{{\red \mathcal{P}_{1_{\{r=0\}}} \longrightarrow^{\star} 2_{\{ r=1\}}}}\only<4>{\red \mathcal{P}_{2_{\{r=0\}}} \longrightarrow^{\star} \infty}$
?* 
${\red\only<1-2>{ \mathcal{I}(P_1)}\only<3-4>{\mathcal{I}(P_2)}}:$ 
$\only<1-2>{\qquad \texttt{(r:= !r + 1; !r) + (r:= !r + 1; !r)}}
\only<3-4>{\qquad \texttt{()}}$ 
   
*?%$\hspace*{8em}\only<2>{\mathcal{I}(P_1)_{\{r=0\}} \longrightarrow^{\star} 3_{\{r=2\}}}\only<4>{\mathcal{I}(P_2)_{\{r=0\}} \longrightarrow^{\star} ()_{\{r=0\}}}$      
?*
\end{whycode}
\end{small} \bigskip
\only<1>{
$$ \texttt{\red effect is duplicated} $$}
\only<3>{
$$ \texttt{\red  semantics is not preserved} $$}
\only<2,4>{
$$ \OliveGreen{ \texttt{rejected by type system}} $$}
\end{frame}

%voici un autre exemple que l'on a sur lequel on a evalué notre approche


\section*{Inlining correctness}
\begin{frame}[fragile]
\frametitle<1>{Inlining correctness}
\begin{large}
\only<1>{
$$~$$
$$ \Gamma \vdash t: \tau^\texttt{i}, \theta, \rho \texttt{ holds }~~ {\red \boldsymbol{\Rightarrow}}~~ \texttt{   t can be inlined correctly}$$
$$~$$
$$~$$}
\end{large}
\end{frame}


\section*{Experimental evaluation}
\begin{frame}
\frametitle{Experimental evaluation}
\begin{itemize}
\item we applied inlining manually on various 
\begin{itemize}
\item {\red HO functions} (iterators, maps, folders,...)
\item {\red data structures} (arrays, lists, binary trees, ...) \pause \bigskip
\end{itemize}
\item we used existing {\red verification tools} (Why3, Alt-Ergo) to compare generated VCs
\end{itemize}
\end{frame}

\section*{sum of list elements} 
\begin{frame}[fragile]
\frametitle{example: sum\_list}
\hspace*{-1em}
\begin{whycode}
 let sum_list (l: int list) : int
 ensures { ${\red \texttt{result =  sum l}}$ }
 = let s = ref 0 in
   List.iter 
     (${\red\texttt{fun before after -> !s = sum before}}$) 
     (fun x -> s := !s + x) l; 
   !s     
\end{whycode}
\end{frame}


\section*{iter spec}
\subsection*{Invariant parameter}
\begin{frame}[fragile]
\frametitle{Invariant parameter}
\hspace*{-1em}
%\begin{small}
\begin{whycode}
let iter ($\textcolor{red}{\texttt{inv:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
\end{whycode}\vspace*{-1em}\begin{whygray} 
= let rec loop (${ \texttt{before:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${ \texttt{(Cons x before)}}$ xs
  in loop ${\texttt{Nil}}$ l
\end{whygray}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{before and after}
\begin{frame}[fragile]
\frametitle<1>{Before and after}
\frametitle<2->{Reversed order}
\hspace*{-1em}
%\begin{small}
\begin{whycode}
let iter ($\textcolor{red}{\texttt{inv:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
= let rec loop (${\red \texttt{before:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${\red \texttt{(Cons x before)}}$ xs
  in loop ${\red\texttt{Nil}}$ l
\end{whycode}
%\end{small}

%\begin{displaymath}\hspace*{-1.5em}
%\begin{array}{lccccl}
%\only<2->{{ \{} \texttt{x}_{\red 1} & \texttt{...} & \texttt{x}_{\red k} { \}} & 
%{ \{}  \texttt{x}_{\red k+1} & \texttt{...} & \texttt{x}_{\red n} { \}} \\}
%
%\only<2->{
%&\stackrel{\texttt{\red before}}{\texttt{<-----------------}} & 
%& 
%&\stackrel{\texttt{\red after}}{\texttt{---------------->}} & \\
%{\{}  \texttt{b}_{\red k} & \texttt{...} & \texttt{b}_{\red 0} { \}}  
%&\hspace*{-1em}  {\{} \texttt{a}_{\red 1} & \texttt{...} & \texttt{x}_{\red n-k} { \}}}
%\end{array}
%\end{displaymath}
\end{frame}
\addtocounter{framenumber}{-1}

\subsection*{pre and post}
\begin{frame}[fragile]
\frametitle{Precondition and postcondition}
\hspace*{-4em}
\begin{footnotesize}
\begin{whycode}
let iter ($\textcolor{red}{\text{inv:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
requires { ${\red \texttt{inv Nil l}}$ }
ensures  { ${\red \texttt{inv (reverse l) Nil}}$ } 
= ${\gray\texttt{let rec loop (before:int list) (after:int list)}}$
  ${\gray\texttt{requires \{ inv before after \} }}$
  ${\gray\texttt{ensures~ \{ inv ((reverse after) ++ before)) Nil \}}}$  
  ${\gray\texttt{= match after with}}$
     ${\gray\texttt{| Nil~~~~~~ -> ()}}$
     ${\gray\texttt{| Cons x xs -> f x; loop (Cons x before) xs}}$
  ${\gray\texttt{in loop Nil l }}$
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
\frametitle{Loop invariant}
\hspace*{-1em}
\begin{footnotesize}
\begin{whycode}
${\gray\texttt{let iter (inv:int list -> int list -> prop)}}$
${\gray\texttt{(f:int -> unit) (l:int list)}}$
${\gray\texttt{requires \{ inv Nil l \}}}$
${\gray\texttt{ensures~ \{ inv (reverse l) Nil\}}}$    
= let rec loop $(\textcolor{red}{\text{before:int list}})$ (after: int list) 
  requires $\texttt{\{ inv {\red before after} \}}$
  ensures  $\texttt{\{ inv {\red((reverse after) ++ before) Nil }}\}$  
  ${\gray\texttt{= match after with}}$
     ${\gray\texttt{| Nil~~~~~~ -> ()}}$
     ${\gray\texttt{| Cons x xs -> f x; loop (Cons x before) xs}}$
  ${\gray\texttt{in loop Nil l }}$
\end{whycode}
\end{footnotesize}
\end{frame}
\addtocounter{framenumber}{-1}


\subsection*{Ghost code}
\begin{frame}[fragile]
\frametitle{Regular code}
\hspace*{-1em}
\begin{whycode}
let iter (${\texttt{{\red inv}:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
= let rec loop (${\texttt{{\red before}:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${\red \texttt{(Cons x before)}}$ xs
  in loop ${\red\texttt{Nil}}$ l
\end{whycode}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
\frametitle{Ghost code}
\hspace*{-1em}
\begin{whycode}
let iter (${\texttt{{\red ghost inv}:int list -> int list -> prop}}$) 
(f:int -> unit) (l: int list)
= let rec loop (${ \texttt{{\red ghost before}:int list}}$) (after:int list)
  = match after with
     | Nil       -> ()
     | Cons x xs -> f x; loop ${\red \texttt{(Cons x before)}}$ xs
  in loop ${\red\texttt{Nil}}$ l
\end{whycode}
\end{frame}

\section*{Ghost Code}
%\begin{frame}
% \begin{itemize}
% 	\item[] $${\large \red \texttt{Ghost Code}}$$
% 	\begin{center}
% 	\includegraphics[scale=0.2]{Ghostbusters2}
% 	\end{center} 
% \end{itemize}
%\end{frame}
%\addtocounter{framenumber}{-1}

\subsection*{ghost properties informally}
% un pgm avec du code ghost :
%  - pour le prouver, je prends *tout* le code, sans distinction
%  - pour l'exécuter, j'oublie le code ghost

\begin{frame}
\frametitle{{Ghost code}}
	may be inserted for the purpose of specification and/or proof \\[1em]
	\pause	
	\begin{itemize}
	\item[\red $\bullet$] regular code does not see ghost data
	\item[\red $\bullet$] ghost code may read regular data (but cannot modify it)
	\item[\red $\bullet$] ghost code must not diverge\\[1em]
	\end{itemize}
in particular, ghost code may be removed without change of observable behaviour
\end{frame}


\subsection*{Ghost formalisation}

% 4. formalisation de Ghost-ML
%    syntaxe, sémantique, typage avec effets (montrer le jugement),
%      bien expliquer qu'il y a des choix à faire (mais aussi des*)
%      obligations), l'opération erasure et la preuve

\begin{frame}
\frametitle{Our second contribution}
\begin{itemize}
\item formalize {\red Ghost-ML}: syntax, semantics \pause
\item extend type system with {\red ghost effects} \pause
\item prove {\red non-interference} between ghost code and regular code \pause
\item define ghost {\red erasure} and prove {\red semantics preservation}
\end{itemize}
\end{frame}

%\begin{frame}
%\frametitle{ghost code non-interference}
%type system with effects 
%$$\Gamma \vdash_{gh} t: \tau^{i}, (\theta, \rho, {\red \beta}) $$
%
%\bigskip\pause
%typing invariant 
%$$\Gamma \vdash_{gh} t : \tau, (\theta, \rho, \gbr) 
% ~~ \Rightarrow ~~
%\models (\gbr = \gbtr) \Rightarrow (\theta = \bth \bwedge \rho = \brh) $$
%\end{frame}
%
%
%\begin{frame}
%\frametitle{ghost code propagation}
%\begin{footnotesize}	
%\begin{displaymath}
%\begin{array}{l}
%\dfrac
%	{
%		\ghosttyping
%			{t_1}
%			{\tau_1}
%			{\theta_1}
%			{\rho_1}
%			{\gbra{1}^{\rouge{'}}}
%			{} \qquad
%		\ghosttyping
%			{t_2}
%			{\tau_2}
%			{\theta_2}
%			{\rho_2}
%			{\gbra{2}}
%			{  \quad \models \gba{1} \Rightarrow \gba{1}^{'}}
%	}
%	{\ghosttyping
%		{let~x^{\gbra{1}}_{\tau_1} = t_1~in~t_2}
%		{\tau_2}
%		{\theta_1 \bvee \theta_2}
%		{\rho_1 \bvee \rho_2}
%		{\gbra{2} \bvee (\gbran{1} \bwedge \gbra{1}^{\rouge{'}})}
%		{}}
%	{}
%	\end{array}	
%\end{displaymath}
%\end{footnotesize}	
%\end{frame}

\section*{Future Work}
\begin{frame}
\frametitle{Future work}

\begin{itemize}
\item[]\hspace*{-3em} ${\blue \bullet}$  continue {\red experimental evaluation}  \pause

\begin{itemize} 
	\item[] {\hspace*{-3em} ${\blue \bullet}$ \normalsize make a {quantitative study} of HO programs used in practice} \pause
	\item[]  {\hspace*{-3em} ${\blue \bullet}$ \normalsize implement a prototype }   \pause \bigskip
\end{itemize} 

\item[] \hspace*{-3em} ${\blue \bullet}$ continue a {\red theoretical study} of our approach \pause
\begin{itemize}
\item[] {\hspace*{-3em} ${\blue \bullet}$ \normalsize adapt correctness proof for   studied fragment extensions} 
\item[] {\hspace*{-3em} ${\blue \bullet}$ \normalsize write two research papers} \pause
\end{itemize}
\end{itemize}
 \end{frame}

%\begin{frame}
%
%\frametitle{Related work}
%\hspace*{-1.5em}
%\only<1->{ verification of {\red imperative} programs (C, Java, ...)}
%\begin{itemize}
%\item<2->[] \hspace*{-2em} ${\blue \bullet}$  first-order logic {\small(Hoare Logic, Weakest Precondition Calculus)}
%\item<3->[] \hspace*{-2em}  ${\blue \bullet}$ fully automatic first-order provers (Nqthm, Otter, SPASS)
%\item<4->[] \hspace*{-2em}  ${\blue \bullet}$ efficient SMT provers (Alt-Ergo, Z3, ...) 
%\end{itemize}
%\bigskip
%\hspace*{-1.5em}
%\only<1->{verification of {\red functional } \underline{stateful} programs (OCaml, F$\sharp$, ...)}
%\begin{itemize}
%\item<5->[] \hspace*{-2em}  ${\blue \bullet}$ higher-order logic {CIC, \small(Hoare Type Theory, Kanig PhD, ...)} 
%%\item<6->[] \hspace*{-2em}  ${\blue \bullet}$ purely functional programs (Coq, PVS, Pangolin)
%\item<6->[] \hspace*{-2em}  ${\blue \bullet}$ stateful functional programs (F$^{\star}$, Who, CFML)
%\item<7->[]  \hspace*{-2em}  ${\blue \bullet}$ interactive proof assistants (Coq, Isabelle, ...)
%\end{itemize}\bigskip
%\only<9>{$$\fbox{\texttt{{\blue challenge}:{\red HO programs proof automation}}}$$}
%\end{frame}


%\section*{Verifying Sum_iter}
%\begin{frame}[fragile]
%\frametitle<1>{Program specification}
%\frametitle<2>{Program verification}
%\frametitle<3>{Our approach}
%\frametitle<4>{Invariant formula}
%\begin{whycode}
% let sum_iter (a: int array) *?\only<1->{\\
%	{\blue \texttt{ ensures }}\{\texttt{ {\blue result} =} 
%	{\red \texttt{ sum 0 (length a) a }}\}}?* 
% = let s = ref 0 in
%   Array.iter*?
%   \only<4->{\\\hspace*{3.5em}
%   {\red\texttt{(fun i -> !s = sum 0 i a)}}\\}?* 
%       (fun x ->  s := !s + x) a; 
%   !s 
%\end{whycode}
%\begin{center}
%\only<2>{\red Can we prove \texttt{sum\_iter} in a way similar to imperative sum ?}
%\only<3>{
%\begin{displaymath}
%\begin{array}{@{\hspace*{-1.2em}}llllllll}
%  \begin{minipage}{0.2\textwidth}
%  {\texttt{{\red HO} program}}\vspace*{-0.5em} \\
% 	\hspace*{2em}+\vspace*{-0.5em}\\ 
%	{\hspace*{0.5em}\texttt{{\blue FO} spec}}
%  \end{minipage} & 
%	\stackrel{\texttt{\normalsize \red }}{\texttt{---------->}} \hspace*{0.1em} 
%& 
%	  \begin{minipage}{0.2\textwidth}
%  {\texttt{\color{cblue}{FO} \gray program}}\vspace*{-0.5em} \\
% 	\hspace*{2em}\color{cblue}{+}\vspace*{-0.5em}\\ 
%	{\hspace*{0.5em}\texttt{\color{cblue}{FO} \gray spec}}
%  \end{minipage}
%& \stackrel{\texttt{\normalsize \gray VCs generator}}{{\gray \texttt{------------->}}}  & \texttt{\color{cblue}{FO} \gray VCs} 
%\end{array}
%\end{displaymath}
%}
%\end{center}
%\end{frame}

%\begin{frame}[fragile]
%\frametitle{\red{ghost code}}
%\begin{footnotesize}
%\begin{whycode}
%let iter ($\textcolor{red}{\text{ghost inv:int list -> int list -> prop}}$) (f:int -> unit) (l: int list)
%requires { ${ \texttt{inv Nil l }}$ }
%ensures  { ${ \texttt{inv (reverse l) Nil}}$ }
%= let rec loop $(\textcolor{red}{\text{ghost before:int list}})$ (after: int list) 
%  requires $\texttt{\{ inv { before after} \}}$
%  ensures  $\texttt{\{ inv {((reverse after) ++ before)} }\}$     
%  = match after with 
%     | Nil       -> ()
%     | Cons x xs -> f x; loop ($\textcolor{red}{\text{Cons x before}}$) xs 
%  in loop $\texttt{\red Nil}$ l 
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%\begin{frame}[fragile]
%\frametitle{regular code}
%\hspace*{-1em}
%\begin{footnotesize}
%\begin{whycode}
%${\gray\texttt{let iter (inv:int list -> int list -> prop)}} ~
%{\gray\texttt{(f:int -> unit) (l:int list)}}$
%${\gray\texttt{requires \{ inv Nil l \}}}$
%${\gray\texttt{ensures~ \{ inv (reverse l) Nil \}}}$    
%= ${\gray\texttt{let rec loop (before:int list) (after:int list)}}$
%  ${\gray\texttt{requires \{ inv before after \} }}$
%  ${\gray\texttt{ensures~ \{ inv ((reverse after) ++ before) Nil \}}}$
%  = match after with 
%     | Nil       -> ()
%     | Cons x xs -> f x; loop ($\textcolor{red}{\text{Cons x before}}$) xs 
%  in loop $\texttt{\red Nil}$ l 
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}

%\begin{frame}
%\frametitle{Related work}
%{\red last 40 years}
%	\begin{itemize}
%		\item[] formal verification of imperative programs 
%		\item[] emergence of efficient ATPs (Alt-Ergo, Z3, CVC4, ...)
%		\item[] first-order verification plateforms (Why3, Boogie, ...)
%	\end{itemize}\vspace*{1em} \pause
%{\red more recently}
%	\begin{itemize}
%		\item[] higher-order functional programs (Coq, PVS, Pangolin,...)
%		\item[] higher-order {\red stateful} programs (Who, F$^\star$, HTT, CFML, ...)
%	\end{itemize}
%\pause
%\bigskip
%{\red challenge}: proof automation
%\end{frame}

%\begin{frame}\frametitle{To summarize, in our work}\vspace*{-4em}
%\begin{itemize}
%	\item[\blue$-$]  we described of the inlining by the set of rewriting rules; \\[1em]
%	\item[\blue$-$]  we proved that the procedure described by these rules \\[0.5em]
%	
%	\begin{itemize}
%		\item[$\blacktriangleright$]
%		{\normalsize always {\red terminates } giving a first-order output term} \\[0.3em]
%		\item[$\blacktriangleright$]  
%		{\normalsize {\red preserves} the semantics of the initial term} \\[1em]
%	\end{itemize}
%	\item[\blue $-$] we formalized the notion of {\red ghost code}
%\end{itemize}
%\end{frame}

	
% In this work (1) formalize domain 
% prove soundness 

% Formaliziation : typing
% Correctness : equivalence
% Example
\end{document}

\begin{frame}[fragile]
%\frametitle{example: let in}
%\begin{small}
%		\infrule[] 
%			{\vspace*{0.5em}\Gamma \vdash t_1 :  {\red \tau^i, \theta_1, \rho_1}  \quad 
%			\quad \Gamma, x:\tau^i  \vdash t_2 : {\red \tau^j, \theta_2, \rho_2}  \quad {\footnotesize \textcolor{blue}{(i = 2) \Rightarrow 
%			(\theta_1 = \bot_{\theta}\bwedge \rho_1 = \bot_{\rho})}}} 
%			{\vspace*{-1em}\hspace*{-2.1em}\Gamma \vdash \text{ let } x = t_1 \text{ in } t_2 
%				: {\red \tau^{j}, 
%				(\theta_1 \bvee \theta_2), 
%				(\rho_1 \bvee \rho_2)} \phantom{ttttttttttt}}
%	\end{small}	
%	\begin{small}
%\begin{whycode} 
%${\red \only<1>{\mathcal{P}_1}\only<2->{\mathcal{P}_2}}$: 
%   let F = 
%      ($\only<1>{\texttt{\red r:= !r + 1;}}\only<2->{\texttt{\red diverge(); }}$ fun (f:int -> int) -> f !r)
%   in $\only<1>{\texttt{(F id) + (F id)}}\only<2->{\texttt{()}}$
%
%${\red\only<1>{ \mathcal{I}(P_1)}\only<2->{\mathcal{I}(P_2)}}: \only<1>{\texttt{(r:= !r + 1; !r) + (r:= !r + 1; !r)}}
%\only<2->{\texttt{()}}$
%\end{whycode}
%\end{small}
%\end{frame}
%\addtocounter{framenumber}{-1}
%\begin{itemize}	
%	\item[-] {\red } ordered simple types 
%	\begin{footnotesize} 
%		\item[] \qquad$\tau^{\red 0}:\{\texttt{ bool, int list,... }\}$
%		\item[] \qquad$\tau^{\red 1}:\{\texttt{ int -> bool, int -> (int -> bool), ... }\}$
%		\item[] \qquad$\tau^{\red 2}:\{\texttt{ (int -> int) -> bool, ... }\}$\\[1em]
%	\end{footnotesize}
%	\end{itemize}
%	\item[-] a type system {\red with effects}:\\[0.5em]
%		\begin{itemize}

%\begin{frame}[fragile]
%\frametitle{Experimental language}
%a fragment of ML with
%\begin{itemize}
%	\item[-] built-in data (int, int list, ...)
%	\item[-] zero-order global references 
%	\item[-] first-order recursion
%	\item[-] second-order closures 
%	\item[-] {\red second-order} programs with types \\[0.5em]
%		\begin{itemize}	
%		\begin{footnotesize} 
%			\item[] \qquad$\tau^{\red 0}:\{\texttt{ int, bool,... }\}$
%			\item[] \qquad$\tau^{\red 1}:\{\texttt{ int -> bool, int -> (int -> bool), ... }\}$
%			\item[] \qquad$\tau^{\red 2}:\{\texttt{ (int -> int) -> bool, ... }\}$\\[1em]
%		\end{footnotesize}
%		\end{itemize}
%		 \pause
%	\item[-] a type system {\red with effects}:\\[0.5em]
%		\begin{itemize}
%			\item[] \qquad $\Gamma \vdash t: \tau^{i}, {\red \theta, \rho} $
%		\end{itemize}
%\end{itemize}
%\end{frame}

%\begin{frame}[fragile]
%\frametitle{\OliveGreen{instantiate inv}}
%\vspace*{0em}
%\begin{footnotesize}
%\begin{whycode}
%let sum_iter (a: int array) 
%ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
%= let s = ref 0 in 
%  let iter (f:int -> unit) (b: int array)
%  requires { ${\red \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
%  ensures  { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}})$ } 
%  = let rec aux (i: int)
%    requires { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{(length b)}$ }
%    ensures  { ${\red \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}}$ }
%    = if i < Array.length b
%      then (f b.(i) ; aux (i + 1)) 
%    in aux 0
%  in iter (fun x -> s := !s + x) a; 
%  !s
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%
%\subsubsection*{Instantiate function f}
%\begin{frame}[fragile]
%\frametitle{\OliveGreen{instantiate f}}
%\vspace*{0em}
%\begin{footnotesize}
%\begin{whycode}
%let sum_iter (a: int array) 
%ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
%= let s = ref 0 in 
%  let iter ${\red \texttt{(f:int -> unit)}}$ (b: int array)
%  requires { ${ \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
%  ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}})$ } 
%  = let rec aux (i: int)
%    requires { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{(length b)}$ }
%    ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}}$ }
%    = if i < Array.length b
%      then (${\red\texttt{f}}$ b.(i) ; aux (i + 1)) 
%    in aux 0
%  in iter ${\red\texttt{(fun x -> s := !s + x)}}$ a; 
%  !s
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%
%\begin{frame}[fragile]
%\frametitle{\OliveGreen{instantiate f}}
%\vspace*{0em}
%\begin{footnotesize}
%\begin{whycode}
%let sum_iter (a: int array) 
%ensures { $\texttt{result = }\sum_{~0 \leq j < \text{a.length}} a[j]$ }
%= let s = ref 0 in 
%  let iter (b: int array)
%  requires { ${ \texttt{!s = } \sum_{~0\leq j < 0} \texttt{ a[j]})}$ } 
%  ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}})$ } 
%  = let rec aux (i: int)
%    requires { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{i}} \texttt{a[j]}} \bwedge 0 \leq \texttt{i} \leq \texttt{(length b)}$ }
%    ensures  { ${ \texttt{!s = } \sum_{~0\leq j < \texttt{(length b)}} \texttt{a[j]}}$ }
%    = if i < Array.length b
%      then (${\red\texttt{s := !s + b.(i)}}$ ; aux (i + 1)) 
%    in aux 0
%  in iter a; 
%  !s
%\end{whycode}
%\end{footnotesize}
%\end{frame}
%\addtocounter{framenumber}{-1}
%
%
%%\section*{Inlining}
%%\begin{frame}
%% \begin{itemize}
%% 	\item[] $${\large \red \texttt{Inlining}}$$
%% 	\begin{center}
%%% 	\includegraphics[scale=0.31]{GhostBusters}
%% 	\end{center} 
%% \end{itemize}
%%\end{frame}
%%\addtocounter{framenumber}{-1}
%



%\begin{frame}[fragile]
%\frametitle<1>
%{sum example with {loop}}
%\frametitle<2>
%{\quad program specification}
%\frametitle<3>
%{\quad loop invariant}
%\frametitle<4>
%{precondition}
%\frametitle<5>
%{array bound check}
%\frametitle<6>
%{preservation}
%\frametitle<7>
%{postcondition}
%\vspace*{-3em}
%\begin{displaymath} 	
%\begin{array}{@{\hspace*{0em}}l@{\hspace*{1.5em}}ll@{\hspace*{1em}}l}
%
%\only<-3>{\vspace*{2em}}
%\only<4>{
% \rond{vc1}	 
% &\textcolor{red}{\emptyset}
% &\textcolor{red}{\vdash}
% &\textcolor{red}{(0 \leq 0 \bwedge 0 \leq n) \bwedge 0 = \sum_{~0\leq j < 0} a[j] \phantom{ phantom of the opera is here right now}}}
%
%\only<5>{
%	\rond{vc2}
%	&\textcolor{red}{\mathcal{I} \bwedge i < n}
%	&\textcolor{red}{ \vdash} 
%	&\textcolor{red}{ 0 \leq i < n} \phantom{phantom of the opera is here right now}}
%
%
%\only<6>{
%	\rond{vc3}
%	&\textcolor{red}{\mathcal{I} \bwedge i < n}
%	&\textcolor{red}{\vdash} 
%	&\textcolor{red}{s + a[i] = \sum_{~0 \leq j < i+1} a[j] \bwedge (0 \leq (i+1) \leq n)   \phantom{phantom of the opera is here right now}}}
%
%
%\only<7>{
%	\rond{vc4}
%	&\textcolor{red}{ \mathcal{I} \bwedge i \geq n} 
%	&\textcolor{red}{ \vdash}
%	&\textcolor{red}{ s = \sum_{~0 \leq j < n} a[j] \phantom{phantom of the opera is here right now}}}
%
%\end{array}
%\end{displaymath}
%\vspace*{-2em}
%\begin{normalsize}
%	\begin{whycode}  
%let sum_while (a: int array) *?\only<2->{\\ 
%	{\blue ensures} $\{\texttt{ {\blue result} = }{\red~\sum_{~0 \leq j < \text{a.length}} a[j]}~\}$}?* 
%= let s = ref 0 in
%  let n = Array.length a in
%  let i = ref 0 in
%  *?\only<4>{\hspace*{-2em}\crond{vc1}{red}~}\only<5->{\hspace*{-2em}\crond{vc1}{gray}~}?*while !i < n do *?
%  
%  \only<3->{\\    
%  ${ \blue \hspace*{1em} \texttt{invariant}}  
%   ~\{{\red~\mathcal{I}: \texttt{!s = } \sum_{0\leq j < !i} a[j] \bwedge 0 \leq !i \leq \texttt{n}}~\}$} 
%  ?*
%	 	*?
%	 	\only<5>{\hspace*{-2em}\crond{vc2}{red}~}
%	 	\only<4,6->{\hspace*{-2em}\crond{vc2}{gray}~}?*  s := !s + a.(!i);  
%    i := !i + 1
% *?\only<6>{\hspace*{-1.5em}\crond{vc3}{red}\hspace*{-0.0em}}
% 	\only<4-5,7->{\hspace*{-1.5em}\crond{vc3}{gray}\hspace*{-0.0em}}?* done;
% *?\only<4-6>{\hspace*{-1.5em}\crond{vc4}{gray}}\only<7->{\hspace*{-1.5em}\crond{vc4}{red}}?* !s 
%\end{whycode}\vspace*{-0.5em}
%\end{normalsize}
%\end{frame}

%\subsubsection*{Conclusion}
%\begin{frame}
%\frametitle{automated proof}
%\begin{itemize}
%\item All verification conditions {\tiny \rond{vc1} - \rond{vc4}} are first-order formulas.
%\item Automated theorem provers easily prove them. 
%%\item<4-> {\color{red} Can we generate first-order VCs from that specification ?}
%\end{itemize}
%\bigskip\pause
%\begin{center}
% {\color{red} Can we prove \texttt{sum\_iter} in a similar way ?}
%\end{center}
%\end{frame}


%\documentclass{beamer}
%
%\usepackage[utf8]{inputenc}
%\usepackage[french]{babel}
%
%\begin{document}
%
%\title{Deductive Verification of Stateful Second-Order Programs}
%\author{Léon Gondelman}
%\date{M2 internship \\ \today}
%
%\begin{frame}
%  \maketitle
%\end{frame}

% Local Variables:
% compile-command: "rubber -d slides"
% ispell-local-dictionary: "francais"
% End:



