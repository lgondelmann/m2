(******************************************************************************)
module Sum 
  use import list.List
  use import int.Int
  use import list.Append
  use import list.Reverse 
  use import list.Mem
  function sum (l:list int) : int =
     match l with
       | Nil -> 0
       | Cons x xs -> x + sum xs
     end

  lemma sum_append:
    forall l1 l2 : list int. sum (l2 ++ l1) = (sum l1) + (sum l2)

  lemma sum_reverse:
    forall l1 : list int. sum (reverse l1) = sum l1

  lemma mem_reverse :
    forall l1: list int, x: int. mem x l1 <-> mem x (reverse l1)

end

(******************************************************************************)
module BinTree
  use import bintree.Tree
  use import bintree.Inorder
  use import ref.Ref
  use import int.Int
  use import list.SortedInt
  use import list.Mem
  use import list.Reverse
  use import Sum
  val s: ref int
  val t: tree int

  (*
predicate member (x: int) (t: tree int) =
    match t with
     | Empty -> false
     | Node l y r -> if x = y then true
       	      	     else member x l \/ member x r
    end


  let rec iter_inorder 
      (f: 'a -> unit) 
      (t: tree 'a) 
      (ghost b: list 'a)
      (ghost inv: list 'a -> list 'a -> prop) : unit =
    requires { inv b l } 
    ensures  { inv (reverse (inorder t) ++ b) Nil }
    match t with
      | Empty -> ()
      | Node l x r -> 
           iter_inorder f l b inv; 
	   f x; 
	   iter_inorder f r (reverse (inorder l) ++ Cons x b) inv
    end 

    let iter_inorder f t inv =
        requires { inv Nil (inorder t) } 
    	ensures  { inv (reverse (inorder t)) Nil }
    iter_inorder f t inv Nil
*)

(* let test (t: tree int) = 
    iter_inorder (fun x -> s:= x + !s) t (/l b. /l a. !s = sum b) *)
 
  let rec iter_inorder_sum (t: tree int) (ghost b: list int) : unit  = 
    requires { !s = sum b }
    ensures  { !s = sum ((reverse (inorder t)) ++ b) }
    match t with
      | Empty -> ()
      | Node l x r -> 
      iter_inorder_sum l b; 
      (s := x + !s); iter_inorder_sum r (Cons x (inorder l) ++ b) 
    end

  let test_iter_0 () =
     s := 0;
    iter_inorder_sum t Nil;
    assert {!s = sum (reverse (inorder t))}

exception Failure 


(* 
 requres ...
 ensures ...
 raises {caller exn -> exn_pred ((reverse (inorder t)) ++ b)) Nil}

let test (t: tree int) = 
    iter_inorder 
      (fun x -> if x < !s then raise Failure else s := x + !s) 
      t 
      (/l b. /l a. sorted b *)



  let rec iter_inorder_isbst (t : tree int) (ghost b: list int) : unit =
    
    requires {sorted b}
    ensures  {sorted ((reverse (inorder t)) ++ b)}
    raises {Failure  -> not (sorted ((reverse (inorder t)) ++ b))}
   match t with
     | Empty -> ()
     | Node l x r ->
          iter_inorder_isbst l b;
	  (if x < !s then raise Failure  else s:= x);
	  iter_inorder_isbst r (Cons x (inorder l) ++ b)
     end

  let test_iter_1 (t: tree int) =
    requires { forall x:int. mem x (inorder t) -> x >= 0 /\ !s >= 0 }
    ensures  { sorted (reverse (inorder t)) }
    raises   { Failure  -> not (sorted  (reverse (inorder t))) }
    s := 0;
    iter_inorder_isbst t Nil
 



 (*let rec leftmost (t: tree int) : int =
      match t with
        | Empty -> raise Failure
	| Node (Node Empty x r0) y r -> x
	| Node l x r -> leftmost l
      end *) 
end


(******************************************************************************)
module Iter
  use import int.Int
  use import int.MinMax
  use import list.List
  use import ref.Ref
  use import list.Mem
  use import list.Reverse
  use import list.Append
  use import list.Length
  use import Sum

  val s : ref int
  val l0 : list int

  (* ******************************  iter  ******************************* *)

(*

  let rec iter
    (f: 'a -> unit) (l : list 'a)
    (ghost inv: list 'a -> list 'a -> prop)
    (ghost before: list 'a) : unit =
      variant   { l }
      requires  { inv before l }
      ensures   { inv ((reverse l) ++ before) Nil }
    match l with
       | Nil       -> ()
       | Cons x xs -> f x; iter f xs inv (Cons x before)
     end

  let iter f l inv =
      requires { inv Nil l }
      ensures  { inv (rev l) Nil }
    iter f inv l Nil

  let test () =
    iter (fun x -> s:= x + !s) l (/| before. /| after. !s = sum before)

   // requires =   (/| bef. /| aft. !s = sum bef) before l
   // ensures  =   (/| bef. /| aft. !s = sum bef) ((rev l) ++ bef) Nil


*)

  let rec iter_0 l (ghost before: list int) =
    variant  { l }
    requires { !s = sum before }
    ensures  { !s = sum ((reverse l) ++ before) }
    match l with
      | Nil -> ()
      | Cons x xs -> s := x + !s; iter_0 xs (Cons x before)
    end

  let test_iter_0 () =
     s := 0;
    iter_0 l0 Nil;
    assert {!s = sum l0}

 val a0 : ref int
 val a1 : ref int


(*
 let test () =
    iter (fun x -> a0:= !a0 + 1; a1 := !a1 - 1) l
    (/| b. /| a. !a0 + !a1 = length b + length a)  *)



 let rec iter_1 l (ghost before: list int) =
    variant  { l }
    requires {  !a0 + !a1 = length before + length l}
    ensures  {  !a0 + !a1 = length ((reverse l) ++ before)
                          + length (Nil : list int)  }
    match l with
      | Nil -> ()
      | Cons x xs -> a0:= !a0 + 1; a1 := !a1 - 1; iter_1 xs (Cons x before)
    end

  let test_iter_1 () =
     a0 := 0; a1 := length l0;
    iter_1 l0 Nil;
    assert {!a0 + !a1 = length l0}

 val lr1 : ref (list int)

(*
 let test () =
    iter (fun x -> lr1: = Cons x !lr a0:= !a0 + 1; a1 := !a1 - 1) l
    (/| b. /| a. !a0 + !a1 = length b + length a)  *)



 let rec iter_2 l (ghost before: list int) =
    variant  { l }
    requires {  !a0 + !a1 = length before + length l}
    ensures  {  !a0 + !a1 = length ((reverse l) ++ before)
                          + length (Nil : list int)  }
    match l with
      | Nil -> ()
      | Cons x xs -> lr1:= Cons x !lr1; iter_2 xs (Cons x before)
    end

  let test_iter_2 () =
     a0 := 0; a1 := length l0;
    iter_2 l0 Nil;
    assert {!a0 + !a1 = length l0}

end


module Fold
  use import int.Int
  use import int.MinMax
  use import list.List
  use import ref.Ref
  use import list.Mem
  use import list.Reverse
  use import list.Append
  use import list.Length
  use import Iter
  use import Sum

(**********************************  fold  *************************************)
(*
  let rec fold (f: a' -> 'b -> 'a) (a: 'a) (l: list 'b) (ghost b: list 'b)
               (ghost inv : list 'b -> list 'b ->
       	requires  {inv b l a }
        ensures   {inv ((reverse l) ++ b) Nil result}
      = match l with
         | Nil -> a
         | Cons x xs -> fold f (f a x) xs inv b
        end

  let fold f a l inv  =
      requires {inv Nil l a}
      ensures  {inv (reverse l) Nil result}
    fold f inv l Nil a

*)


(* let test_0 () =
     fold (fun a x -> x + a) 0 l (/| b. /| l. /| a. a = sum b) *)

let rec fold_0 (a : int) (l : list int) (ghost b : list int)
 requires { a = sum b}
 ensures  { result = sum ((reverse l) ++ b) }
 = match l with
    | Nil -> a
    | Cons x  xs ->  fold_0 (x + a) xs (Cons x b)
  end


 let test_fold_0 () =
    let n = fold_0 0 l0 Nil in
    assert {n = sum l0}


(* let test_1 () =
     fold (fun a x -> min x a) 0 l
      (/| b. /| l. /| a. a =
       forall x:int. (x >= 0 /\ mem x b) -> a <= x *)

let rec fold_1 (a : int) (l : list int) (ghost b : list int)
   requires { forall x:int. (x >= 0 /\ mem x b)  -> a <= x }
   ensures  { forall x:int. (x >= 0 /\ mem x ((reverse l) ++ b)) -> result <= x }
  = match l with
     | Nil -> a
     | Cons x xs -> fold_1 (min x a) xs (Cons x b)
    end


 let test_fold_1 () =
    let n = fold_1 0 l0 Nil in
    assert {forall x: int. x >= 0 /\ mem x l0 -> n <= x}


(* let test_2 () =
     fold (fun a x -> min x a) 0 l
      (/| b. /| l. /| a. a =
       forall x:int. (mem x b /\ x >= 0) <-> mem x a *)

let rec fold_2 (a : list int) (l : list int) (ghost b : list int)
   requires { forall x:int. (mem x b /\ x >= 0) <-> mem x a }
   ensures  { forall x:int. (mem x (reverse l ++ b) /\ x >= 0) <-> mem x result}
  = match l with
     | Nil -> a
     | Cons x xs -> fold_2 (if x >= 0 then Cons x a else a) xs (Cons x b)
    end

 let test_fold_2 () =
    let l1 = fold_2 Nil l0 Nil in
    assert {forall x:int. (mem x l0 /\ x >= 0) <-> mem x l1 }

end

module Filter
  use import int.Int
  use import int.MinMax
  use import list.List
  use import ref.Ref
  use import list.Mem
  use import list.Reverse
  use import list.Append
  use import list.Length
  use import Iter
  use import Fold

(*
  let rec filter (f: a' -> bool) (l: list 'a) (ghost b r: list 'a)
               (ghost inv : list 'a -> list 'a -> list 'a -> prop
       	requires  {inv b r l}
        ensures   {inv ((reverse l) ++ b) Nil}
      = match l with
         | Nil -> Nil
         | Cons x xs -> if f x then Cons x (filter f xs) inv b
	   	        else filter f xs
        end

  let filter f l inv  =
      requires {inv Nil l}
      ensures  {inv (reverse l) Nil}
    filter f l Nil inv

*)



let rec filter_0 (l : list int) (ghost b r: list int)
 requires { forall x: int. mem x b /\ x >= 0 <-> mem x r}
 ensures  { forall x: int. mem x ((reverse l) ++ b) /\ x >= 0 <->
           mem x ((reverse result) ++ r)}
 = match l with
    | Nil -> Nil
    | Cons x  xs ->  if x >= 0 then Cons x (filter_0 xs (Cons x b) (Cons x r))
                     else filter_0 xs (Cons x b) r
  end


 let test_filter_0 () =
    let l1 = filter_0 l0 Nil Nil in
    assert {forall x: int. mem x l0 /\ x >= 0 <-> mem x l1}

end



(*
module Map
  use import int.Int
  use import int.MinMax
  use import list.List
  use import ref.Ref
  use import list.Mem
  use import list.Reverse
  use import list.Append
  use import list.Length
  use import Sum
  use import Iter



(* ******************************  map  ******************************* *)

(*

 let rec map f l (ghost b) ()  =
     requires  { true }
     ensures   { inv  }
  match l with
    | Nil -> Nil
    | Cons x xs -> Cons (f x) (map f xs))



 let map f l inv =
      requires { inv Nil l }
      ensures  { inv (rev l) Nil }
    map f inv l Nil

  let test () =
    iter (fun x -> x + 1)
         (/| before. /| after. /| l. sum l = sum after + length after)

*)

  let rec map_1 (l: list int)  =
    requires { true }
    ensures  { sum result = sum l + length l  }
    match l with
      | Nil -> Nil
      | Cons x xs ->  Cons (x + 1) (map_1 xs)
    end

  let test_map_1 () =
    let l1 = map_1 l0 in
    assert {sum l1 = sum l0 + length l0}



 val lr : ref (list int)

 let rec map_2 (l: list int) (ghost b: list int)  =
    requires { !lr = b}
    ensures  { !lr = ((reverse result) ++ b)}
    match l with
      | Nil -> Nil
      | Cons x xs ->  let y = lr := Cons x !lr; x in
      	       	       Cons y (map_2 xs (Cons x b))
    end

  let test_map_2 () =
    lr := Nil;
    let l1 = map_2 l0 Nil in
    assert {!lr = reverse l1}





(*


*)



end


(*
Local Variables:
compile-command: "why3ide -I . examples.mlw"
End:
*)

 (* predicate is_binary_searh_tree (t: tree int) = 
    match t with 
     | Empty -> true
     | Node l x r -> 
       (forall y: int. member y l -> y <= x) /\
       (forall z: int. member z l -> x <= z) /\
       is_binary_searh_tree l /\ is_binary_searh_tree r
    end
 

  lemma mem_sorted : 
    forall x y: int, l: list int. sorted (Cons x l) /\ mem y l -> x <= y   

  lemma member_bst : 
    forall x: int, t: tree int. mem x (inorder t) -> member x t

  lemma is_bst_node : 
    forall l r : tree int, x: int.  
      sorted (inorder (Node l x r)) -> 
      (forall y: int. member y l -> y <= x) /\
      (forall z: int. member z r -> x <= z) /\ 
      sorted (inorder l) /\  sorted (inorder r)

  lemma is_bst : 
    forall t: tree int.  sorted (inorder t) -> is_binary_searh_tree t
*)




 (* inductive prefix (l0 l1: list 'a) = 
     | PrefixNil : forall l: list 'a. prefix Nil l
     | PrefixCons : forall l0 l1: list 'a, x: 'a. prefix l0 l1 ->
                       prefix (Cons x l0) (Cons x l1)

  lemma sorted_prefix : 
  forall l0 l1 : list int. prefix l0 l1 /\ not (sorted l0) -> not (sorted l1)

  lemma sorted_prefix2 : 
  forall l0 l1 : list int. 
     not (sorted (l0 ++ l1)) /\ sorted l1 -> 

 prefix l0 l1 /\ not (sorted l0) -> not (sorted l1) *)

*)