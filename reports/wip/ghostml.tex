\section{GhostLambda: Lambda-Calculus with Ghost Code}
%cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
%Annotating a program with logical formulae predicting statically it dynamic behaviour is a 
%keystone of the deductive software verification approach.
%
%Typically, these logical formulae are assertions about program assigned variables,
% loop invariants, recursive function variants, etc. 
% 
% However,  it is often useful to annotate programs with some data that appear in program 
%  that appear in assertions but do not affect the program dynamic behaviour in any way. 
%   
% When a correct-by-construction executable code is extracted
% from the specified program, this , called \textit{ghost code} disappear  together with
% specification. 
%The goal of this section is to present the idea of \textit{ghost} code,
%its use in program specification and to state some properties about its 
%extraction.
%
%Ghost code is a kind of program annotation that serves 
%as a support for program specification inside logical formulae and assertions.
%
%The main idea about ghost code is that as any other kind of
% specification it does not affect the program meaning. That is, ghost
% code does not correspond to any physical entity, and as such can by entirely erased from a program, without altering its formal meaning. 
% 
%In this section we describe a language where one can annotate programs 
%with such \textit{ghost code}.
%
%We start by formalizing the \textit{ghost}$\lambda$\textit{-calculus}, 
%a tiny language of simply typed $\lambda$-calculus enriched with ghost variables and ghost expressions.
%
%We then define ghost code \textit{erasure}, which transforms a well-typed g$\lambda $ term  to a term of standard  $\lambda$-calculus.
%Finally we state and proof a few basic preservation properties of such translation.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{g$\lambda$-Calculus Syntax and Semantics}
\renewcommand{\arraystretch}{1.1}
%The syntax of \gml is summarized below.\vspace{-0.5cm}
\begin{figure}[H]
\begin{adjustwidth}{-6em}{-4em}
\begin{displaymath}
\begin{array}{ll@{\hspace*{-0.1cm}}
							 l@{\hspace*{1.5cm} }
							 l|@{\hspace*{0.5cm}}
							 llll}
	\hline

  p & ::= 
  & & \textsc{programs} &  
  c & ::= 
	& & \textsc{constants} \\

	&  \vardecl ; \quad p       
	& & \textit{reference declaration} &
	&     0 ~| 1 ~| ... ~| n        
	& & \textit{integer} \\    
 
  & t 
  & & \textit{body} &
	&   \mathtt{true}~|\mathtt{false} 
  & & \textit{boolean} \\ 

	& & & &	 
	&  () 
 	& & \textit{unit} \\  	
 
  t & ::= 
  & & \textsc{terms} &
  & op
  & & \textit{built-in operators}\\ 

     
  &    c
  & & \textit{constant} & \\
   	  
    	      
  &     x^{\mf{B}}_{\tau} 
  & & \textit{variable} &
	op & :=       
	& & \textsc{built-in operators} \\   	
  
  
  &    \gabst{x}{}{}{t}         
  & & \textit{abstraction} &   	
  & +|~-|~=|~\mathtt{not}
  & & \textit{built-in operators}  \\ 
        
  &    v~v    
  & & \textit{application}
  & & & & \\		 	
   	
  & \gghost{t} 
  & & \textit{ghost~ term}   
  &  \tau & ::= 
  & & \textsc{types} \\ 
   	
  & \gllet    
  & & \textit{local binding} &
 	&  \mathtt{int}~ | ~\mathtt{bool}~ | ~\mathtt{unit}~  
  & & \textit{built-in types} \\ 	
   								   
  & \gif{v}{t}{t}
  & & \textit{if-branching}  &  
  &     \tau^{\mf{B}}  \rightarrow \tau  
  & & \textit{function type} \\  
   		 								      								   
  &	\glrec
  & &  \textit{recursive function}
  & & & & \\
   	   		
   	   								      								   
  &  	\glread
  & &  \textit{reference access} &
  \mathtt{ref}~\tau  &
	& & \textsc{reference's type}  \\      					
 	   
	&  	\gwrite{r}{B}{\tau}{v} 
	& &  \textit{reference assignment} & \\
	
	& & & & \mf{B} & ::= 
  & & \textsc{ghost indicator} \\
	
	{v} & ::= & & \textsc{values} &
	& \bot \mathtt{(* false *)} 
  & & \textit{raw code} \\ 
	
	
	&   c
  & & \textit{constant} & 
  
  & \top \mathtt{(* true *)} 
  & & \textit{ghost code} \\ 



	&		\glvar
	& & \textit{variable} & \\
	

	
  &   \glabst
  & & \textit{abstraction} &	\\
	
	
	
	
	&   \glrec
  & & \textit{recursive function} &	\\
	
 \hline						   
  \end{array} 
\end{displaymath} 
\caption{ \textbf{\gml Syntax} \hfill}
\end{adjustwidth}
\end{figure}
%
%Here, the letters \textit{p, t, v, c} are meta-variables for programs, terms, variables and constants respectively. 
%
%As we can see, g$\lambda$-calculus is just an extension of standard simply 
%typed $\lambda$-calculus with \texttt{arrow} and \texttt{unit} enriched
%with a construction \texttt{ghost t} for ghost terms. 
%Moreover, variables and formal arguments in abstraction are annotated with
%their type and \textit{ghost} mark $\mf{B}$ which indicates whether 
%it is ghost ($\top$) or not ($\bot$). \\
%
%The evaluation of g$\lambda$-calculus corresponds as well to the standard SOS call-by-value semantics of $\lambda$-calculus, except for the rule  \makebox{(\textsc{E-DeGhost})}.

\begin{figure}[H]
	\hrulefill
	\begin{spacing}{1.1} 

 $\delta(+, n, m) \triangleq ||n + m||$ 
 	(where $n,m$ are integers)\\
 $\delta(-, n, m) \triangleq  ||n - m||$ 
 	(idem)\\
 $\delta(\mathtt{not}, b) \triangleq  ||\neg b||$ 
 	(where b is a boolean)\\
 $\delta(\mathtt{=}, t, u) \triangleq ||t =_{\tau} u||$ 
 	(where $t$ and $u$ are both of the same type $\tau$)\\
	\end{spacing}
	\caption{ \textbf{\gml Semantics (Delta Rules)} \hfill}
	\hrulefill	\\
\end{figure}


\begin{figure}[H]
	\hrulefill
	\begin{spacing}{1.1} 
	
	\infax[E-Op] 
	{\ghead
		{ op~v_1 \dots v_k}{\mem}
		{ \delta(c,v_1 \dots v_k)}\mem \quad 
		\text{if } k = Arity(op) \text{ and }\delta(c,v)\text{ is defined }} 
	
  \infax[E-Clo]
	{\ghead
		{{op~v_1 \dots v_k}{\mem}}
		{\gabst{x}{}{}{op~v_1 \dots v_k ~ \glvar}\quad 
		\text{if } 1 \leq k < arity(op)}}		
	
	\infax[E-AppFun] 
	{\ghead
		{ (\lambda \gvar{x}{}{}.t)v\mem }
		{ \sbst{t}{\gvar{x}{}{}}{v}}\mem } 
	  

	\infax[E-AppRec]
	{\ghead
		{(\mathtt{rec}~ 
			\var{f}{\mf{B_{1}}}{\tarr{2}{1}{}}~\gvar{x}{2}{2}.t) v\mem}
		{t[\gvar{x}{2}{2} \mapsfrom v, 
			 \var{f}{1}{\tarr{2}{1}{}} \mapsfrom 
			 \mathtt{rec}~\var{f}{\mf{B_{1}}}{\tarr{2}{1}{}}
			 ~\gvar{x}{2}{2}.t]}\mem}		
	
	\infax[E-LetV]
	{\ghead
	 {\mathtt{let} ~ \gvar{x}{}{} = v_{1} ~ \mathtt{in}~ {t_{2}}\mem}
	 {\sbst{t_{2}}{\gvar{x}{}{}}{v_{1}}}\mem} 
	
	\infax[E-If-true]		
	{\ghead
		{\mathtt{if}~\mathtt{true}~\mathtt{then}~t_{1}~\mathtt{else}~t_{2}{\mem}}
		{t_{1}{\mem}}}
	
	\infax[E-If-false]		
	{\ghead
		{\mathtt{if}~\mathtt{false}~\mathtt{then}~t_{1}~\mathtt{else}~t_{2}{\mem}}
		{t_{2}{\mem}}}	

	\infax[E-DeGhost]	 	
	{\ghead{\text{ghost } t\mem}{t \mem}}

	\infax[E-Deref]	 	
	{\ghead
	{\gref{!r}{}{}{\mem}}
	{\mu_{}(\gref{r}{}{})}}

	\infax[E-Assign]
	{\ghead
		{\gref{r}{}{} := v\mem}
		{()_{|\mu[\gref{r}{}{} \mapsfrom ~ v]}}}
	
\end{spacing}
\caption{ \textbf{\gml Semantics (Head Reduction Rules)} \hfill}
\hrulefill	\\
\end{figure}
	
\begin{figure}[H]
	\hrulefill
	\begin{spacing}{1.1} 	
	
	\infrule[E-Head]
	{\gevalh{t}{\mu}{t'}{\mu'}}
	{\geval{t}{\mu}{t'}{\mu'}}
	
	\infrule[E-Context]
	{{t_{1}}\mem \rightarrow {{t'}_{1}}\memp}
	{\mathtt{let} ~ \gvar{x}{}{} = t_{1} ~ \mathtt{in}~ {t_{2}}\mem
		\rightarrow 
		\mathtt{let} ~ \gvar{x}{}{} = t_{1}' ~ \mathtt{in}~ {t_{2}}\memp}
  
%  
%	\infrule[E-AppLeft]
%	{{t_{1}}\mem \rightarrow {t'_{1}}\memp}
%	{{t_{1} t_{2}}\mem
%						\rightarrow {t'_{1}t_{2}}\memp}
%  
%	\infrule[E-AppRight]
%	{{\texttt{t}_{2}}\mem \rightarrow {\texttt{t}'_{2}}\memp}
%	{{\texttt{v}_{1} \texttt{t}_{2}}\mem 
%	\rightarrow {\texttt{v}_{1}\texttt{t}'_{2}}\memp}  
%
%	\infrule[E-IfT]
%	{{t_{1}}\mem \rightarrow {t'_{1}}\memp}
%	{\mathtt{if}~t_{1}~\mathtt{then}~t_{2}~\mathtt{else}~t_{3}{\mem}	
%	\rightarrow \mathtt{if}~t'_{1}~\mathtt{then}~t_{2}~\mathtt{else}~t_{3}{\memp}}
%
%	\infrule[E-AssignT]
%	{{t_{1}}\mem \rightarrow {t'_{1}}\memp}
%	{\stepone
%		{\gref{r}{}{} := t_{1}{\mem}}
%		{\gref{r}{}{} := t'_{1}{\memp}}}
\end{spacing}
\caption{ \textbf{\gml Semantics Context Rules} \hfill}
\hrulefill	\\
\end{figure}

\subsection{Typing Relation}
\begin{figure}[H]
\hrulefill
\begin{spacing}{1.01}
\begin{multicols}{2} 
	\infrule[T-Const]
		{\text{Typeof}(c) = \tau}
		{\typrule
			{c}
			{\tau}
			{\bot}
			{\bot}}
		
	\infrule[T-Var]
		{}
		{\typrule
			{\gvar{x}{}{}}
			{\tau}
			{\mf{B}}
			{\bot}}
	\end{multicols}
	
	\infrule[T-Decl]
		{\typrule
			{v}
			{\mf{B}}
			{\tau}
			{\bot}}
		{\typrule
			{\vardecl}
			{\text{ref } \tau}
			{\mf{B}}
			{\bot}}
	
	\infrule[T-Abs]
		{\typrule
			{t_{1}}
			{\tau_{1}}
			{\mf{B_{1}}}
			{\Sigma_{1}}\quad
			{\textcolor{BrickRed}
				{\overline{\mf{B}_{1} \wedge \Sigma_{1}}}}}
		{\typrule
			{\lambda \gvar{x}{2}{2}.t_{1}}
			{\tarrS{2}{1}{2}{1}}
			{\mf{B_{1}}}
			{\bot}}

	\infrule[T-App]
		{ \qquad\qquad
		\typrule
		 {t_{1}}
		 {\tau_{2}^{\mf{B}_{2}} 
		 \stackrel{\Sigma_{0}}{\longrightarrow} \tau_{1}}
		 {\mf{B}_{1}}
		 {\Sigma_{1}}	
		{\typrule
			{t_{2}}
			{\tau_{2}}
			{\mf{B'_{2}}}
			{\Sigma_{2}}\\
			{\textcolor{BrickRed}
			{\overline{(\mf{B}_{1} \vee 
			(\overline{\mf{B}_{2}}\wedge
			\mf{B'}_{2}))	\wedge	
			(\Sigma_{0}\vee\Sigma_{1}\vee\Sigma_{2})}
			\quad
			\textcolor{BrickRed}
			{\overline{\mf{B'_{2}} \wedge \Sigma_{2}}}
			\quad				
			\textcolor{BrickRed}
			{\mf{B}_{2} \Rightarrow \mf{B'}_{2}}}}
			}}
		{\typrule
			{t_{1}~t_{2}}
			{\tau_{1}}
			{\mf{B}_{1} \vee 
			(\overline{\mf{B}_{2}}\wedge
			\mf{B'}_{2})}
			{\Sigma_{0}\vee\Sigma_{1}\vee\Sigma_{2}}}

	\infrule[T-If]
		{
		\typrule
		{t_{1}}
		{\text{bool}}
		{\mf{B_{1}}}
		{\Sigma_{1}}
		\typrule
			{t_{2}}
			{\tau_{0}}
			{\mf{B}_{2}}
			{\Sigma_{2}}
			\typrule
			{t_{3}}
			{\tau_{0}}
			{\mf{B}_{3}}
			{\Sigma_{3}}\\
			{\textcolor{BrickRed}
			{\overline{
			(\mf{B}_{1}\vee
			\mf{B}_{2}\vee\mf{B}_{3}) \wedge
			 (\Sigma_{1}\vee\Sigma_{2}\vee\Sigma_{3})}}}}
		{\typrule
			{\text{if } t_{1} \text{ then } t_{2} 
		 	\text{ else } t_{3}}
		 	{\tau_{0}}
		 	{\mf{B_{1} \vee \mf{B_{2} \vee
		 	\mf{B_3}}}}
		 	{\Sigma_{1} \vee \Sigma_{2} \vee \Sigma_{3}}
		 }	
	
	\infrule[T-Rec]
		{\typrule
			{t_{1}}
			{\tau_{1}}
			{\mf{B}_{1}}
			{\Sigma_{1}}\quad
			{\textcolor{BrickRed}
			{\overline{\mf{B}_{1} \wedge \Sigma_{1}}}}}
		{\typrule
			{
			{\grec{1}{1}{2}{2}}}
			{\tarrS{2}{1}{2}{1}}
			{\mf{B_{1}}}
			{\bot}}
	
	\infrule[T-Let]
		{
		\typrule
			{t_{1}}
			{\tau_{1}}
			{\mf{B_{1}}}
			{\Sigma_{1}}\quad
		{\typrule
			{t_{2}}
			{\tau_{2}}
			{\mf{B'_{2}}}
			{\Sigma_{2}}\quad
			{\textcolor{BrickRed}
			{\overline{\mf{B'}_{2} \wedge \Sigma_{2}}
			}}}\\[0.2cm]
			{\textcolor{BrickRed}
			{\overline{(\mf{B}_{1} \vee 
			(\overline{\mf{B}_{2}}\wedge
			\mf{B'}_{2}))	\wedge	
			(\Sigma_{1}\vee\Sigma_{2})}
			\quad	\mf{B}_{2}
			\Rightarrow \mf{B'}_{2}}}}
		{\typrule
			{\text{let }\gvar{x}{2}{2}=t_{2}\text{ in }t_{1}}
			{\tau_{1}}
			{\mf{B}_{1} \vee 
			(\overline{\mf{B}_{2}}\wedge
			\mf{B'}_{2})}
			{\Sigma_{1}\vee\Sigma_{2}}}
		
	\begin{multicols}{2}
	\infrule[T-Ghost]
		{\typrule
			{t}
			{\tau}
			{\mf{B}}
			{\bot}}
		{\typrule
			{\mathtt{ghost  }~t}
			{\tau}
			{\top}
			{\bot}}

	\infrule[T-Deref]
		{}
		{\typrule
			{!\rvar{r}{}{}}
			{\tau}
			{\mf{B}}
			{\bot}}
	\end{multicols}
	
	\infrule[T-Assign]
		{\typrule
			{t_{2}}
			{\tau_{2}}
			{\mf{B_{2}}}
			{\Sigma_{2}}\quad
			{\textcolor{BrickRed}
			{\overline{(\mf{B}_{1} \vee \mf{B_2}) \wedge \Sigma_{2}}
			\quad
			{\mf{B_{2}} \Rightarrow \mf{B_{1}}}}}}
		{\typrule
			{\rvar{r}{1}{2} := t_{2}}
			{\text{unit}}
			{\mf{B_{1}}}
			{\overline{\mf{B}}_{1} \vee \Sigma_{2}}}

\end{spacing}
\caption{ \textbf{\gml Typing Rules with Effects}
 \hfill}
\hrulefill
\end{figure}

\subsubsection*{Invariant of Typing Relation}

The following lemma states that in well typed terms the ghost code 
does not write in any not ghost global references. 

\begin{lemma}[Invariant of Typing Relation] ~\\
If $\typrule{t}{\tau}{\mf{B}}{\Sigma}$ is a well typed term, 
then for any sub-term $t_{1}$ of t, such that 
\mbox{$\typrule{t_{1}}{\tau_{1}}{\mf{B_{1}}}{\Sigma_{1}}$}, 
the condition $\overline{\mf{B_{1}} \wedge \Sigma_{1}}$ 
holds.
\end{lemma}
\begin{proof}
By induction on typing derivations and case analysis
(the interesting cases are (\textsc{T-App}) and (\textsc{T-Let}) where the resulting invariant condition does not cover the case when ghost code
is used as argument by a non-ghost function,
so that argument invariant condition must be 
written in typing rules explicitly).
\end{proof}



%
%										
%The rules \textsc{(T-Unit)}, \textsc{(T-Var)} and \textsc{(T-Abs)} are straightforward.
%
%The rule \textsc{(T-Ghost)} states simply that a term of \texttt{ghost t}
%is a ghost code, whether \texttt{t} is ghost or not. That is, if \texttt{t} were a well-typed non-ghost term, once we put inside a ghost code, it becomes ghost itself. 
%
%The more complex rule \textsc{(T-App)} states that formal argument of $\texttt{t}_{1}$ and actual parameter $\texttt{t}_{2}$ must be
%of the same type. Moreover, it forbids the application of normal code
%to a function whose formal argument is ghost.  
%
%However, a function whose formal argument is not ghost is applied to a 
%ghost code, then the application itself becomes ghost, whether function's
%body is ghost or not. We summarized that is the following table:

\subsubsection*{Ghost-Code Propagation}
\begin{figure}[H]
\begin{center}
\begin{tabular}{|c|c|c|c|l|}
\hline
\multicolumn{5}{|c|} 
 {$\mathbf{t_{1}~t_{2}}:$ $\typrule
		 {t_{1}}
		 {\tau_{2}^{\mf{B}_{2}} 
		 \stackrel{\Sigma_{0}}{\longrightarrow} \tau_{1}}
		 {\mf{B}_{1}}
		 {\Sigma_{1}} \quad
		\typrule
			{t_{2}}
			{\tau_{2}}
			{\mf{B'_{2}}}
			{\Sigma_{2}}\quad
			{\textcolor{BrickRed}
			{\mf{B}_{2} \Rightarrow \mf{B'}_{2}}}		 $ 
			}
 			
			\\
\hline
$\mf{B_{2}}$ & $\mf{B_{1}}$ & $\mf{B'_{2}}$
 &  \multicolumn{2}{c|}{result} \\
\hline
$\bot$ & $\bot$ & $\bot$ & $\bot$ &  raw code application \\ \hline
$\top$ & $\bot$ & $\top$ & $\bot$ &  ghost-code passing inside normal code
\\ \hline
$\top$ & $\top$ & $\top$ & $\top$ &  ghost code application \\ \hline
$\bot$ & $\top$ & $\bot$ & $\top$ &  raw code passing inside ghost code
 \\ \hline
 \rowcolor{lightgray} 
 $\bot$ & $\top$ & $\top$ & $\top$ &formal parameter contamination \\ \hline
  \rowcolor{lightgray} 
 $\bot$ & $\bot$ & $\top$ & $\top$ &function parameter and body contamination \\ \hline
  $\top$ & $\bot$ & $\bot$ & $-$ & impossible \\ \hline
 $\top$ & $\top$ & $\bot$ & $-$ & impossible \\ \hline
 
\end{tabular}
\end{center}
\end{figure}  

 
%
%
%
%
%\subsubsection{Properties of typing}
%\begin{lemma}[Inversion of typing relation]~\\
%\vspace{-0.5cm}
%\begin{enumerate}
%	\item 
%	if $\tystepone{\texttt{ghost t}}{\tau_{1}}{\mf{B_{1}}}$ 
%	then	$ \mf{B_{1}} = \top $ 
%	and $\tystepone{\texttt{t}}{\tau_{1}}{\mf{B_{2}}} $.
%%	with $\mf{B_{2}} = \{\bot, \top\}$.
%	
% 	\item
% 	if $\tystepone
% 			{\lambda x_{\tau_{2}}^{\mf{B}_{2}}.\texttt{t}}
% 			{\tau_{1}}
% 			{\mf{B_{1}}}$
% 	then $\tau_{1} = \tau_{2}^{\mf{B}_{2}} \rightarrow \tau_{11}$
% 	for some $\tau_{11}$ with \mbox{$\tystepone{\texttt{t}}{\tau_{11}}{\mf{B_{1}}} $}.
%  
% \item 
% 	If ${\tystepone{\texttt{t}_{1}~ \texttt{t}_{2} }{\tau_{1}}{\mf{B}_{1}}}$
%	then there exist $\tau_{11}$, $\tau_{2}$, $\mf{B_{2}}$ and 	
%	$\mf{B'_{2}}$
%	such that \\ 
%	$\tystepone
%		{\texttt{t}_{1}}
%		{\tau_{2}^{\mf{B}_{2}} \rightarrow \tau_{11}}
%		{\mf{B_{1}}}$
%		and 
%	${\tystepone{\texttt{t}_{2}}{\tau_{2}}{\mf{B'}_{2}}}$ with \\
%	 \quad
%	\mbox{$\vDash \mf{B}_{1} \vee (\neg \mf{B}_{2} \wedge \mf{B'}_{2} ) \wedge (\mf{B}_{2} \Rightarrow \mf{B'}_{2})$}. 
%	
%	In particular, if 
% 		${\tystepone{\texttt{t}_{1}~ \texttt{t}_{2} }{\tau_{1}}{\bot}}$
%then $\vDash \mf{B_{2}} \Leftrightarrow \mf{B'_{2}} $.
%\end{enumerate}
%\end{lemma} 
%\begin{proof}
%Straightforward from definition of the typing relation.
%\end{proof}
%
%\begin{lemma}[Progress] 
%If \texttt{t} is a closed, well-typed term 
%(that is ${\tystepone{\texttt{t}}{\tau}{\mf{B}}}$ 
%for some $\tau$ and $\mf{B}$, 
%then either \texttt{t} is a value or else there is some \texttt{t}' 
%such that \mbox{\texttt{t} $\rightarrow_{g\lambda}$ \texttt{t}'}.
%\end{lemma}
%\begin{proof}
%Admit.
%\end{proof}
%
%Note that the typing preservation works only for well-typed non-ghost terms. Indeed,as the following example shows, the contamination of non-ghost code makes the preservation fail for ghost code: if we evaluate
%ghost code \quad \texttt{ghost} $(\lambda \gvarF{x}{unit}. \gvarF{x}{unit}) 
%\rightarrow_{g\lambda} \lambda \gvarF{x}{unit}. \gvarF{x}{unit}$,  
%then \\
%${\tystepone
%{\texttt{ghost} (\lambda \gvarF{x}{unit}. \gvarF{x}{unit}) }{unit \rightarrow unit}{\top}}$ holds, while the typing relation  ${\tystepone{\gvarF{x}{unit}}{unit}{\top}}$ fails.
%
%
%
%\begin{lemma}[Non-ghost Code Typing Preservation] 
%If ${\tystepone{\texttt{t}}{\tau}{\mf{\bot}}}$ 
%and \mbox{\texttt{t} $\rightarrow_{g\lambda}$ \texttt{t}'},
%then ${\tystepone{\texttt{t'}}{\tau}{\mf{\bot}}}$ 
%\end{lemma}
%\begin{proof}
%Admit.
%\end{proof}
%
%\begin{theorem}[Soundness] 
%\end{theorem}
%\begin{proof}
%Admit.
%\end{proof}
%\\e\_\{\\bot\}\(([^}]*)\)%
%--------------------------------------------------------------------------%
\subsection{Ghost Code Erasure}
\theoremstyle{remark}
\newtheorem{dfn}[theorem]{Definition}



\begin{figure}[H]
\hrulefill
\begin{dfn}[Type-Erasure] 
\label{type-erasure}
We define type-erasure function (parametrized by \{$\bot, top$\})  
by induction on the structure of types : \vspace{0.2cm} 

\noindent$ \e_{\top}(\tau) = \texttt{unit} $ \\
\noindent$ 
\e_{\bot}(\tau_{2}^{\mf{B_{2}}} \rightarrow \tau_{1})  
= \e_{\mf{B_{2}}}(\tau_{2}) \rightarrow \e_{\bot}(\tau_{1}) $. \\
\noindent$ \e_{\bot}(\tau_{1}) = \tau_{1}$ \qquad\qquad otherwise.\\

Also $\e_{\mf{B}}(\text{ref } \tau) = \text{ref } \e_{\mf{B}}(\tau) $.\\
\end{dfn}

\begin{dfn}[Term-Erasure]
Let \texttt{t} be a term such that 
~$\typrule{t}{\tau}{\mf{B}}{\Sigma}$ holds. 
We define term-erasure function 
$\e_{\mf{B}}(t)$ by induction on 
the structure of \texttt{t}: \\[0.1cm]
\noindent$ \e_{\top}(t_1) = () $ 
\quad where $ \typrule{t_{1}}{\tau_{1}}{\top}{\bot}$.\\
\noindent$ \ebot{c} = c $\\
\noindent$ \e_{\bot}(\gvar{x}{}{}) = x_{\ebot{\tau}} $\\
\noindent$ \e_{\bot}(\gabst{x}{2}{2}{t}) =  
\lambda x_{\e_{\mf{B_{2}}}(\tau_{2})}. \e_{\bot}(t_{1})$
\quad where $ \typrule{t_{1}}{\tau_{1}}{\bot}{\Sigma}$.\\
\noindent$ 
\ebot{t_1~t_2} =\e_{\bot}(t_{1})~\e_{\mf{B_{2}}}(t_{2})$ \\
where 
$\typrule{t_{1}}
	{\tau_{2}^{\mf{B}_{2}} 
	\stackrel{\Sigma_{0}}{\longrightarrow} \tau_{1}}
	{\bot}{\Sigma_1}$ and 
$ \typrule{t_{2}}{\tau_{2}}{\mf{B'_{2}}}{\Sigma_2}$.\\
\noindent
$\e_{\bot}(\mathtt{let}~\gvar{x}{2}{2}= t_2~\mathtt{in}~t_1) = 
\mathtt{let}~x_{\e_{\mf{B_2}}(\tau_2)} = \e_{\mf{B_2}}(t_2) ~\mathtt{in}~\ebot{~t_1}
 $\\
\noindent
$\e_{\bot}
(\mathtt{rec}~\var{f}{\bot}{}~\gvar{x}{2}{2}:\tau_{1}. t_1)
= 
\mathtt{rec}~\var{f}{}{}~x_{\evar{\mf{B_{2}}}{\tau_{2}}}:\ebot{\tau_{1}}. \ebot{t_1}$\\
\noindent
$\e_{\bot}(\mathtt{if}~t_1~\mathtt{then}~t_2~\mathtt{else}~t_3) 
=
\mathtt{if}~\ebot{t_1}~
\mathtt{then}~\ebot{t_2}~
\mathtt{else}~\ebot{t_3}$ \\
\noindent
$\e_{\bot}(!r^{\bot}_{\text{ref } \tau}) 
= !r_{\text{ref }\ebot{\tau}} $ \\
\noindent
$\e_{\bot}(r^{\bot}_{\text{ref }\tau} := t_2) = ~~
r_{\text{ref } \ebot{\tau}} := \ebot{t_2}$\\
\end{dfn}

\begin{dfn}[Global-Variable-Erasure]
$\phantom{.}\\ \e_{\top}(\mathtt{var}~r^{\top}_{\text{ref }\tau}= v~)
= \emptyset $ 
$\phantom{.}\\ \e_{\bot}(\mathtt{var}~r^{\bot}_{\text{ref }\tau}= v~)
= \mathtt{var}~r_{\text{ref }\ebot{\tau}}: \ebot{v} $ \\
\end{dfn}

\begin{dfn}[Memory-Erasure]
$\phantom{.}\\
\ebot{\mu} 
= \{\Big(r_{\text{ref } \ebot{\tau}},~
		 \e_{\bot}
		 	\big(\mu(r^{\bot}_{\text{ref } \tau})
		 	\big)\Big)\}$ \\
\end{dfn}
\caption{ \textbf{\gml Ghost-Code Erasure}}
\hrulefill
\end{figure}
\newpage
%
%
%
% 
%  & & \textit{body} &
%	& \gabst{x}{}{}{t}        
%	& & \textit{abstraction}\\    
%
%	& & & &	 
%	& \mathtt{rec}~\var{f}{\mf{B}}{\tarr{}{}}~
%	\gvar{x}{}{}. t    
%  & &  \textit{recursive function} \\ 
% 

							   
%  &  	\mathtt{!}\gref{r}{}{} 
%  & &  \textit{reference access} &
%  &     \tau^{\mf{B}}  \rightarrow \tau  
%  & & \textit{function type} \\    					
% 	   
%	&  	\gref{r}{}{} := t  
%	& &  \textit{reference assignment} & \\
%	
%	& & & &		\mathtt{ref}~\tau  &
%	& & \textsc{reference's type}  \\   
%  
%  & & & & \\  
%   	
%  & & & & \mf{B} & ::= 
%  & & \textsc{ghost indicator} \\
%         
%  & & & & &  \bot \mathtt{(* false *)} 
%  & & \textit{raw code} \\ 
%    
%  & & & & &  \top \mathtt{(* true *)} 
%  & & \textit{ghost code} \\ 


%
%\qquad Once we formally defined the simply typed lambda-calculus enriched with ghost expressions, our goal is to show that the computational meaning
% of non ghost well typed non-ghost $g\lambda$-terms is preserved by their translation to simply typed lambda-calculus.
%
%To achieve this, we start by defining the \textit{type-} and \textit{term-} \textit{erasure} functions from g$\lambda$-calculus to simply typed  $\lambda$-calculus. 


%\subsubsection{Ghost Erasure}
%
%
%\begin{dfn}[Type-Erasure] 
%\label{type-erasure}
%We define type-erasure by induction on the structure of types : \vspace{0.2cm} 
%
%\noindent$ \e_{\top}(\tau) = \texttt{unit} $ 
%
%\noindent$ \e_{\bot}(\texttt{unit}) = \texttt{unit}$ 
%
%\noindent$ \e_{\bot}(\tau_{2}^{\mf{B_{2}}} \rightarrow \tau_{1})  
%= \e_{\mf{B_{2}}}(\tau_{2}) \rightarrow \e_{\bot}(\tau_{1}) $. \\
%\end{dfn} 
%
%\begin{dfn}[Term-Erasure] 
%\label{term-erasure}
%Let \texttt{t} be a term such that 
%~~ $\tystepone{\texttt{t}}{\tau}{\mf{B}}$ ~ holds. 
%We define term-erasure function by induction on 
%the structure of \texttt{t}, parametrizing it by the value of 
%$ \mf{B}$. \\[0.1cm]
%$ \e_{\top}(\texttt{t}_{1}) = \texttt{()}$ 
%\quad where $ \tystepone{\texttt{t}_{1}}{\tau_{1}}{\top}$.\\[0.05cm]
%$\ebot{\texttt{(}}) = \texttt{()}$\\[0.05cm]
%$\e_{\bot}(x_{\tau}^{\bot}) = x_{\ebot{\tau}}$\\[0.05cm]  
%$\e_{\bot}(\lambda x_{\tau_{2}}^{\mf{B_{2}}}.t_{1}) 
%= \lambda x_{\e_{\mf{B_{2}}}(\tau_{2})}. \e_{\bot}(t_{1})$
%\quad where $ \tystepone{\texttt{t}_{1}}{\tau_{1}}{\bot}$.\\[0.05cm]
%$\e_{\bot}(\texttt{t}_{1} ~ \texttt{t}_{2}) 
%= \e_{\bot}(\texttt{t}_{1})  ~ \e_{\mf{B_{2}}}(\texttt{t}_{2})$
%\quad 
%where $ \tystepone{\texttt{t}_{1}}{\tau_{1}}{\bot}$
%and $ \tystepone{\texttt{t}_{2}}{\tau_{2}}{\mf{B_{2}}}$.
%\end{dfn}
%As it can be seen, the erasure function is a morphism that preserve
%the structure of operational (not ghost) terms and their types ($\sim\ebot{\star)$), and sends ghost expressions and types to \texttt{(}} and \texttt{unit} respectively ($\sim\e_{\top}(\star)$).
%
%Here is two examples of term erasure:
%
%$ 
%\e_{\top}[
%(\lambda \gvarF{z}{\tau_{1}}.\gvarF{z}{\tau_{1}})(\texttt{ghost }())] 
%= () $
%
%$
%\e{\bot}[
%(\lambda \gvarT{x}{\tau_{1}}. 
%\lambda \gvarF{y}{\tau_{1}}. \gvarF{y}{\tau_{1}}) 
%(\texttt{ghost }())] = 
%(\lambda x_{\texttt{unit}}. \lambda y_{\tau_{1}}.y_{\tau_{1}})() $ 
%
%


%--------------------------------------------------------------------------%
\subsection{Properties of ghost erasure}

Ghost code is a part of program specification.
Suppose we have a source program \textit{p} that we want to specify using
ghost code inside.

First of all, if our specification predicts statically some dynamic 
behaviour that \textit{p} does not even have, it is simply unsound.
\begin{figure}[H]
\begin{diagram}
t_{|\mu}	& : (\_, \bot, \_)	 \rTo^\epsilon{g\lambda} & &  
t'_{|\mu'} & : (\_, \bot, \_) \\
\dImplies^{\ebot{t_{|\mu}}} & & &   \dImplies_{\ebot{t'_{|\mu'}}} & & \\
p_{|\mu_0} & \textcolor{red}{\nrepeat{10}\cdot/\nrepeat8\cdot >}   & &  q_{|\mu_1}
\end{diagram}
\begin{adjustwidth}{5em}{5em}
\caption{\scriptsize{\textbf{
The ghost-ML "\textit{non ghost}" head reduction from a ghostML term $t$ (program $p$'s specification) to $t'$), to $t'$ 
does not correspond to any of reductions of $p$.}}}
\end{adjustwidth}
\end{figure}

On the other hand, if some dynamic behaviour of \textit{p} 
escapes from the specification, then such a specification does not reflect 
properly it's meaning, so it is useless for establishing the correctness of \textit{p}:
\begin{figure}[H]
\begin{diagram}
t_{|\mu}				             &   & \rTo_{g\lambda} &  
\textcolor{red}{t'_{|\mu'}} \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dImplies^{\ebot{t_{|\mu}}} &   &  &               &
 \rdImplies(2,2)^{\ebot{t'_{|\mu'}}}  \\
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
{p}_{|\mu_0}                  &   & \rTo_{\lambda}  & 
{p'}_{|\mu'_0} & \textcolor{red}{\neq} & \textcolor{red}{\_} 
\end{diagram}
\begin{adjustwidth}{5em}{5em}
\caption{\scriptsize{\textbf{
None of ghost-ML term's $t$ ($p$'s specification) reductions 
can reflect the reduction step from source program $p$ to $p'$.}}}
\end{adjustwidth}
\end{figure}

%\begin{diagram}
%t_{|\mu} & \textcolor{red}{\dashrightarrow_{g\lambda}} & 
%\textcolor{red}{t'_{|\mu'}}   \\
%\qquad \Longdownarrow_{\ebot{t_{|\mu}}}     &  & \qquad  \textcolor{red}{\Longdownarrow_{\ebot{t'_{|\mu'}}}}\\
%{t_{0}}_{|\mu_0}  & \longrightarrow_{\lambda}  &{t_{1}}_{|\mu_1}
%\end{diagram}


In this section we check the absence of those two pathological situations,
using a technique called \textit{bi-simulation}, which consists of 
the following two theorems:

\begin{theorem}[Forward Simulation]
If t is a closed ghost-ML term, such that\\ 
$\typrule{t}{\tau}{\bot}{\Sigma}$ ~holds and $\gevalstar{t}{v}{\mu}{\mu'}$ 
for some value v, then\\ 
$\levalstar{\ebot{t}}{\ebot{\mu}}{\ebot{v}}{\ebot{\mu'}}$.
\end{theorem}

\begin{theorem}[Backward Simulation]
If t is a closed ghost-ML term, such that 
\\ $\typrule{t}{\tau}{\bot}{\Sigma}$~holds and 
$\ebot{t}_{|\ebot{\mu}}$ = $\leval{{t_0}}{{\mu_0}}{{t_{1}}}{\mu_1}$ 
for some ML value $t_1$ and store $\mu_1$, 
then there exist a ghost-ML term t' and a store $\mu'$~
such that $t_1 =\ebot{t'}$, $\mu1 = \ebot{\mu'}$ and 
$\gevalstar{t}{\mu}{t'}{\mu'}$.
\end{theorem}

We begin by stating auxiliary lemmas which will help us deal with proving these theorems.
 
\subsubsection{Forward simulation}

\begin{lemma}[One Step Forward Simulation]
If t is a closed ghost-ML term, such that $\typrule{t}{\tau}{\bot}{\Sigma}$~holds 
and $\geval{t}{\mu}{t'}{\mu'}$, then 
${\ebot{t}}_{\ebot{\mu}} \rightarrow^{0|1} {\ebot{t'}}_{\ebot{\mu'}}$.
\end{lemma}







\begin{theorem}[Forward Simulation]
If t is a closed ghost-ML term, such that\\ 
$\typrule{t}{\tau}{\bot}{\Sigma}$ ~holds and $\gevalstar{t}{\mu}{v}{\mu'}$ 
for some value v, then\\ 
$\levalstar{\ebot{t}}{\ebot{\mu}}{\ebot{v}}{\ebot{\mu'}}$.
\end{theorem}





\begin{proof}
By induction on the length of the evaluation of 
$\gevalstar{t}{\mu}{v}{\mu'}$.
\begin{adjustwidth}{1em}{-3em}

\noindent ($\alpha$) \quad 
 if $\gevalh{t}{\mu}{v}{\mu'}$ then 	
 by \textit{one-step} forward simulation lemma,\\ 
$${\ebot{t}}_{\ebot{\mu}} \rightarrow^{0|1} {\ebot{v}}_{\ebot{\mu'}}.$$ 

\noindent ($\beta$) \quad Assume now that 
$\geval{t}{\mu}{t^{''}}{\mu^{''}}$ and  $t^{''}_{\mu^{''}} \rightarrow^{n} v_{\mu'}$
for some arbitrary $n \in \mathbb{N}$.
By the progress of Ghost-ML typing, 
$ \typrule{t''}{\tau}{\bot}{\Sigma''}$ (for some $\Sigma$ with $\Sigma \Rightarrow \Sigma''$ and some store $\mu^{''}$). By induction hypothesis 
on $t^{''}$, and by \textit{one step} forward lemma applied to $t$, 
we have that  
$${\ebot{t}}_{\ebot{\mu}} \rightarrow^{0|1} {\ebot{t''}}_{\ebot{\mu''}}
\rightarrow^{n} {\ebot{v}}_{\ebot{\mu'}}.$$ That is, for any $n \in \mathbb{N}$, $\gevalstar{\ebot{t}}{\ebot{\mu}}{\ebot{v}}{\ebot{\mu'}}$.
\end{adjustwidth}
\end{proof}




%cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Evaluation Preservation}
\begin{lemma}[Substitution under erasure] ~\\
If $\typrule
		{\texttt{t}_{1}}
		{\tau_{1}}
		{\bot}
		{\Sigma_1}$  
and 
	\mbox{
		$\typrule
			{\texttt{v}_{2}}
			{\tau_{2}}
			{\mf{B_{2}}}
			{\Sigma_2}$}	
hold, \\ 
then
$\e_{\bot}
	(\sbst
		{\texttt{t}_{1}}
		{x^{\mf{B_{2}}}_{\tau_{2}}}
		{\texttt{v}_{2}})
= \sbst
		{\e_{\bot}(\texttt{t}_{1})}
		{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
		{\e_{\mf{B_{2}}}(\texttt{v}_{2})}$
\label{Substitution under erasure}
\end{lemma}

\begin{proof}
By induction on the structure of $\texttt{t}_{1}$.  
%\\
%
%\noindent\textit{Case} 
%$\texttt{t}_{1} = x^{\mf{B_{2}}}_{\tau_{2}}$:\\
%In that case,  we can deduce that $\mf{B_{2}} = \bot$. Therefore:
%
%\begin{center}
% $\e_{\bot}
%	(\sbst
%		{x^{\bot}_{\tau_{2}}}
%		{x^{\bot}_{\tau_{2}}}
%		{\texttt{v}_{2}}) 
%	= \e_{\bot}(\texttt{v}_{2}) $ 
%	$= \sbst
%			{x_{\e_{\bot}(\tau_{2})}}
%			{x_{\e_{\bot}(\tau_{2})}}
%			{\e_{\bot}(\texttt{v}_{2})}$ \\[0.08cm]
%	$= \sbst
%			{\e_{\bot}(x^{\bot}_{\tau_{2}})}
%			{x_{\e_{\bot}(\tau_{2})}}
%			{\e_{\bot}(\texttt{v}_{2})}$
%\end{center}
%
%\noindent\textit{Case} $
%\texttt{t}_{1} = y^{\bot}_{\tau'_{2}} \neq x^{\mf{B_{2}}}_{\tau_{2}}$:
%\begin{center}
% $\e_{\bot}
%	(\sbst
%		{y^{\bot}_{\tau'_{2}}}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}}) 
%	= \e_{\bot}(y^{\bot}_{\tau'_{2}}) 
%	= y_{\e_{\bot}(\tau'_{2})} $ \\[0.08cm]
%$ = \sbst
%			{y_{\e_{\bot}(\tau'_{2})}}
%			{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
%			{\e_{\mf{B_{2}}}(\texttt{v}_{2})}$ 
%$ = \sbst
%			{\e_{\bot}(y^{\bot}_{\tau'_{2}})}
%			{x_{\e_{\mf{B_{2}}(\tau_{2})}}}
%			{\e_{\mf{B_{2}}}(\texttt{v}_{2})}$
%\end{center}
%
%\noindent\textit{Case} 
%$\texttt{t}_{1} 
%= \lambda y^{\mf{B'_{2}}}_{\tau'_{2}}. t_{11} \quad \text{ with }   
%y^{\mf{B'_{2}}}_{\tau'_{2}} \not\in \texttt{FV}(\texttt{v}_{2}) 
%\text{ and } \neq x^{\mf{B_{2}}}_{\tau_{2}} : $
%\begin{center}
% $\e_{\bot}
%	(\sbst
%		{(\lambda y^{\mf{B'_{2}}}_{\tau'_{2}}. t_{11})}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}})
%	= \e_{\bot}[\lambda y^{\mf{B'_{2}}}_{\tau'_{2}}.
%	(\sbst
%		{ t_{11}}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}})] $\\[0.08cm]
%$	= \lambda y_{\e_{\mf{B'_{2}}}(\tau'_{2})}.
%		\e_{\bot}(
%		\sbst
%			{\texttt{t}_{11}}
%			{x^{\mf{B_{2}}}_{\tau_{2}}}
%			{\texttt{v}_{2}})] $\\[0.08cm]
%$ \stackrel{Ind.Hyp.}{=} 
%	\lambda y_{\e_{\mf{B'_{2}}}(\tau'_{2})}.		
%	\sbst
%			{\e_{\bot}(\texttt{t}_{11})}
%			{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
%			{\e_{\mf{B_{2}}}(\texttt{v}_{2})}$ \\[0.08cm]
%$	= \sbst
%			{(\lambda y_{\e_{\mf{B'_{2}}}(\tau'_{2})}.
%				\e_{\bot}(\texttt{t}_{11}))}
%			{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
%			{\e_{\mf{B_{2}}}(\texttt{v}_{2})}$ \\[0.08cm]
%$ = 
%	\sbst
%			{\e_{\bot}(\lambda y^{\mf{B'_{2}}}_{\tau'_{2}}. t_{11}) }
%			{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
%			{\e_{\mf{B_{2}}}(\texttt{v}_{2})}$
%\end{center}
%
%\noindent\textit{Case} 
%$\texttt{t}_{1} = \texttt{t}_{11}\texttt{t}_{12} $
%\begin{center}
% $\e_{\bot}
%	(\sbst
%		{\texttt{t}_{11}\texttt{t}_{12}}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}}) 	$ 
%$	= \e_{\bot}
%	(\sbst
%		{\texttt{t}_{11}}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}} ~
%	\sbst
%		{\texttt{t}_{12}}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}}) 	  $ \\[0.08cm]
%$ = \e_{\bot}
%	(\sbst
%		{\texttt{t}_{11}}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}}) ~
%	\e_{\bot}
%	(\sbst
%		{\texttt{t}_{12}}
%		{x^{\mf{B_{2}}}_{\tau_{2}}}
%		{\texttt{v}_{2}}) 	  $ \\[0.08cm]
%$ \stackrel{Ind.Hyp.}{=} 
%		(\sbst
%			{\e_{\bot}({\texttt{t}_{11}})}
%			{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
%			{\e_{\mf{B_{2}}}(\texttt{v}_{2})})	
%		(\sbst
%			{\e_{\bot}({\texttt{t}_{12}})}
%			{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
%			{\e_{\mf{B_{2}}}(\texttt{v}_{2})})	$ \\[0.08cm]
%$ = 
%	\sbst
%		{\e_{\bot}(\texttt{t}_{11} \texttt{t}_{12})}
%		{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
%		{\e_{\mf{B_{2}}}(\texttt{v}_{2})})	$\\[0.08cm]
%\end{center}
 \end{proof}



\theoremstyle{remark}

\begin{lemma}[One-step evaluation under erasure]
For any closed g$\lambda$-term \texttt{t} such that
$\typrule{t}{\tau}{\bot}{\Sigma_1}$ holds, 
if	$\texttt{t}\mem \rightarrow_{g\lambda} \texttt{t}'\memp$ 
for some term \texttt{t}', 
then either 
\text{$\e_{\bot}(\texttt{t}) \rightarrow_{\lambda} \ebot{t'}$} 
or 		$\e_{\bot}(\texttt{t}) = \ebot{t'}$. 
\end{lemma}

\begin{proof} 
By induction on the evaluation relation of 
$\texttt{t} \rightarrow_{g\lambda} \texttt{t}'$. \\

\noindent\textit{Case} \textsc{E-AppAbs}: \qquad
$ ~\texttt{t} 
= (\lambda x^{\mf{B_{2}}}_{\tau_{2}}.
		\texttt{t}_{1})\texttt{v}_{1}$ ~with~
$ (\lambda x^{\mf{B_{2}}}_{\tau_{2}}.
		\texttt{t}_{1})\texttt{v}_{1} 
	\stackrel{\epsilon\quad}{\rightarrow_{g\lambda}}  
	\sbst
		{\texttt{t}_{1}}
		{x^{\mf{B_{2}}}_{\tau_{2}}}
		{\texttt{v}_{1}}$\\
\phantom{\noindent\textit{Case} \textsc{E-AppAbs}: \qquad }		
$ \tystepone
		{(\lambda x^{\mf{B_{2}}}_{\tau_{2}}.\texttt{t}_{1})\texttt{v}_{1}}	
		{\tau_{1}}
		{\mf{B_{1}}}, \quad 
 	\tystepone
 		{\texttt{v}_{1}}
 		{\tau_{2}}
 		{\mf{B'_{2}}}, $ \\
\phantom{\noindent\textit{Case} \textsc{E-AppAbs}: \qquad }		
$ \mf{B_{1}} = \bot,  \quad 
	\vDash\mf{B_{2}} \Leftrightarrow \mf{B'_{2}} $ 

\begin{center}
	\begin{tabular}{lll}
   & $ \e_{\bot}
  [(\lambda x^{\mf{B_{2}}}_{\tau_{2}}.
  		\texttt{t}_{1})\texttt{v}_{1}]$ &\\
   & $ = \lambda x_{\e_{\mf{B_{2}}}(\tau_{2})}. 
   \e_{\bot}(\texttt{t}_{1}))\e_{\mf{B'_{2}}}(\texttt{v}_{1})$ 
   & (as $ \mf{B_{1}} = \bot $)  \\
&  $ \stackrel{\epsilon~~}{\rightarrow_{\lambda}} 
	   \sbst
   		{\e_{\bot}(\texttt{t}_{1})}
   		{x_{\e_{\mf{B_{2}}}(\tau_{2})}}
   		{\e_{\mf{B'_{2}}}(\texttt{v}_{1})}$ & (head red.) \\
& $ = \e_{\bot}(\sbst{\texttt{t}_{1}}{x^{\mf{B_{2}}}_{\tau_{2}}}{\texttt{v}_{1}}) $ & (by Substitution under erasure lemma)
	\end{tabular}
\end{center}

\noindent\textit{Case} \textsc{E-DeGhost}:  \qquad \\ Trivially verified,
as for any instance of $\tystepone{(ghost ~ \texttt{t}_{1})}{\tau_{1}}{\mf{B_{1}}}$, $\mf{B_{1}} = \top $.\\

\noindent\textit{Case} \textsc{E-AppLeft}: \qquad 
 $\texttt{t} = \texttt{t}_{1} \texttt{t}_{2},\quad
 \texttt{t}^{'} = \texttt{t}^{'}_{1} \texttt{t}_{2}, ~ \text{ with }
 \texttt{t}_{1} \rightarrow_{g\lambda} \texttt{t}^{'}_{1}$ \\
\phantom{\noindent\textit{Case} \textsc{E-AppLeft}: \qquad}		
$\tystepone{\texttt{t}_{1}}{\tau_{2}^{\mf{B_{2}}} \rightarrow \tau_{1}}{\mf{B_{1}}}$,  ~
$\tystepone{\texttt{t}_{2}}{\tau_{2}}{\mf{B'_{2}}}, $ \\ 
\phantom{\noindent\textit{Case} \textsc{E-AppLeft}: \qquad}		
$ \mf{B_{1}} = \bot,  \quad 
\vDash\mf{B_{2}} \Leftrightarrow \mf{B'_{2}} $ \\

As $\mf{B_{1}} = \bot$, we can apply induction hypothesis on
$\texttt{t}_{1}$ which gives  
$\e_{\bot}(\texttt{t}_{1}) \rightarrow_{\lambda} 
\e_{\bot}(\texttt{t}_{1}^{'})$.
Then, applying \textsc{E-AppRight} rule, we obtain:
$$
\e_{\bot}(\texttt{t}) 
= \e_{\bot}(\texttt{t}_{1})\e_{\bot}(\texttt{t}_{2})
\rightarrow_{\lambda} 
\e_{\bot}(\texttt{t}^{'}_{1})\e_{\bot}(\texttt{t}_{2})
= \e_{\bot}(\texttt{t}^{'}).$$




\noindent\textit{Case} \textsc{E-AppRight}: \qquad 
 $\texttt{t} = \texttt{v}_{1} \texttt{t}_{2},\quad
 \texttt{t}^{'} = \texttt{v}_{1} \texttt{t}^{'}_{2}, ~ \text{ with }
 \texttt{t}_{2} \rightarrow_{g\lambda} \texttt{t}^{'}_{2}$ \\
\phantom{\noindent\textit{Case} \textsc{E-AppRight}: \qquad}		
$\tystepone{\texttt{v}_{1}}{\tau_{2}^{\mf{B_{2}}} \rightarrow \tau_{1}}{\mf{B_{1}}}$,  ~
$\tystepone{\texttt{t}_{2}}{\tau_{2}}{\mf{B'_{2}}}, $ \\ 
\phantom{\noindent\textit{Case} \textsc{E-AppRight}: \qquad}		
$ \mf{B_{1}} = \bot,  \quad 
\vDash\mf{B_{2}} \Leftrightarrow \mf{B'_{2}} $ \\
If $\mf{B_{2}} = \mf{B'_{2}} = \top $, then
$$\e_{\bot}(\texttt{t}) 
= \e_{\bot}(\texttt{v}_{1})\e_{\top}(\texttt{t}_{2})
= (\e_{\bot}(\texttt{v}_{1}))\texttt{()}
= \e_{\bot}(\texttt{v}_{1})\e_{\top}(\texttt{t}^{'}_{2})
= \e_{\bot}(\texttt{t}^{'}). $$
Otherwise, $\mf{B_{2}} = \mf{B'_{2}} = \bot $.
By induction hypothesis, 
$\e_{\bot}(\texttt{t}_{2}) \rightarrow_{\lambda} 
\e_{\bot}(\texttt{t}_{2}^{'})$.
Then, applying \textsc{E-AppRight} rule, we obtain:
$$
\e_{\bot}(\texttt{t}) 
= \e_{\bot}(\texttt{v}_{1})\e_{\bot}(\texttt{t}_{2})
\rightarrow_{\lambda} 
\e_{\bot}(\texttt{v}_{1})\e_{\bot}(\texttt{t}^{'}_{2})
= \e_{\bot}(\texttt{t}^{'}).$$




%
%
%By canonical forms lemma, $\texttt{v}_{2} = 
%\lambda x^{\mf{B_{2}}}_{\tau_{2}}. \texttt{t}_{2} $.    
 
% $\texttt{t} = \texttt{E t}_{1},\quad
% \texttt{t'} = \texttt{E t'}_{1}, \quad
% \texttt{t}_{1} \rightarrow_{g\lambda} \texttt{t'}_{1}$  

\end{proof}

Now we can prove the main theorem.
\begin{theorem}[Value preservation under erasure]
	For any closed g$\lambda$-term \texttt{t} such that
	$\tystepone{\texttt{t}}{\tau}{\bot}$ holds, 
	if	$\texttt{t} \rightarrow^{\ast}_{g\lambda} \texttt{v}$ for some value \texttt{v}, then
	 \text{$\e(\texttt{t}) \rightarrow^\ast_{\lambda} \e(v)$}. 
\end{theorem}
\begin{proof} By induction on the length of the evaluation of 
$\texttt{t} \rightarrow^{\ast}_{g\lambda} \texttt{v}$. 


We already have proved the base case : indeed, if $\texttt{t} \rightarrow_{g\lambda} \texttt{v}$ then by the one-step evaluation lemma, 
$\e_{\bot}(\texttt{t}) \rightarrow^{0 | 1}_{\lambda} 
\e_{\bot}(\texttt{v})$. 

Now, assume that $\texttt{t} \rightarrow^{1}_{g\lambda} 
\texttt{t}' \rightarrow^{n}_{g\lambda}  \texttt{v}$
for some arbitrary $n \in \mathbb{N}$.
By the progress of typing, 
$ \tystepone{\texttt{t}'}{\tau}{\bot} $, so we can apply induction hypothesis on $\texttt{t}'$ which gives~
$\e(\texttt{t}') \rightarrow^\ast_{\lambda} \e(\texttt{v})$.
By the one-step evaluation lemma again, we have 
$\e_{\bot}(\texttt{t}) \rightarrow^{0 | 1}_{\lambda} 
\e_{\bot}(\texttt{t}')$. 
That is, 
$\e_{\bot}(\texttt{t}) \rightarrow^{\ast}_{\lambda} 
\e_{\bot}(\texttt{v})$.
\end{proof}





\subsubsection{Typing Erasure}
\begin{lemma}[Typing relation under erasure]~ \\
	If  $\tystepone{\texttt{t}}{\tau}{\bot}$  
	then \text{$\vdash_{\lambda}  \e_{\bot}(\texttt{t}) 
	~:~\e_{\bot}({\tau})$}.
\end{lemma}
\begin{proof}
By induction on a derivation of the statement 
\text{$\vdash_{g\lambda}  \e_{\bot}(\texttt{t}) ~:~\e_{\bot}({\tau})$}. 
For a given derivation, we proceed by case analysis on the final typing rule
 used in the proof. 
 
 	\noindent\textit{Case} \textsc{T-Unit}:\quad 
 	$\tystepone{\texttt{()}}{\texttt{unit}}{\bot}$
 	
 	Immediately by definition of $\e_{\bot}$.\\[0.08cm] 
% 		As  $\ebot{\texttt{(}}) = \texttt{()}$ and $ \e_{\bot}(\texttt{unit}) = \texttt{unit}$
% 		 we have immediately $\vdash_{\lambda} \texttt{()} : \texttt{unit}$.
 	\noindent\textit{Case} \textsc{T-Var}:\quad 
 	$\tystepone{x_{\tau}^{\bot}}{\tau}{\bot}$
 	 
 	 $\e_{\bot}(x_{\tau}^{\bot}) = x_{\ebot{\tau}}$ gives  immediately 
 	 $\vdash_{\lambda} x_{\ebot{\tau}} : \e(\tau)$.\\[0.08cm] 
 	\noindent\textit{Case} \textsc{T-Abs}:\quad
 		$\tystepone{\lambda x_{\tau_{2}}^{\mf{B}_{2}}.\texttt{t}_{1}}
 		{\tau_{2}^{_{2}} \rightarrow 
 		\tau_{1}}{\bot}~ \text{with} \tystepone{\texttt{t}_{1}}{\tau_{1}}{\bot}	$
 		
 		By induction hypothesis $\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}) : \e_{\bot}(\tau_{1}) $.
 		There are two cases to consider, depending on whether the parameter 
 		of the abstraction is ghost or not. If $\mf{B_{2} = \top}$ then 
 		$\e_{\bot}(\lambda x_{\tau_{2}}^{\top}. \texttt{t}_{1}) = \lambda x_{\texttt{unit}}. \e(\texttt{t}_{1})$
 		and therefore
 		\infrule[T-Abs]
 		{\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}) : \e_{\bot}(\tau_{2})}
 		{ \vdash_{\lambda} \lambda x_{\texttt{unit}}.\e_{\bot}(\texttt{t}_{1}) : 
 		\texttt{unit} \rightarrow 	\e_{\bot}(\tau_{1})} 
 	
 		Otherwise $\mf{B_{2} = \bot}$ and again by the rule \textsc{T-Abs} 
 		we obtain :
 		\infrule[T-Abs]
 		{\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}) : \e_{\bot}(\tau_{1})}
 		{ \vdash_{\lambda} \lambda x_{\e_{\bot}(\tau_{2})}.\e_{\bot}(\texttt{t}_{1}) : 
 		\e_{\bot}(\tau_{2}) \rightarrow 	\e_{\bot}(\tau_{1})}
 		
 		 	
 	\noindent\textit{Case} \textsc{T-App}:\quad
 	$\tystepone{\texttt{t}_{1}~\texttt{t}_{2}}{\tau_{1}}{\bot} $ ~
 	with sub-derivations: \\
	\phantom{{Case} \textsc{T-App}: \qquad}
	$\tystepone{\texttt{t}_{1}}
	{\tau_{2}^{\mf{B}_{2}} \rightarrow \tau_{1}}{\mf{B}_{1}}$ \\
	\phantom{\textit{Case} \textsc{T-App}: \qquad}	
	$ \tystepone{\texttt{t}_{2}}{\tau_{2}}{\mf{B'}_{2}} $, \quad 
%	and constraints: \\ 
%	\phantom{\textit{Case} \textsc{T-App}: \qquad}	
%	$ \mf{B}_{1}\vee (\neg \mf{B}_{2} \wedge \mf{B'}_{2})=\bot,$
%	$ \mf{B}_{2} \Rightarrow \mf{B'}_{2} = \top $ \\
	
%	By lemma's statement, $\texttt{t}_{1}~\texttt{t}_{2}$ 
%	should not be a ghost term. Therefore
%	$\mf{B}_{1}\vee (\neg \mf{B}_{2} \wedge \mf{B'}_{2})=\bot$.
%	From that and from the rule's premise condition 
%	$ \mf{B}_{2} \Rightarrow \mf{B'}_{2} = \top $ 
%	we deduce 

As $\tystepone{\texttt{t}_{1}~\texttt{t}_{2}}{\tau_{1}}{\bot} $, the inversion lemma gives as 
By inversion that $\vDash \mf{B}_{2} \Leftrightarrow \mf{B'}_{2}$. That is, we have two cases to consider.
	
	If \text{$ \mf{B}_{2} = \mf{B'}_{2} = \bot $} 
	then by induction hypotheses \\
	$\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}) : 
	\e_{\bot}(\tau_{2}) \rightarrow \e_{\bot}(\tau_{1}) $ and
	\text{$\vdash_{\lambda} \e_{\bot}(\texttt{t}_{2}) : \e_{\bot}(\tau_{2}) $}.
	By  \textsc{T-App} rule,
	\infrule[T-App]
	{\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}) : 
	\e_{\bot}(\tau_{2}) \rightarrow \e_{\bot}(\tau_{1}) 
	\qquad
	\vdash_{\lambda} \e_{\bot}(\texttt{t}_{2}) : \e_{\bot}(\tau_{2}) }
	{\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}~\texttt{t}_{2}): \e(\tau_{1})}  
	
	If \text{$ \mf{B}_{2} = \mf{B'}_{2} = \top $},
	then by definition of $\e$ we have $\e(\texttt{t}_{2}) = \texttt{()}$ 
	and $\e_{\mf{B'_{2}}}(\tau_{2}) = \texttt{unit}$. 
	By induction hypothesis on $\texttt{t}_{1}$,
	\text{$\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}) : 
	\texttt{unit} \rightarrow \e_{\bot}(\tau_{1}) $}. 
	Applying \textsc{T-App} rule gives us \\

\hspace*{1.2in}
\infer[\mbox{\textsc{(T-App)}}]
 {\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}~\texttt{t}_{2}): \e_{\bot}(\tau_{1})}
 {\infer
   {\vdash_{\lambda} \e_{\bot}(\texttt{t}_{1}~\texttt{t}_{2}): \e(\tau_{1})}
   {}
   &
 \infer[\mbox{\textsc{(T-Unit)}}]
  {\vdash_{\lambda} \texttt{()} : \texttt{unit}}
  {}}	\\
  
  	The case of (\textsc{T-Ghost}) as well as any other valid derivation  
  	where a typed term is marked as ghost do not satisfy lemma's requirement, 
  	so these cases are trivially verified.									
\end{proof}

%TODO:
%Extensions:
%- If-then-else
%- rec
%- let in
%- match 
%- constructors
%- ref global mono
%- types polymorphes
%- operators
%
%Potential difficulties:
%- polymorphism
%- schemes
%- non interference
%
%-->(E,E')
%
%règles de typage
%règles d'effacement




%\begin{adjustwidth}{-22em}{-2em}
%\begin{spacing}{1.4}
%
%
%\infax[E-AppFun] {\stepone{(\lambda x^{b}_{\tau}.\texttt{t})v}{\sbst{\texttt{t}}{x^{b}_{\tau}}{v}}} 
%
%\infax[E-DeGhost]	 	{\stepone{\texttt{ghost t}}{\texttt{t}}}
%   \end{minipage}
%\hphantom{....}
%
%   \begin{minipage}{0.5\linewidth}
%  \infrule[T-AppLeft]{{\texttt{t}_{1}} \rightarrow {\texttt{t}'_{1}}}{{\texttt{t}_{1} \texttt{t}_{2} } \rightarrow {\texttt{t}'_{1} \texttt{t}_{2}}}
%  
%\infrule[T-AppRight]{{\texttt{t}_{2}} \rightarrow {\texttt{t}'_{2}}}{{\texttt{v}_{1} \texttt{t}_{2} } \rightarrow {\texttt{v}_{1} \texttt{t}'_{2}}}  
%
%    
%   \end{minipage}
%   
%\end{spacing}
%\end{adjustwidth}



%  	 \begin{flushright}  	 \textbf{Evaluation}  	 \end{flushright}
%  	\infax[E-AppFun]    	{\stepone{(\lambda x^{b}_{\tau}.\texttt{t})v}{\sbst{\texttt{t}}{x^{b}_{\tau}}{v}}}
%	\infax[E-DeGhost]	 	{\stepone{\texttt{ghost t}}{\texttt{t}}}
%%	\infrule[E-Context]{{\texttt{t}} \rightarrow {\texttt{t}'}}{{\texttt{E[t]}} \rightarrow {\texttt{E[t']}}}
%%	\begin{center}
%% 	 where ~ \texttt{E}   $::= \square$  | \texttt{E}~\texttt{t} |	 \texttt{v} \texttt{E}
%% 	 \end{center}	 
%	\infrule[T-AppLeft]{{\texttt{t}_{1}} \rightarrow {\texttt{t}'_{1}}}{{\texttt{t}_{1} \texttt{t}_{2} } \rightarrow {\texttt{t}'_{1} \texttt{t}_{2}}}
%	\infrule[T-AppLeft]{{\texttt{t}_{2}} \rightarrow {\texttt{t}'_{2}}}{{\texttt{v}_{1} \texttt{t}_{2} } \rightarrow {\texttt{v}_{1} \texttt{t}'_{2}}}	
%\caption{ \textbf{\glam syntax and semantics} \hfill}

%
%\subsubsection*{Free variables, scope and equivalence of terms} 
%We do not present here the formal definitions of free variables, 
%abstraction scope, $\alpha$-equivalence and substitution: they are exactly 
%the same that those of $\lambda$-calculus.
%
%However, it is important to notice that two variables $x^{\mf{B_{1}}}_{\tau_{1}}$ and  
%$y^{\mf{B_{2}}}_{\tau_{2}}$ are syntactically equal only if 
%$x = y$, $\mf{B_{1}} = \mf{B_{2}}$ and $ \tau_{1} = \tau_{2} $. That is  $\lambda \gvarT{x}{1}. \gvarT{x}{1}$ corresponds to $\tau_{1}$- identity, whilst  $\lambda \gvarT{x}{1}. \gvarF{x}{1}$ corresponds to the constant function that ignores its argument. 
%
%
%  	 \begin{flushright}  	 \textbf{Typing}  	 \end{flushright}
%	\infrule[T-Unit]	 	{}{\tystepone{()}{unit}{\bot}} 
%	
%	\infrule[T-Var]	 	{}{\tystepone{x^{\mf{B}}_{\tau}}{\tau}{\mf{B}}}
%	
%	\infrule[T-Ghost]	 {\tystepone{\texttt{t}}{\tau}{\mf{B}}}{\tystepone{\texttt{ghost t}}{\tau}{\top}}
%	
%	\infrule[T-Abs]	 	 {\tystepone{\texttt{t}}{\tau_{2}}{\mf{B}_{2}}}
%										{\tystepone{\lambda x_{\tau_{1}}^{\mf{B}_{1}}.\texttt{t}}{\tau_{1}^{\mf{B}_{1}} \rightarrow \tau_{2}}{\mf{B}_{2}}}
%										
%	\infrule[T-App]	 
%	{\tystepone{\texttt{t}_{1}}{\tau_{2}^{\mf{B}_{2}} \rightarrow \tau_{1}}{\mf{B}_{1}} 
%	\qquad  {\tystepone{\texttt{t}_{2}}{\tau_{2}}{\mf{B'}_{2}}}
%	\qquad \mf{B}_{2} \Rightarrow \mf{B'}_{2}}
%	{\tystepone{\texttt{t}_{1}~ \texttt{t}_{2} }{\tau_{1}}{\mf{B}_{1} \vee (\neg \mf{B}_{2} \wedge \mf{B'}_{2} ) }}

%In the simply typed $\lambda$-calculus, typing rules out  statically some erroneous programs. For instance, it allows to check that when function is applied to some argument, the type of the formal parameter corresponds to that one of actual parameter.
%
%The typing of the programs containing some ghost code should of course 
%assure the same safety with respect of program evaluation. However, in the presence of ghost code, this should also include the \textit{non-interference} of ghost code with the rest of the program. Intuitively, the \textit{non-interference} means that computation of ghost code must be completely disjoint from the computation of the non-ghost code. 
%
%To assure that, we define the typing relation as three-argument predicate  
%\fbox{${}{\tystepone{t}{\tau}{\mf{B}}} $} which both carries statically the information about type of term $t$, and indicates whether
%this term is ghost or not. Formally, we define the typing relation inductively over the structure of terms as follows: