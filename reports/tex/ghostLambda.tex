\section{GhostLambda: Lambda-Calculus with Ghost Code}
%ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
Annotating a program with logical formulae predicting statically it dynamic behaviour is a 
keystone of the deductive software verification approach.

Typically, these logical formulae are assertions about program assigned variables,
 loop invariants, recursive function variants, etc. 
 
 However,  it is often useful to annotate programs with some data that appear in program 
  that appear in assertions but do not affect the program dynamic behaviour in any way. 
   
 When a correct-by-construction executable code is extracted
 from the specified program, this , called \textit{ghost code} disappear  together with
 specification. 
 
In this section we describe a language where one can annotate programs with such \textit{ghost code}.
We start by formalizing \textit{ghost}$\lambda$\textit{-calculus}, a tiny language of simply typed $\lambda$-calculus enriched with ghost variables and ghost expressions.
We then define ghost code \textit{erasure}, which transforms a well-typed ghostLambda term  to a term of standard  $\lambda$-calculus.
Finally we state and proof a few basic preservation properties of such translation.



\subsection{Syntax and Semantics}
The syntax and small-step operational semantics of \glam is summarized in ~\autoref{fig:syntax}.
\begin{figure}[!h]
	  \hrule 
  	 \begin{flushright}  	 \textbf{Syntax}  	 \end{flushright}
\begin{displaymath}
 \begin{array}{lll@{\hspace*{2.5cm} }l}
	\grtitle{\texttt{t}}{\textsc{terms:}}
  	\grcase{()}{unit}
  	\grcase{\glvar}{variable}
  	\grcase{\lambda \glvar.\texttt{t}}{abstraction}
  	\grcase{\texttt{t} \texttt{t}}{application}
  	\grcase{\texttt{ghost t}}{ghost term} \\
  	\grtitle{\texttt{v}}{\textsc{values:}}
  	\grcase{()}{unit}
  	\grcase{\lambda \glvar.\texttt{t}}{abstraction}
  	\\
  	\grtitle{\mathfrak{B}}{\textsc{ghost status :}}
  	\grcase{\top ~~(*true*)}{ghost code} 
   	\grcase{\bot~~(*false*)}{physical code} \\
  	\\
  	\grtitle{\tau}{\textsc{types:}}
  	\grcase{\texttt{unit}}{unit type}
  	\grcase{\tau^{\mathfrak{B}} \rightarrow \tau}{function type}
  \end{array} 
\end{displaymath} 
  \hrule 
  	 \begin{flushright}  	 \textbf{Evaluation}  	 \end{flushright}
  	\infax[E-AppFun]    	{\stepone{(\lambda x^{b}_{\tau}.\texttt{t})v}{\sbst{\texttt{t}}{x^{b}_{\tau}}{v}}}
	\infax[E-DeGhost]	 	{\stepone{\texttt{ghost t}}{\texttt{t}}}
	\infrule[E-Context]{{\texttt{t}} \rightarrow {\texttt{t}'}}{{\texttt{E t}} \rightarrow {\texttt{E t}'}}
	\begin{center}
 	 where ~ \texttt{E}   $::= \square$  | \texttt{E}~\texttt{t} |	 \texttt{v} \texttt{E}
 	 \end{center}	 
\caption{ \textbf{\glam syntax and semantics} \hfill}
\label{fig:syntax}
\end{figure}
\newpage
\subsection{Typing}
The typing relation of \glam is summarized in ~\autoref{fig:typing}.
\begin{figure}[!h]
%	
% 	 	  \hrule
%  	 \begin{flushright}  	 \textbf{Typing}  	 \end{flushright}
	\infrule[T-Unit]	 	{}{\tystepone{()}{unit}{\bot}} \vspace*{0.4cm}
	
	\infrule[T-Var]	 	{}{\tystepone{x^{\mathfrak{B}}_{\tau}}{\tau}{\mathfrak{B}}}\vspace*{0.4cm}
	
	\infrule[T-Ghost]	 {\tystepone{\texttt{t}}{\tau}{\mathfrak{B}}}{\tystepone{\texttt{ghost t}}{\tau}{\top}}\vspace*{0.4cm}
	
	\infrule[T-Abs]	 	 {\tystepone{\texttt{t}}{\tau_{2}}{\mathfrak{B}_{2}}}
										{\tystepone{\lambda x_{\tau_{1}}^{\mathfrak{B}_{1}}.\texttt{t}}{\tau_{1}^{\mathfrak{B}_{1}} \rightarrow \tau_{2}}{\mathfrak{B}_{2}}}\vspace*{0.4cm}
										
	\infrule[T-App]	 
	{\tystepone{\texttt{t}_{1}}{\tau_{2}^{\mathfrak{B}_{2}} \rightarrow \tau_{1}}{\mathfrak{B}_{1}} 
	\qquad  {\tystepone{\texttt{t}_{2}}{\tau_{2}}{\mathfrak{B'}_{2}}}
	\qquad \mathfrak{B}_{2} \Rightarrow \mathfrak{B'}_{2}}
	{\tystepone{\texttt{t}_{1}~ \texttt{t}_{2} }{\tau_{1}}{\mathfrak{B}_{1} \vee (\neg \mathfrak{B}_{2} \wedge \mathfrak{B'}_{2} ) }}
										
\caption{ \textbf{\glam  } typing relation \hfill}
\label{fig:typing}
\end{figure}




%--------------------------------------------------------------------------%
\subsection{Ghost Code Erasure}
\newcommand{\e}{\mathcal{E}}
\theoremstyle{remark}
\newtheorem{dfn}[theorem]{Definition}

\qquad Once we formally defined the simply typed lambda-calculus enriched with ghost expressions, our goal is to show that terms which are not ghost 
themselves have the same computational behaviour as their translation to
lambda-calculus, which preserves the structure of terms except for ghost sub-expressions. 

Therefore we need to define at first a type-erasure and a term-erasure translations from g$\lambda$-calculus to standard simply typed  
$\lambda$-calculus:  

\begin{dfn}[Type-Erasure] 
\label{type-erasure}
We define type-erasure by induction on the structure of types : \vspace{0.2cm} 

\noindent$ \e_{\top}(\tau) = \texttt{unit} $ 

\noindent$ \e_{\bot}(\texttt{unit}) = \texttt{unit}$ 

\noindent$ \e_{\bot}(\tau_{2}^{\mathfrak{B_{2}}} \rightarrow \tau_{1})  
= \e_{\mathfrak{B_{2}}}(\tau_{2}) \rightarrow \e_{\bot}(\tau_{1}) $. \\
\end{dfn} 

\begin{dfn}[Term-Erasure] 
\label{term-erasure}
Let \texttt{t} be a term such that 
~~ $\tystepone{\texttt{t}}{\tau}{\mathfrak{B}}$ ~ holds. 
We define term-erasure function by induction on 
the structure of \texttt{t}\\[0.1cm]
$ \e_{\top}(\texttt{t}) = \texttt{()}$\\[0.05cm]
$\e_{\bot}(\texttt{()}) = \texttt{()}$\\[0.05cm]
$\e_{\bot}(x_{\tau}^{\bot}) = x_{\e_{\bot}(\tau)}$\\[0.05cm]  
$\e_{\bot}(\lambda x_{\tau_{2}}^{\mathfrak{B_{2}}}.t) 
= \lambda x_{\e_{\mathfrak{B_{2}}}(\tau_{2})}. \e_{\bot}(t)$\\[0.05cm]  
$\e_{\bot}(\texttt{t}_{1} ~ \texttt{t}_{2}) 
= \e_{\bot}(\texttt{t}_{1})  ~ \e_{\bot}(\texttt{t}_{2})$.
\end{dfn}
As it can be seen, the erasure function is a morphism that preserve
the structure of operational (not ghost) terms and their types ($\sim\e_{\bot}(\star)$), and sends ghost expressions and types to \texttt{()} and \texttt{unit} respectively ($\sim\e_{\top}(\star)$).




%--------------------------------------------------------------------------%
\subsection{Properties of Ghost Code Erasure}

Now that we defined the erasure-translation of $g\lambda$-calculus to $\lambda$-calculus, our concern is to prove that evaluation of well-typed operational terms is preserved under erasure. However we need to state a 
few basic lemmas before we can prove it. 



    


\subsubsection{Typing Erasure}
\begin{lemma}[Translation of Typing Relation]
	If  $\tystepone{\texttt{t}}{\tau}{\bot}$  
	then \text{$\vdash_{\lambda}  \e(\texttt{t}) ~:~\e({\tau})$}.
\end{lemma}
\begin{proof}
By induction on a derivation of the statement 
\text{$\vdash_{g\lambda}  \e(\texttt{t}) ~:~\e({\tau})$}. 
For a given derivation, we proceed by case analysis on the final typing rule
 used in the proof. 
 
 	\noindent\textit{Case} \textsc{T-Unit}:\quad 
 	$\tystepone{\texttt{()}}{\texttt{unit}}{\bot}$ 
 	
 		As  $\e(\texttt{()}) = \texttt{()}$ and $ \e(\texttt{unit}) = \texttt{unit}$
 		 we have immediately $\vdash_{\lambda} \texttt{()} : \texttt{unit}$.
 	
 	\noindent\textit{Case} \textsc{T-Var}:\quad 
 	$\tystepone{x_{\tau}^{\bot}}{\tau}{\bot}$
 	 
 	 As  $\e(x_{\tau}^{\bot}) = x_{\e(\tau)}$, we have immediately 
 	 $\vdash_{\lambda} x_{\e(\tau)} : \e(\tau)$.
 	 

 	\noindent\textit{Case} \textsc{T-Abs}:\quad
 		$\tystepone{\lambda x_{\tau_{1}}^{\mathfrak{B}_{1}}.\texttt{t}}
 		{\tau_{1}^{_{1}} \rightarrow 
 		\tau_{2}}{\bot}~ \text{with} \tystepone{\texttt{t}}{\tau_{2}}{\bot}	$
 		
 		By induction hypothesis $\vdash_{\lambda} \e(\texttt{t}) : \e(\tau_{2}) $.
 		There are two cases to consider, depending on whether the parameter 
 		of the abstraction is ghost or not. If $\mathfrak{B_{1} = \top}$ then 
 		$\e(\lambda x_{\tau_{1}}^{\top}. \texttt{t}) = \lambda (). \e(\texttt{t})$
 		and therefore
 		\infrule[T-Abs]
 		{\vdash_{\lambda} \e(\texttt{t}) : \e(\tau_{2})}
 		{\lambda (). \vdash_{\lambda} \e(\texttt{t}) : 
 		\texttt{unit} \rightarrow 	\e(\tau_{2})} 
 	
 		Otherwise $\mathfrak{B_{1} = \bot}$ and again by the rule \textsc{T-Abs} 
 		we obtain :
 		\infrule[T-Abs]
 		{\vdash_{\lambda} \e(\texttt{t}) : \e(\tau_{2})}
 		{\lambda x_{\e(\tau_{1})}. \vdash_{\lambda} \e(\texttt{t}) : 
 		\e(\tau_{1}) \rightarrow 	\e(\tau_{2})}
 		
 		 	
 	\noindent\textit{Case} \textsc{T-App}:\quad
 	$\tystepone{\texttt{t}_{1}~\texttt{t}_{2}}{\tau_{1}}{\mathfrak{B}_{1}} $ ~
 	with sub-derivations: \\
	\phantom{{Case} \textsc{T-App}: \qquad}
	$\tystepone{\texttt{t}_{1}}
	{\tau_{2}^{\mathfrak{B}_{2}} \rightarrow \tau_{1}}{\mathfrak{B}_{1}}$ \\
	\phantom{\textit{Case} \textsc{T-App}: \qquad}	
	$ \tystepone{\texttt{t}_{2}}{\tau_{2}}{\mathfrak{B'}_{2}} $, \quad 
	and constraints: \\ 
	\phantom{\textit{Case} \textsc{T-App}: \qquad}	
	$ \mathfrak{B}_{1}\vee (\neg \mathfrak{B}_{2} \wedge \mathfrak{B'}_{2})=\bot,$
	$ \mathfrak{B}_{2} \Rightarrow \mathfrak{B'}_{2} = \top $ \\
	
	By lemma's statement, $\texttt{t}_{1}~\texttt{t}_{2}$ 
	should not be a ghost term. Therefore
	$\mathfrak{B}_{1}\vee (\neg \mathfrak{B}_{2} \wedge \mathfrak{B'}_{2})=\bot$.
	From that and from the rule's premise condition 
	$ \mathfrak{B}_{2} \Rightarrow \mathfrak{B'}_{2} = \top $ 
	we deduce that $\mathfrak{B}_{1} = \bot$ 
	and that \text{$ \mathfrak{B}_{2} \Leftrightarrow \mathfrak{B'}_{2}=\top $},
	so we have to cases two consider.
	
	If \text{$ \mathfrak{B}_{2} = \mathfrak{B'}_{2} = \bot $} 
	then by induction hypotheses: 
	\text{$\vdash_{\lambda} \e(\texttt{t}_{1}) : 
	\e(\tau_{2}) \rightarrow \e(\tau_{1}) $} and
	\text{$\vdash_{\lambda} \e(\texttt{t}_{2}) : \e(\tau_{2}) $}.
	Applying  \textsc{T-App} rule gives us 
	\text{$\vdash_{\lambda} \e(\texttt{t}_{1}~\texttt{t}_{2}): \e(\tau_{1}) $}
	(where \text{$\e(\texttt{t}_1)\e(\texttt{t}_{2}) =
	 \e(\texttt{t}_{1}~\texttt{t}_{2})$} as \text{$\mathfrak{B_{1} = \bot}$}).  	 
	
	If \text{$ \mathfrak{B}_{2} = \mathfrak{B'}_{2} = \top $} 
	then by induction hypothesis,
	\text{$\vdash_{\lambda} \e(\texttt{t}_{1}) : 
	\texttt{unit} \rightarrow \e(\tau_{1}) $}. 
	Also by definition of $\e$ we have $\e(\texttt{t}_{2}) = \texttt{()}$, 
	and $\e(\tau_{2}, \mathfrak{B'_{2}}) = \texttt{unit}$. 
	Applying \textsc{T-App} rule gives us \\

\hspace*{1.2in}
\infer[\mbox{\textsc{(T-App)}}]
 {\vdash_{\lambda} \e(\texttt{t}_{1}~\texttt{t}_{2}): \e(\tau_{1})}
 {\infer
   {\vdash_{\lambda} \e(\texttt{t}_{1}~\texttt{t}_{2}): \e(\tau_{1})}
   {}
   &
 \infer[\mbox{\textsc{(T-Unit)}}]
  {\vdash_{\lambda} \texttt{()} : \texttt{unit}}
  {}}	
  
  	The case (\textsc{T-Ghost}) as well as any other valid derivation  
  	where a typed term is marked as ghost do not satisfy lemma's requirement, 
  	so these cases are trivially verified.									
\end{proof}






\subsubsection{Evaluation Preservation}
\begin{theorem}[Evaluation under erasure]
	For any closed g$\lambda$-term \texttt{t} such that
	$\tystepone{\texttt{t}}{\tau}{\bot}$ holds, 
	if	$\texttt{t} \rightarrow \texttt{t'}$ for some term \texttt{t'}, then
	 \text{$\e(\texttt{t}) \rightarrow \e(t')$}. 
\end{theorem}
\begin{proof} By induction on the evaluation relation of $\texttt{t} \rightarrow \texttt{t'}$. \\

\noindent\textit{Case} \textsc{E-AppAbs}: \qquad 
 $\tystepone{(\lambda x^{\mathfrak{B_{2}}}_{\tau_{2}}.\texttt{t})v}{\tau_{1}}{\bot} $ \\
\phantom{\noindent\textit{Case} \textsc{E-AppAbs}: \qquad }		
$(\lambda x^{\mathfrak{B_{2}}}_{\tau_{2}}.\texttt{t})v 
\rightarrow \sbst{\texttt{t}}{x^{\mathfrak{B_{2}}}_{\tau_{2}}}{v}$ \\


\begin{center}
\begin{tabular}{lll}
   & $\e[(\lambda x^{\bot}_{\tau_{2}}.\texttt{t})\texttt{v}]$ &\\
   & $= \e(\lambda x^{\bot}_{\tau_{2}}.\texttt{t}) ~ \e(\texttt{v})$ 
   & ($ \mathfrak{B_{1}} = \bot $)  \\
 	& $ = \lambda x_{\texttt{unit}}. \e(\texttt{t}))\e(\texttt{()})$ 
 	& ($\mathfrak{B_{2}} = \mathfrak{B'_{2}} = \bot $) \\
   &  $ \stackrel{\epsilon}{\rightarrow} 
   \sbst{\e(\texttt{t})}{x^{\bot}_{\texttt{unit}}}{()}$ & (head red.) \\
   & $ \e(\sbst{\texttt{t}}{x^{\bot}_{\texttt{unit}}}{()}) $ 
   & (by Lemma) 

 \end{tabular}
  \end{center}
\end{proof}

\begin{lemma}[Evaluation preservation under erasure]
	For any closed g$\lambda$-term \texttt{t} such that
	$\tystepone{\texttt{t}}{\tau}{\bot}$ holds, 
	if	$\texttt{t} \rightarrow^{\ast} \texttt{v}$ for some value \texttt{v}, then
	 \text{$\e(\texttt{t}) \rightarrow^\ast \e(v)$}. 
\end{lemma}
\begin{proof}

\end{proof}
